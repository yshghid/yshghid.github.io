<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>알고리즘 on</title><link>https://yshghid.github.io/docs/study/algorithm/</link><description>Recent content in 알고리즘 on</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Fri, 01 Aug 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://yshghid.github.io/docs/study/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>MutClust 코드 리펙토링 #2 arg_parser</title><link>https://yshghid.github.io/docs/study/algorithm/algo2/</link><pubDate>Fri, 01 Aug 2025 00:00:00 +0000</pubDate><guid>https://yshghid.github.io/docs/study/algorithm/algo2/</guid><description>&lt;h1 id="mutclust-코드-리펙토링-2-arg_parser">
 MutClust 코드 리펙토링 #2 arg_parser
 &lt;a class="anchor" href="#mutclust-%ec%bd%94%eb%93%9c-%eb%a6%ac%ed%8e%99%ed%86%a0%eb%a7%81-2-arg_parser">#&lt;/a>
&lt;/h1>
&lt;p>#2025-08-01&lt;/p>
&lt;hr>
&lt;p>MutClust 알고리즘의 코드 구성은 아래와 같은데&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span>MutClust
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── sc/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── lib.py
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── arg_parser.py // 실행 설정
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── utils.py
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── Test
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>arg_parser.py는 실험 환경 파라미터 세팅 및 CLI 인자 파싱을 포함한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># === arg_parser.py ===&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">import&lt;/span> argparse
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">from&lt;/span> os.path &lt;span style="color:#fff;font-weight:bold">import&lt;/span> exists
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">from&lt;/span> src.mlib &lt;span style="color:#fff;font-weight:bold">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DIMINISHING_FACTOR, EPSILON, EPSILON_SCALING_FACTOR,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MAX_EPS, MIN_CLUSTER_LENGTH, CCM_MIN_PERCENTAGE_SUM
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">class&lt;/span> ArgsInfo:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">def&lt;/span> __init__(&lt;span style="color:#fff;font-weight:bold">self&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.args = {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.fin = &lt;span style="color:#0ff;font-weight:bold">&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.ref = &lt;span style="color:#0ff;font-weight:bold">&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.outdir = &lt;span style="color:#0ff;font-weight:bold">&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.eps = EPSILON
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.maxeps = MAX_EPS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.min_persum = CCM_MIN_PERCENTAGE_SUM
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.eps_scaler_const = EPSILON_SCALING_FACTOR
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.es_control_const = DIMINISHING_FACTOR
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.min_cluster_length = MIN_CLUSTER_LENGTH
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> set_env(input_path=&lt;span style="color:#fff;font-weight:bold">None&lt;/span>, reference=&lt;span style="color:#fff;font-weight:bold">None&lt;/span>, output_path=&lt;span style="color:#fff;font-weight:bold">None&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> info = ArgsInfo()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parser = argparse.ArgumentParser(prog=&lt;span style="color:#0ff;font-weight:bold">&amp;#34;cluster.py&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parser.add_argument(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;-f&amp;#39;&lt;/span>, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;--input_file&amp;#39;&lt;/span>, &lt;span style="color:#fff;font-weight:bold">type&lt;/span>=&lt;span style="color:#fff;font-weight:bold">str&lt;/span>, default=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;/data3/projects/2020_MUTCLUST/Data/Rawdata/COVID19/nucleotide_data/mutclust_input_data.txt&amp;#39;&lt;/span>, help=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;mutation frequency data file&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parser.add_argument(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;-r&amp;#39;&lt;/span>, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;--ref&amp;#39;&lt;/span>, &lt;span style="color:#fff;font-weight:bold">type&lt;/span>=&lt;span style="color:#fff;font-weight:bold">str&lt;/span>, default=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;/data3/projects/2020_MUTCLUST/Data/Rawdata/COVID19/nucleotide_data/new_reference.fasta&amp;#39;&lt;/span>, help=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;the reference genome&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parser.add_argument(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;-e&amp;#39;&lt;/span>, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;--eps&amp;#39;&lt;/span>, &lt;span style="color:#fff;font-weight:bold">type&lt;/span>=&lt;span style="color:#fff;font-weight:bold">int&lt;/span>, default=EPSILON, help=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;width of window (epsilon)&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parser.add_argument(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;--maxeps&amp;#39;&lt;/span>, &lt;span style="color:#fff;font-weight:bold">type&lt;/span>=&lt;span style="color:#fff;font-weight:bold">int&lt;/span>, default=MAX_EPS, help=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;maximum eps&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parser.add_argument(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;--minps&amp;#39;&lt;/span>, &lt;span style="color:#fff;font-weight:bold">type&lt;/span>=&lt;span style="color:#fff;font-weight:bold">float&lt;/span>, default=CCM_MIN_PERCENTAGE_SUM, help=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;minimum per_sum&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parser.add_argument(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;--es&amp;#39;&lt;/span>, &lt;span style="color:#fff;font-weight:bold">type&lt;/span>=&lt;span style="color:#fff;font-weight:bold">float&lt;/span>, default=EPSILON_SCALING_FACTOR, help=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;eps scaling factor&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parser.add_argument(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;--exd&amp;#39;&lt;/span>, &lt;span style="color:#fff;font-weight:bold">type&lt;/span>=&lt;span style="color:#fff;font-weight:bold">float&lt;/span>, default=DIMINISHING_FACTOR, help=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;cluster expansion es diminishing factor&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parser.add_argument(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;--minl&amp;#39;&lt;/span>, &lt;span style="color:#fff;font-weight:bold">type&lt;/span>=&lt;span style="color:#fff;font-weight:bold">int&lt;/span>, default=MIN_CLUSTER_LENGTH, help=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;minimum cluster length&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> args = parser.parse_args()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> info.fin = input_path &lt;span style="color:#fff;font-weight:bold">if&lt;/span> input_path &lt;span style="color:#fff;font-weight:bold">else&lt;/span> args.input_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> info.ref = reference &lt;span style="color:#fff;font-weight:bold">if&lt;/span> reference &lt;span style="color:#fff;font-weight:bold">else&lt;/span> args.ref
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> info.outdir = output_path &lt;span style="color:#fff;font-weight:bold">if&lt;/span> output_path &lt;span style="color:#fff;font-weight:bold">else&lt;/span> &lt;span style="color:#0ff;font-weight:bold">&amp;#39;./output&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> not exists(info.fin):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34;Input file does not exist: &lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>info.fin&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exit()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> info.eps = args.eps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> info.maxeps = args.maxeps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> info.min_persum = args.minps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> info.eps_scaler_const = args.es
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> info.es_control_const = args.exd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> info.min_cluster_length = args.minl
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> info
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>MutClust 코드 리펙토링 #3 utils</title><link>https://yshghid.github.io/docs/study/algorithm/algo9/</link><pubDate>Fri, 01 Aug 2025 00:00:00 +0000</pubDate><guid>https://yshghid.github.io/docs/study/algorithm/algo9/</guid><description>&lt;h1 id="mutclust-코드-리펙토링-3-utils">
 MutClust 코드 리펙토링 #3 utils
 &lt;a class="anchor" href="#mutclust-%ec%bd%94%eb%93%9c-%eb%a6%ac%ed%8e%99%ed%86%a0%eb%a7%81-3-utils">#&lt;/a>
&lt;/h1>
&lt;p>#2025-08-01&lt;/p>
&lt;hr>
&lt;p>MutClust 알고리즘의 코드 구성은 아래와 같은데&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span>MutClust
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── sc/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── lib.py
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── arg_parser.py
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── utils.py // 전처리 및 분석
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── Test
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>utils.py는 데이터 전처리 및 분석 함수를 포함한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># === Fasta 전처리 ===&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> fasta2csv(home_dir, nation_dir, filechunk, ref, outdir):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> file in filechunk:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path = os.path.join(home_dir, nation_dir, file)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filename = os.path.splitext(os.path.basename(file))[&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> outpath = os.path.join(outdir, &lt;span style="color:#0ff;font-weight:bold">f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>filename&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">.csv&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> not os.path.exists(outpath):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df = DataFrame({&lt;span style="color:#0ff;font-weight:bold">&amp;#39;ref&amp;#39;&lt;/span>: ref.values, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;pos&amp;#39;&lt;/span>: ref.index})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seq = &lt;span style="color:#0ff;font-weight:bold">&amp;#39;&amp;#39;&lt;/span>.join(&lt;span style="color:#fff;font-weight:bold">open&lt;/span>(path).readlines()[&lt;span style="color:#ff0;font-weight:bold">1&lt;/span>:]).strip()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df[&lt;span style="color:#0ff;font-weight:bold">&amp;#39;mut&amp;#39;&lt;/span>] = [a &lt;span style="color:#fff;font-weight:bold">if&lt;/span> a != ref[i] &lt;span style="color:#fff;font-weight:bold">else&lt;/span> &lt;span style="color:#0ff;font-weight:bold">&amp;#39;&amp;#39;&lt;/span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> i, a in &lt;span style="color:#fff;font-weight:bold">enumerate&lt;/span>(seq)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df.to_csv(outpath, index=&lt;span style="color:#fff;font-weight:bold">False&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> gisaid_fasta2csv(homedir=&lt;span style="color:#0ff;font-weight:bold">f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>GISAID_DIR&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">/Sequence/Preprocessed/&amp;#34;&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inputdir = os.path.join(homedir, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;MSA_fasta&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> outdir = os.path.join(homedir, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;MSA_mutationinfo&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Path(outdir).mkdir(exist_ok=&lt;span style="color:#fff;font-weight:bold">True&lt;/span>, parents=&lt;span style="color:#fff;font-weight:bold">True&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> core_n = &lt;span style="color:#ff0;font-weight:bold">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> args_list = []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> nation_dir in get_dirnames_list(inputdir):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filelist = get_filenames_list(os.path.join(inputdir, nation_dir))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> chunk in array_split(filelist, core_n):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> args_list.append((inputdir, nation_dir, chunk, ref_seq, outdir))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">with&lt;/span> Pool(core_n) &lt;span style="color:#fff;font-weight:bold">as&lt;/span> pool:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pool.map(fasta2csv, args_list)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># === Nucleotide 전처리 ===&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> get_nucleotide_sequence_dict(seq_dir):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seq_dict = &lt;span style="color:#fff;font-weight:bold">dict&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seq_list = get_filenames_list(seq_dir)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> file in seq_list:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filepath = os.path.join(seq_dir, file)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df = read_csv(filepath, index_col=&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df.name = file.split(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;.&amp;#39;&lt;/span>)[&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df = df.reset_index(drop=&lt;span style="color:#fff;font-weight:bold">True&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seq_dict[df.name] = df
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> seq_dict
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> getNucleotideRefSeqbyGene():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> read_csv(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;/data3/projects/2020_MUTCLUST/Data/Annotation/Nucleotide/covid_annotation.tsv&amp;#39;&lt;/span>, sep=&lt;span style="color:#0ff;font-weight:bold">&amp;#39; &amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> make_nucleotide_mutclust_input(outdir, name, seq_dict=&lt;span style="color:#fff;font-weight:bold">None&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> not os.path.exists(outdir):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(outdir + &lt;span style="color:#0ff;font-weight:bold">&amp;#39; is not exist&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> output_path = os.path.join(outdir, name + &lt;span style="color:#0ff;font-weight:bold">&amp;#39;_mutclust_input.tsv&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> freq_df_ATGC_path = os.path.join(outdir, name + &lt;span style="color:#0ff;font-weight:bold">&amp;#39;_freq_ATGC.csv&amp;#39;&lt;/span>) 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pos_list, freq_list, per_list, entropy_list = [], [], [], []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> not os.path.exists(freq_df_ATGC_path):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> seq_dict is &lt;span style="color:#fff;font-weight:bold">None&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;load seq_dict&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> freq_df = DataFrame.from_dict(seq_dict).transpose().fillna(&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>).astype(&lt;span style="color:#fff;font-weight:bold">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> freq_df = freq_df.sort_index()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> freq_df = freq_df[&lt;span style="color:#fff;font-weight:bold">list&lt;/span>(IUPAC_CODES.keys())][[&lt;span style="color:#0ff;font-weight:bold">&amp;#39;A&amp;#39;&lt;/span>,&lt;span style="color:#0ff;font-weight:bold">&amp;#39;T&amp;#39;&lt;/span>,&lt;span style="color:#0ff;font-weight:bold">&amp;#39;G&amp;#39;&lt;/span>,&lt;span style="color:#0ff;font-weight:bold">&amp;#39;C&amp;#39;&lt;/span>]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> freq_df.to_csv(freq_df_ATGC_path)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> freq_df = read_csv(freq_df_ATGC_path, index_col=&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> pos in freq_df.index:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> freq = freq_df.loc[pos]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cnt_n = freq.sum()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> percentage = freq / cnt_n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> entrpy = entropy(percentage, base=&lt;span style="color:#ff0;font-weight:bold">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> percentage.drop(ref_seq[pos], inplace=&lt;span style="color:#fff;font-weight:bold">True&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> freq.drop(ref_seq[pos], inplace=&lt;span style="color:#fff;font-weight:bold">True&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pos_list.append(&lt;span style="color:#fff;font-weight:bold">int&lt;/span>(pos))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> freq_list.append(freq.sum())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> per_list.append(percentage.sum())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> entropy_list.append(entrpy)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mutclust_input_df = DataFrame({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0ff;font-weight:bold">&amp;#39;Position&amp;#39;&lt;/span>: pos_list,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0ff;font-weight:bold">&amp;#39;Frequency&amp;#39;&lt;/span>: freq_list,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0ff;font-weight:bold">&amp;#39;Percentages&amp;#39;&lt;/span>: per_list,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0ff;font-weight:bold">&amp;#39;Entropy&amp;#39;&lt;/span>: entropy_list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mutclust_input_df.to_csv(output_path, sep=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\t&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>, index=&lt;span style="color:#fff;font-weight:bold">False&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> mutclust_input_df
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># === Mutation 데이터 병렬 처리 ===&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> read_thead(filepathlist, return_list, i):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ref_seq_sr = getNucleotideRefSeq()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sub_dict = {pos: Counter({k: &lt;span style="color:#ff0;font-weight:bold">0&lt;/span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> k in IUPAC_CODES.keys()}) &lt;span style="color:#fff;font-weight:bold">for&lt;/span> pos in ref_seq_sr.index}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> filepath in filepathlist:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df = read_csv(filepath, index_col=&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>).fillna(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&amp;#39;&lt;/span>).reset_index(drop=&lt;span style="color:#fff;font-weight:bold">True&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> index, mut in &lt;span style="color:#fff;font-weight:bold">enumerate&lt;/span>(df[&lt;span style="color:#0ff;font-weight:bold">&amp;#39;mut&amp;#39;&lt;/span>]):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> symbol = mut &lt;span style="color:#fff;font-weight:bold">if&lt;/span> mut &lt;span style="color:#fff;font-weight:bold">else&lt;/span> ref_seq_sr[index + &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> symbol in sub_dict[index + &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sub_dict[index + &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>][symbol] += &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sub_dict[index + &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>][symbol] = &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> return_list.append(sub_dict)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>i&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">th process complete!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> merge_thread(poslist, sub_dict_list, return_dict):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> pos in poslist:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count_dict = &lt;span style="color:#fff;font-weight:bold">sum&lt;/span>([d[pos] &lt;span style="color:#fff;font-weight:bold">for&lt;/span> d in sub_dict_list], Counter())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> merged_dict = {k: count_dict.get(k, &lt;span style="color:#ff0;font-weight:bold">0&lt;/span>) &lt;span style="color:#fff;font-weight:bold">for&lt;/span> k in IUPAC_CODES.keys()}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> return_dict[pos] = merged_dict
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> load_mutationinfo(input_dir=COVID19_MUTATIONINFO_DIR, sample_list=&lt;span style="color:#fff;font-weight:bold">None&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> core_n, split_n = &lt;span style="color:#ff0;font-weight:bold">100&lt;/span>, &lt;span style="color:#ff0;font-weight:bold">1000&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sub_dict_list = Manager().list()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filelist = get_file_paths_recursive(input_dir)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> sample_list:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filelist = [f &lt;span style="color:#fff;font-weight:bold">for&lt;/span> f in filelist &lt;span style="color:#fff;font-weight:bold">if&lt;/span> os.path.basename(f).split(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;.&amp;#39;&lt;/span>)[&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>] in sample_list]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;sample_n: &lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>&lt;span style="color:#fff;font-weight:bold">len&lt;/span>(sample_list)&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> splited_filepaths = array_split(filelist, split_n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parameter_list = [(chunk, sub_dict_list, i) &lt;span style="color:#fff;font-weight:bold">for&lt;/span> i, chunk in &lt;span style="color:#fff;font-weight:bold">enumerate&lt;/span>(splited_filepaths)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;read thread start!&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> multi_processing(read_thead, parameter_list, core_n=core_n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;read thread end!&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> merged_dict = Manager().dict()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> poslist = ref_seq.index
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> splited_poslist = array_split(poslist, split_n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sub_dict_list = &lt;span style="color:#fff;font-weight:bold">list&lt;/span>(sub_dict_list)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parameter_list = [(pos_chunk, sub_dict_list, merged_dict) &lt;span style="color:#fff;font-weight:bold">for&lt;/span> pos_chunk in splited_poslist]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;merge thread start!&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> multi_processing(merge_thread, parameter_list, core_n=core_n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;merge thread end!&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> &lt;span style="color:#fff;font-weight:bold">dict&lt;/span>(merged_dict)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># === Matrix 생성 병렬 처리 ===&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> make_matrix_thread(file_list):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clusters_df = pd.read_csv(os.path.join(GISAID_MUTCLUST_OUTPUT_DIR, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;clusters_hscore.txt&amp;#39;&lt;/span>), sep=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\t&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> column_list = [&lt;span style="color:#0ff;font-weight:bold">f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34;c&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>i&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">(&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>row[&lt;span style="color:#0ff;font-weight:bold">&amp;#39;left_position&amp;#39;&lt;/span>]&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">,&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>row[&lt;span style="color:#0ff;font-weight:bold">&amp;#39;right_position&amp;#39;&lt;/span>]&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">)&amp;#34;&lt;/span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> i, row in clusters_df.iterrows()]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cluster_df = pd.DataFrame(columns=column_list)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> path in file_list:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df = pd.read_csv(path)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> patient_name = os.path.splitext(os.path.basename(path))[&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cluster_df.loc[patient_name] = &lt;span style="color:#ff0;font-weight:bold">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> pos in df[df[&lt;span style="color:#0ff;font-weight:bold">&amp;#39;mut&amp;#39;&lt;/span>].notnull()][&lt;span style="color:#0ff;font-weight:bold">&amp;#39;pos&amp;#39;&lt;/span>]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cluster_idx = clusters_df[(clusters_df[&lt;span style="color:#0ff;font-weight:bold">&amp;#39;left_position&amp;#39;&lt;/span>] &amp;lt;= pos) &amp;amp; (pos &amp;lt;= clusters_df[&lt;span style="color:#0ff;font-weight:bold">&amp;#39;right_position&amp;#39;&lt;/span>])].index
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cluster_df.loc[patient_name][cluster_idx] += &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> cluster_df
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> make_matrix(mutationinfo_dir, out_dir, tag, cpu_n=&lt;span style="color:#ff0;font-weight:bold">60&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;starting make matrix!&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pool = Pool(processes=cpu_n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> file_list = get_file_paths_recursive(mutationinfo_dir)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> results = pool.map(make_matrix_thread, array_split(file_list, cpu_n))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pd.concat(results).to_csv(os.path.join(out_dir, &lt;span style="color:#0ff;font-weight:bold">f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;cluster_matrix_&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>tag&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">.csv&amp;#39;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pool.close()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pool.join()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># === H-score 계산 ===&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> add_HSCORE():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df = pd.read_csv(os.path.join(MUTCLUST_INPUT_DIR, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;gisaid_mutclust_input.tsv&amp;#39;&lt;/span>), sep=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\t&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df[HSCORE] = df[PER] * df[ENT]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df.to_csv(os.path.join(MUTCLUST_INPUT_DIR, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;gisaid_mutclust_input_with_score.tsv&amp;#39;&lt;/span>), sep=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\t&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>, index=&lt;span style="color:#fff;font-weight:bold">False&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># === 주석(Annotation) ===&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> annotation():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">import&lt;/span> ast
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mapping_df = pd.read_csv(os.path.join(GISAID_METADATA_DIR, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;merged_info.tsv&amp;#39;&lt;/span>), sep=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\t&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>, index_col=&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> i, row in mapping_df.iterrows():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mapping_df.loc[i] = [ast.literal_eval(val) &lt;span style="color:#fff;font-weight:bold">for&lt;/span> val in row]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(mapping_df)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> make_clade_divide_mutation():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clade_dir = &lt;span style="color:#0ff;font-weight:bold">&amp;#39;./clade_divide_mutation&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> start_dict = getStartDict()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> file in get_filenames_list(clade_dir):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df = read_csv(os.path.join(clade_dir, file), sep=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\t&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(df)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># === 병렬 처리 유틸리티 ===&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> multi_processing(func, parameter_list, core_n=&lt;span style="color:#ff0;font-weight:bold">100&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> proc, proc_excution, proc_end = [], [], []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> param in parameter_list:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> proc.append(Process(target=func, args=param))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">while&lt;/span> proc or proc_excution:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> _ in &lt;span style="color:#fff;font-weight:bold">range&lt;/span>(&lt;span style="color:#fff;font-weight:bold">len&lt;/span>(proc)):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> &lt;span style="color:#fff;font-weight:bold">len&lt;/span>(proc_excution) &amp;lt; core_n:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p = proc.pop(&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p.start()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> proc_excution.append(p)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> p in proc_excution[:]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> not p.is_alive():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> proc_excution.remove(p)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p.join()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p.close()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> proc_end.append(p)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># === 메인 실행 ===&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">if&lt;/span> __name__ == &lt;span style="color:#0ff;font-weight:bold">&amp;#39;__main__&amp;#39;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> annotation()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>MutClust 코드 리펙토링 #1 lib.py</title><link>https://yshghid.github.io/docs/study/algorithm/algo1/</link><pubDate>Thu, 31 Jul 2025 00:00:00 +0000</pubDate><guid>https://yshghid.github.io/docs/study/algorithm/algo1/</guid><description>&lt;h1 id="mutclust-코드-리펙토링-1-libpy">
 MutClust 코드 리펙토링 #1 lib.py
 &lt;a class="anchor" href="#mutclust-%ec%bd%94%eb%93%9c-%eb%a6%ac%ed%8e%99%ed%86%a0%eb%a7%81-1-libpy">#&lt;/a>
&lt;/h1>
&lt;p>#2025-07-31&lt;/p>
&lt;hr>
&lt;p>MutClust 알고리즘의 코드 구성은 아래와 같은데&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span>MutClust
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── sc/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── lib.py // 핵심 알고리즘 로직
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── arg_parser.py
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── utils.py
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── Test
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>lib.py는 후보 Core 선택 로직과 클러스터 탐지 알고리즘을 포함한다.&lt;/p>
&lt;h1 id="">
 
 &lt;a class="anchor" href="#">#&lt;/a>
&lt;/h1>
&lt;h3 id="1-config--constant-선언">
 1. Config &amp;amp; Constant 선언
 &lt;a class="anchor" href="#1-config--constant-%ec%84%a0%ec%96%b8">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># === mlib.py ===&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">from&lt;/span> math &lt;span style="color:#fff;font-weight:bold">import&lt;/span> ceil
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">import&lt;/span> numpy &lt;span style="color:#fff;font-weight:bold">as&lt;/span> np
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">from&lt;/span> src.utils &lt;span style="color:#fff;font-weight:bold">import&lt;/span> mutation_filtering
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># --- Constants ---&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>POS = &lt;span style="color:#0ff;font-weight:bold">&amp;#39;Position&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>FREQ = &lt;span style="color:#0ff;font-weight:bold">&amp;#39;Frequency&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PER = &lt;span style="color:#0ff;font-weight:bold">&amp;#39;Percentage&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ENT = &lt;span style="color:#0ff;font-weight:bold">&amp;#39;Entropy&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>HSCORE = &lt;span style="color:#0ff;font-weight:bold">&amp;#39;H-score&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>HSCORE_SUM = &lt;span style="color:#0ff;font-weight:bold">&amp;#39;H-score_sum&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>HSCORE_AVR = &lt;span style="color:#0ff;font-weight:bold">&amp;#39;H-score_avr&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PER_SUM = &lt;span style="color:#0ff;font-weight:bold">&amp;#39;per_sum&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ENT_SUM = &lt;span style="color:#0ff;font-weight:bold">&amp;#39;ent_sum&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PER_AVR = &lt;span style="color:#0ff;font-weight:bold">&amp;#39;per_avr&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ENT_AVR = &lt;span style="color:#0ff;font-weight:bold">&amp;#39;ent_avr&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>EPSILON = &lt;span style="color:#ff0;font-weight:bold">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>EPSILON_SCALING_FACTOR = &lt;span style="color:#ff0;font-weight:bold">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DIMINISHING_FACTOR = &lt;span style="color:#ff0;font-weight:bold">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MIN_CLUSTER_LENGTH = &lt;span style="color:#ff0;font-weight:bold">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CCM_MIN_HSCORE_SUM = &lt;span style="color:#ff0;font-weight:bold">0.05&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CCM_MIN_HSCORE_AVR = &lt;span style="color:#ff0;font-weight:bold">0.01&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CCM_MIN_HSCORE = &lt;span style="color:#ff0;font-weight:bold">0.03&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MIN_MUTATIONS = &lt;span style="color:#ff0;font-weight:bold">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># --- Config Init ---&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> init(d, info):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\n&lt;/span>&lt;span style="color:#0ff;font-weight:bold">--- Configurations ---&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34;Input data: &amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>info.fin&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39; &lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>d.shape&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34;Output dir: &amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>info.outdir&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;Parameters:&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34; Min Eps=&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>info.eps&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34; Max Eps=&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>info.maxeps&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34; Min per_sum=&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>info.min_persum&lt;span style="color:#0ff;font-weight:bold">:&lt;/span>&lt;span style="color:#0ff;font-weight:bold">.1f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34; Eps scaling factor=&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>info.eps_scaler_const&lt;span style="color:#0ff;font-weight:bold">:&lt;/span>&lt;span style="color:#0ff;font-weight:bold">.1f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34; Expansion diminishing factor=&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>info.es_control_const&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34; Min cluster length=&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>info.min_cluster_length&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;----------------------&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\n&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="2-eps-내-중요도-계산">
 2. Eps 내 중요도 계산
 &lt;a class="anchor" href="#2-eps-%eb%82%b4-%ec%a4%91%ec%9a%94%eb%8f%84-%ea%b3%84%ec%82%b0">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># --- EPS Stats ---&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">class&lt;/span> get_eps_stats:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">def&lt;/span> __init__(&lt;span style="color:#fff;font-weight:bold">self&lt;/span>, idx, pos, df, lr_index, lr_distance, es):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.idx = idx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.i = pos
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.i_per = df.loc[idx, PER]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.i_freq = df.loc[idx, FREQ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.i_ent = df.loc[idx, ENT]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.i_hscore = df.loc[idx, HSCORE]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.l_dist, &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.r_dist = lr_distance
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ccm_df = df.loc[lr_index[&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>]:lr_index[&lt;span style="color:#ff0;font-weight:bold">1&lt;/span>] + &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.length = &lt;span style="color:#fff;font-weight:bold">len&lt;/span>(ccm_df)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.l_pos = df.loc[lr_index[&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>], POS]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.r_pos = df.loc[lr_index[&lt;span style="color:#ff0;font-weight:bold">1&lt;/span>], POS]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.mut_n = &lt;span style="color:#fff;font-weight:bold">len&lt;/span>(ccm_df[ccm_df[HSCORE] &amp;gt; &lt;span style="color:#ff0;font-weight:bold">0&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.eps_scaler = es
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.freq_sum = ccm_df[FREQ].sum()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.freq_avr = &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.freq_sum / &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.length
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.per_sum = ccm_df[PER].sum()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.per_avr = &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.per_sum / &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.length
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.ent_sum = ccm_df[ENT].sum()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.ent_avr = &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.ent_sum / &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.length
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.hscore_sum = ccm_df[HSCORE].sum()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.hscore_avr = &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.hscore_sum / &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.length
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">def&lt;/span> to_dict(&lt;span style="color:#fff;font-weight:bold">self&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0ff;font-weight:bold">&amp;#39;index&amp;#39;&lt;/span>: &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.idx, POS: &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.i, FREQ: &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.i_freq, PER: &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.i_per,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ENT: &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.i_ent, HSCORE: &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.i_hscore, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;length&amp;#39;&lt;/span>: &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.length,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0ff;font-weight:bold">&amp;#39;freq_sum&amp;#39;&lt;/span>: &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.freq_sum, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;freq_avr&amp;#39;&lt;/span>: &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.freq_avr,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PER_SUM: &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.per_sum, PER_AVR: &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.per_avr,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ENT_SUM: &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.ent_sum, ENT_AVR: &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.ent_avr,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HSCORE_SUM: &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.hscore_sum, HSCORE_AVR: &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.hscore_avr,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0ff;font-weight:bold">&amp;#39;eps_scaler&amp;#39;&lt;/span>: &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.eps_scaler, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;left_distance&amp;#39;&lt;/span>: &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.l_dist,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0ff;font-weight:bold">&amp;#39;right_distance&amp;#39;&lt;/span>: &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.r_dist, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;l_pos&amp;#39;&lt;/span>: &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.l_pos,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0ff;font-weight:bold">&amp;#39;r_pos&amp;#39;&lt;/span>: &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.r_pos, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;mut_n&amp;#39;&lt;/span>: &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.mut_n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="3-local-eps-계산">
 3. Local Eps 계산
 &lt;a class="anchor" href="#3-local-eps-%ea%b3%84%ec%82%b0">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># --- EPS Region ---&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> get_eps_region(df, idx, info):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pos = df.loc[idx, POS]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cur_hscore = df.loc[idx, HSCORE]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> eps_scaler = ceil(EPSILON_SCALING_FACTOR * cur_hscore)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ldeps = rdeps = eps_scaler * EPSILON
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ldeps = &lt;span style="color:#fff;font-weight:bold">min&lt;/span>(ldeps, info.maxeps)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rdeps = &lt;span style="color:#fff;font-weight:bold">min&lt;/span>(rdeps, info.maxeps)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> l_idx, r_idx = idx - &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>, idx + &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">while&lt;/span> l_idx &amp;gt;= &lt;span style="color:#ff0;font-weight:bold">0&lt;/span> and (pos - df.loc[l_idx, POS]) &amp;lt;= ldeps:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> l_idx -= &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">while&lt;/span> r_idx &amp;lt; &lt;span style="color:#fff;font-weight:bold">len&lt;/span>(df) and (df.loc[r_idx, POS] - pos) &amp;lt;= rdeps:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r_idx += &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> [l_idx + &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>, r_idx - &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>], [idx - (l_idx + &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>), (r_idx - &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>) - idx], eps_scaler
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="4-후보-core-돌연변이-선택">
 4. 후보 Core 돌연변이 선택
 &lt;a class="anchor" href="#4-%ed%9b%84%eb%b3%b4-core-%eb%8f%8c%ec%97%b0%eb%b3%80%ec%9d%b4-%ec%84%a0%ed%83%9d">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># --- Core Mutation Detection ---&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> get_candidate_core_mutations(df, info, tag):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mut_list = []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ccm_list = []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df = mutation_filtering(df)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> idx, pos in &lt;span style="color:#fff;font-weight:bold">enumerate&lt;/span>(df[POS]):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lr_idx, lr_dist, es = get_eps_region(df, idx, info)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stat = get_eps_stats(idx, pos, df, lr_idx, lr_dist, es)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> d = stat.to_dict()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mut_list.append(d)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> d[&lt;span style="color:#0ff;font-weight:bold">&amp;#39;mut_n&amp;#39;&lt;/span>] &amp;gt;= MIN_MUTATIONS and d[HSCORE_SUM] &amp;gt;= CCM_MIN_HSCORE_SUM and d[HSCORE_AVR] &amp;gt;= CCM_MIN_HSCORE_AVR and d[HSCORE] &amp;gt;= CCM_MIN_HSCORE:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ccm_list.append(idx)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">with&lt;/span> &lt;span style="color:#fff;font-weight:bold">open&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>info.outdir&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">/total_results_&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>tag&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">.tsv&amp;#34;&lt;/span>, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;w&amp;#39;&lt;/span>) &lt;span style="color:#fff;font-weight:bold">as&lt;/span> f:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f.write(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\t&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>.join(mut_list[&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>].keys()) + &lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\n&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> m in mut_list:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f.write(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\t&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>.join(&lt;span style="color:#fff;font-weight:bold">map&lt;/span>(&lt;span style="color:#fff;font-weight:bold">str&lt;/span>, m.values())) + &lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\n&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">with&lt;/span> &lt;span style="color:#fff;font-weight:bold">open&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>info.outdir&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">/ccm_results_&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>tag&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">.tsv&amp;#34;&lt;/span>, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;w&amp;#39;&lt;/span>) &lt;span style="color:#fff;font-weight:bold">as&lt;/span> f:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f.write(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\t&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>.join(mut_list[&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>].keys()) + &lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\n&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> i in ccm_list:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f.write(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\t&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>.join(&lt;span style="color:#fff;font-weight:bold">map&lt;/span>(&lt;span style="color:#fff;font-weight:bold">str&lt;/span>, mut_list[i].values())) + &lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\n&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> np.array(mut_list), ccm_list
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="5-cluster-expansion">
 5. Cluster Expansion
 &lt;a class="anchor" href="#5-cluster-expansion">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># --- Cluster Expansion ---&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> expand_cluster(ccm_idx, mut_list, info):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> es_l = es_r = mut_list[ccm_idx][&lt;span style="color:#0ff;font-weight:bold">&amp;#39;eps_scaler&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> l_idx, r_idx = ccm_idx - &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>, ccm_idx + &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mut_n = &lt;span style="color:#fff;font-weight:bold">len&lt;/span>(mut_list)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> l_max, r_max = mut_list[ccm_idx][&lt;span style="color:#0ff;font-weight:bold">&amp;#39;left_distance&amp;#39;&lt;/span>], mut_list[ccm_idx][&lt;span style="color:#0ff;font-weight:bold">&amp;#39;right_distance&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> l_pos = mut_list[ccm_idx][POS]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">while&lt;/span> l_idx &amp;gt;= &lt;span style="color:#ff0;font-weight:bold">0&lt;/span> and (l_pos - mut_list[l_idx][POS]) &amp;lt;= l_max:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delta = es_l - mut_list[l_idx][&lt;span style="color:#0ff;font-weight:bold">&amp;#39;eps_scaler&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> es_l -= delta / info.es_control_const
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> l_max = &lt;span style="color:#fff;font-weight:bold">max&lt;/span>(info.eps * es_l, &lt;span style="color:#ff0;font-weight:bold">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> l_idx -= &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">while&lt;/span> r_idx &amp;lt; mut_n and (mut_list[r_idx][POS] - l_pos) &amp;lt;= r_max:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delta = es_r - mut_list[r_idx][&lt;span style="color:#0ff;font-weight:bold">&amp;#39;eps_scaler&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> es_r -= delta / info.es_control_const
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r_max = &lt;span style="color:#fff;font-weight:bold">max&lt;/span>(info.eps * es_r, &lt;span style="color:#ff0;font-weight:bold">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r_idx += &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> l_idx = &lt;span style="color:#fff;font-weight:bold">max&lt;/span>(l_idx + &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>, &lt;span style="color:#ff0;font-weight:bold">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r_idx = &lt;span style="color:#fff;font-weight:bold">min&lt;/span>(r_idx - &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>, mut_n - &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clust = [a[POS] &lt;span style="color:#fff;font-weight:bold">for&lt;/span> a in mut_list[l_idx:r_idx + &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>] &lt;span style="color:#fff;font-weight:bold">if&lt;/span> a[HSCORE] &amp;gt; &lt;span style="color:#ff0;font-weight:bold">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0ff;font-weight:bold">&amp;#39;left_position&amp;#39;&lt;/span>: &lt;span style="color:#fff;font-weight:bold">min&lt;/span>(clust),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0ff;font-weight:bold">&amp;#39;right_position&amp;#39;&lt;/span>: &lt;span style="color:#fff;font-weight:bold">max&lt;/span>(clust),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0ff;font-weight:bold">&amp;#39;length&amp;#39;&lt;/span>: &lt;span style="color:#fff;font-weight:bold">max&lt;/span>(clust) - &lt;span style="color:#fff;font-weight:bold">min&lt;/span>(clust) + &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0ff;font-weight:bold">&amp;#39;mut_positions&amp;#39;&lt;/span>: &lt;span style="color:#0ff;font-weight:bold">&amp;#39;,&amp;#39;&lt;/span>.join(&lt;span style="color:#fff;font-weight:bold">map&lt;/span>(&lt;span style="color:#fff;font-weight:bold">str&lt;/span>, &lt;span style="color:#fff;font-weight:bold">sorted&lt;/span>(clust)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="6-dynamic-clustering">
 6. Dynamic Clustering
 &lt;a class="anchor" href="#6-dynamic-clustering">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># --- Dynamic Clustering ---&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> dynaclust(mut_list, ccm_list, info, tag):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clusters = [expand_cluster(i, mut_list, info) &lt;span style="color:#fff;font-weight:bold">for&lt;/span> i in ccm_list]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clusters.sort(key=&lt;span style="color:#fff;font-weight:bold">lambda&lt;/span> x: x[&lt;span style="color:#0ff;font-weight:bold">&amp;#39;left_position&amp;#39;&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> merged = []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i = &lt;span style="color:#ff0;font-weight:bold">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">while&lt;/span> i &amp;lt; &lt;span style="color:#fff;font-weight:bold">len&lt;/span>(clusters):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> l, r = clusters[i][&lt;span style="color:#0ff;font-weight:bold">&amp;#39;left_position&amp;#39;&lt;/span>], clusters[i][&lt;span style="color:#0ff;font-weight:bold">&amp;#39;right_position&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> muts = &lt;span style="color:#fff;font-weight:bold">set&lt;/span>(&lt;span style="color:#fff;font-weight:bold">map&lt;/span>(&lt;span style="color:#fff;font-weight:bold">int&lt;/span>, clusters[i][&lt;span style="color:#0ff;font-weight:bold">&amp;#39;mut_positions&amp;#39;&lt;/span>].split(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;,&amp;#39;&lt;/span>)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> j = i + &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">while&lt;/span> j &amp;lt; &lt;span style="color:#fff;font-weight:bold">len&lt;/span>(clusters) and clusters[j][&lt;span style="color:#0ff;font-weight:bold">&amp;#39;left_position&amp;#39;&lt;/span>] &amp;lt;= r:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r = &lt;span style="color:#fff;font-weight:bold">max&lt;/span>(r, clusters[j][&lt;span style="color:#0ff;font-weight:bold">&amp;#39;right_position&amp;#39;&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> muts.update(&lt;span style="color:#fff;font-weight:bold">map&lt;/span>(&lt;span style="color:#fff;font-weight:bold">int&lt;/span>, clusters[j][&lt;span style="color:#0ff;font-weight:bold">&amp;#39;mut_positions&amp;#39;&lt;/span>].split(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;,&amp;#39;&lt;/span>)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> j += &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> &lt;span style="color:#fff;font-weight:bold">len&lt;/span>(muts) &amp;gt;= MIN_MUTATIONS:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> merged.append({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0ff;font-weight:bold">&amp;#39;left_position&amp;#39;&lt;/span>: &lt;span style="color:#fff;font-weight:bold">min&lt;/span>(muts),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0ff;font-weight:bold">&amp;#39;right_position&amp;#39;&lt;/span>: &lt;span style="color:#fff;font-weight:bold">max&lt;/span>(muts),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0ff;font-weight:bold">&amp;#39;length&amp;#39;&lt;/span>: &lt;span style="color:#fff;font-weight:bold">max&lt;/span>(muts) - &lt;span style="color:#fff;font-weight:bold">min&lt;/span>(muts) + &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0ff;font-weight:bold">&amp;#39;mut_positions&amp;#39;&lt;/span>: &lt;span style="color:#0ff;font-weight:bold">&amp;#39;,&amp;#39;&lt;/span>.join(&lt;span style="color:#fff;font-weight:bold">map&lt;/span>(&lt;span style="color:#fff;font-weight:bold">str&lt;/span>, &lt;span style="color:#fff;font-weight:bold">sorted&lt;/span>(muts)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i = j
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">with&lt;/span> &lt;span style="color:#fff;font-weight:bold">open&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>info.outdir&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">/clusters_&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>tag&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">.txt&amp;#34;&lt;/span>, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;w&amp;#39;&lt;/span>) &lt;span style="color:#fff;font-weight:bold">as&lt;/span> f:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f.write(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\t&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>.join(merged[&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>].keys()) + &lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\n&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> m in merged:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f.write(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\t&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>.join(&lt;span style="color:#fff;font-weight:bold">map&lt;/span>(&lt;span style="color:#fff;font-weight:bold">str&lt;/span>, m.values())) + &lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\n&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> merged
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>BFS/DFS #3 게임 맵 최단거리</title><link>https://yshghid.github.io/docs/study/algorithm/algo8/</link><pubDate>Mon, 21 Jul 2025 00:00:00 +0000</pubDate><guid>https://yshghid.github.io/docs/study/algorithm/algo8/</guid><description>&lt;h1 id="bfsdfs-3-게임-맵-최단거리">
 BFS/DFS #3 게임 맵 최단거리
 &lt;a class="anchor" href="#bfsdfs-3-%ea%b2%8c%ec%9e%84-%eb%a7%b5-%ec%b5%9c%eb%8b%a8%ea%b1%b0%eb%a6%ac">#&lt;/a>
&lt;/h1>
&lt;p>#2025-07-21&lt;/p>
&lt;hr>
&lt;p>문제: ROR 게임은 두 팀으로 나누어서 진행하며, 상대 팀 진영을 먼저 파괴하면 이기는 게임입니다. 따라서, 각 팀은 상대 팀 진영에 최대한 빨리 도착하는 것이 유리합니다. 지금부터 당신은 한 팀의 팀원이 되어 게임을 진행하려고 합니다. 다음은 5 x 5 크기의 맵에, 당신의 캐릭터가 (행: 1, 열: 1) 위치에 있고, 상대 팀 진영은 (행: 5, 열: 5) 위치에 있는 경우의 예시입니다.&lt;/p>
&lt;p>&lt;img src="https://github.com/user-attachments/assets/0c2834d7-07d7-4c5a-b6c6-9058de58a3da" alt="image" />&lt;/p>
&lt;p>위 그림에서 검은색 부분은 벽으로 막혀있어 갈 수 없는 길이며, 흰색 부분은 갈 수 있는 길입니다. 캐릭터가 움직일 때는 동, 서, 남, 북 방향으로 한 칸씩 이동하며, 게임 맵을 벗어난 길은 갈 수 없습니다. 아래 예시는 캐릭터가 상대 팀 진영으로 가는 두 가지 방법을 나타내고 있습니다.&lt;/p></description></item><item><title>BFS/DFS #1 타겟 넘버</title><link>https://yshghid.github.io/docs/study/algorithm/algo6/</link><pubDate>Sat, 19 Jul 2025 00:00:00 +0000</pubDate><guid>https://yshghid.github.io/docs/study/algorithm/algo6/</guid><description>&lt;h1 id="bfsdfs-1-타겟-넘버">
 BFS/DFS #1 타겟 넘버
 &lt;a class="anchor" href="#bfsdfs-1-%ed%83%80%ea%b2%9f-%eb%84%98%eb%b2%84">#&lt;/a>
&lt;/h1>
&lt;p>#2025-07-19&lt;/p>
&lt;hr>
&lt;p>문제: n개의 음이 아닌 정수들이 있습니다. 이 정수들을 순서를 바꾸지 않고 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 사용할 수 있는 숫자가 담긴 배열 &lt;code>numbers&lt;/code>, 타겟 넘버 &lt;code>target&lt;/code>이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.&lt;/p>
&lt;p>제한사항: 주어지는 숫자의 개수는 2개 이상 20개 이하입니다. 각 숫자는 1 이상 50 이하인 자연수입니다. 타겟 넘버는 1 이상 1000 이하인 자연수입니다.&lt;/p></description></item><item><title>BFS/DFS #2 네트워크</title><link>https://yshghid.github.io/docs/study/algorithm/algo7/</link><pubDate>Sat, 19 Jul 2025 00:00:00 +0000</pubDate><guid>https://yshghid.github.io/docs/study/algorithm/algo7/</guid><description>&lt;h1 id="bfsdfs-2-네트워크">
 BFS/DFS #2 네트워크
 &lt;a class="anchor" href="#bfsdfs-2-%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac">#&lt;/a>
&lt;/h1>
&lt;p>#2025-07-19&lt;/p>
&lt;hr>
&lt;p>문제: 컴퓨터 A와 컴퓨터 B가 직접적으로 연결되어있고, 컴퓨터 B와 컴퓨터 C가 직접적으로 연결되어 있을 때 컴퓨터 A와 컴퓨터 C도 간접적으로 연결되어 정보를 교환할 수 있습니다. 이때 컴퓨터 A, B, C는 모두 같은 네트워크 상에 있다고 할 수 있습니다. 컴퓨터의 개수 n, 연결에 대한 정보가 담긴 2차원 배열 computers가 매개변수로 주어질 때, 네트워크의 개수를 return 하도록 solution 함수를 작성하시오.&lt;/p>
&lt;p>제한사항: 컴퓨터의 개수 n은 1 이상 200 이하인 자연수입니다. 각 컴퓨터는 0부터 &lt;code>n-1&lt;/code>인 정수로 표현합니다. i번 컴퓨터와 j번 컴퓨터가 연결되어 있으면 computers[i][j]를 1로 표현합니다. computer[i][i]는 항상 1입니다.&lt;/p></description></item><item><title>BFS 공부</title><link>https://yshghid.github.io/docs/study/algorithm/algo5/</link><pubDate>Fri, 04 Jul 2025 00:00:00 +0000</pubDate><guid>https://yshghid.github.io/docs/study/algorithm/algo5/</guid><description>&lt;h1 id="bfs-공부">
 BFS 공부
 &lt;a class="anchor" href="#bfs-%ea%b3%b5%eb%b6%80">#&lt;/a>
&lt;/h1>
&lt;hr>
&lt;h3 id="1-기본로직">
 1. 기본로직
 &lt;a class="anchor" href="#1-%ea%b8%b0%eb%b3%b8%eb%a1%9c%ec%a7%81">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span>1. graph 만든다
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2. 인접 리스트 정렬
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>3. bfs 만든다.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>i) visited 만들고 / queue 만들어서 start만 넣는다. 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ii) queue가 빌때까지 다음을 수행
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>: queue의 첫번째값 v를 꺼냄. v가 미방문이면? visited에 v추가하고. v의 이웃을 봣을때 미방문이면? queue에 추가.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>4. bfs 돌린다.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>참고 문제: &lt;a href="https://yshghid.github.io/docs/study/algorithm/algo3/#1-%eb%b0%a9%eb%ac%b8-%ec%88%9c%ec%84%9c-%ec%b6%9c%eb%a0%a5%ed%95%98%ea%b8%b0">BFS #1&lt;/a>&lt;/p>
&lt;h1 id="">
 
 &lt;a class="anchor" href="#">#&lt;/a>
&lt;/h1></description></item><item><title>BFS #1 #2</title><link>https://yshghid.github.io/docs/study/algorithm/algo3/</link><pubDate>Thu, 03 Jul 2025 00:00:00 +0000</pubDate><guid>https://yshghid.github.io/docs/study/algorithm/algo3/</guid><description>&lt;h1 id="bfs-1-2">
 BFS #1 #2
 &lt;a class="anchor" href="#bfs-1-2">#&lt;/a>
&lt;/h1>
&lt;p>#2025-07-03&lt;/p>
&lt;hr>
&lt;h3 id="1-방문-순서-출력하기">
 1. 방문 순서 출력하기
 &lt;a class="anchor" href="#1-%eb%b0%a9%eb%ac%b8-%ec%88%9c%ec%84%9c-%ec%b6%9c%eb%a0%a5%ed%95%98%ea%b8%b0">#&lt;/a>
&lt;/h3>
&lt;p>#문제 설명&lt;/p>
&lt;p>정점의 개수 n, 간선의 개수 m, 시작 정점 s가 주어진다.
이후 m개의 간선 정보(정점 a, 정점 b)가 주어진다.
인접한 정점들을 오름차순으로 방문한다고 할 때, BFS로 방문한 정점의 순서를 출력하시오.&lt;/p>
&lt;p>#입력 형식&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span>5 4 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1 2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1 3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2 4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>3 5
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>#출력 예시&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span>1 2 3 4 5
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>#정답&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">from&lt;/span> collections &lt;span style="color:#fff;font-weight:bold">import&lt;/span> deque
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># 입력&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>n, m, s = &lt;span style="color:#fff;font-weight:bold">map&lt;/span>(&lt;span style="color:#fff;font-weight:bold">int&lt;/span>, &lt;span style="color:#fff;font-weight:bold">input&lt;/span>().split()) &lt;span style="color:#007f7f"># 정점 개수, 간선 개수, 시작 정점&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>graph = {i: [] &lt;span style="color:#fff;font-weight:bold">for&lt;/span> i in &lt;span style="color:#fff;font-weight:bold">range&lt;/span>(&lt;span style="color:#ff0;font-weight:bold">1&lt;/span>, n+&lt;span style="color:#ff0;font-weight:bold">1&lt;/span>)}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># 간선 입력&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">for&lt;/span> _ in &lt;span style="color:#fff;font-weight:bold">range&lt;/span>(m):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a, b = &lt;span style="color:#fff;font-weight:bold">map&lt;/span>(&lt;span style="color:#fff;font-weight:bold">int&lt;/span>, &lt;span style="color:#fff;font-weight:bold">input&lt;/span>().split())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> graph[a].append(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> graph[b].append(a) &lt;span style="color:#007f7f"># 양방향 그래프&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># 인접 리스트 정렬 (오름차순 방문)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">for&lt;/span> node in graph:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> graph[node].sort()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># BFS 함수&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> bfs(start):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> visited = &lt;span style="color:#fff;font-weight:bold">set&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queue = deque([start])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> visited_order = []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">while&lt;/span> queue:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v = queue.popleft()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> v not in visited:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> visited.add(v)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> visited_order.append(v)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> neighbor in graph[v]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> neighbor not in visited:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queue.append(neighbor)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> visited_order
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># 출력&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>order = bfs(s)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">&amp;#34; &amp;#34;&lt;/span>.join(&lt;span style="color:#fff;font-weight:bold">map&lt;/span>(&lt;span style="color:#fff;font-weight:bold">str&lt;/span>, order)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>#풀이&lt;/p></description></item><item><title>BFS #3</title><link>https://yshghid.github.io/docs/study/algorithm/algo4/</link><pubDate>Thu, 03 Jul 2025 00:00:00 +0000</pubDate><guid>https://yshghid.github.io/docs/study/algorithm/algo4/</guid><description>&lt;h1 id="bfs-3">
 BFS #3
 &lt;a class="anchor" href="#bfs-3">#&lt;/a>
&lt;/h1>
&lt;p>#2025-07-03&lt;/p>
&lt;hr>
&lt;h3 id="3-가장-가까운-목표지점까지의-거리">
 3. 가장 가까운 목표지점까지의 거리
 &lt;a class="anchor" href="#3-%ea%b0%80%ec%9e%a5-%ea%b0%80%ea%b9%8c%ec%9a%b4-%eb%aa%a9%ed%91%9c%ec%a7%80%ec%a0%90%ea%b9%8c%ec%a7%80%ec%9d%98-%ea%b1%b0%eb%a6%ac">#&lt;/a>
&lt;/h3>
&lt;p>#문제 설명&lt;/p>
&lt;p>1과 0으로 구성된 maps 배열이 주어집니다.
maps[y][x] == 1인 곳은 이동할 수 있고, 0인 곳은 이동할 수 없습니다.&lt;/p>
&lt;p>시작점은 (0,0), 도착점은 (n-1, m-1)입니다.
상, 하, 좌, 우 4방향으로만 이동할 수 있을 때, 도착지까지 최단 거리를 구하세요.
도착할 수 없는 경우 -1을 반환하세요.&lt;/p>
&lt;p>#제한사항&lt;/p>
&lt;p>maps는 5 ≤ maps의 세로 길이, 가로 길이 ≤ 100&lt;/p>
&lt;p>시작점과 도착점은 항상 1입니다.&lt;/p></description></item></channel></rss>
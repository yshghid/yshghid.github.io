<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  #6 네트워크
  #

#2025-07-19

문제: 컴퓨터 A와 컴퓨터 B가 직접적으로 연결되어있고, 컴퓨터 B와 컴퓨터 C가 직접적으로 연결되어 있을 때 컴퓨터 A와 컴퓨터 C도 간접적으로 연결되어 정보를 교환할 수 있습니다. 이때 컴퓨터 A, B, C는 모두 같은 네트워크 상에 있다고 할 수 있습니다. 컴퓨터의 개수 n, 연결에 대한 정보가 담긴 2차원 배열 computers가 매개변수로 주어질 때, 네트워크의 개수를 return 하도록 solution 함수를 작성하시오.
제한사항: 컴퓨터의 개수 n은 1 이상 200 이하인 자연수입니다. 각 컴퓨터는 0부터 n-1인 정수로 표현합니다. i번 컴퓨터와 j번 컴퓨터가 연결되어 있으면 computers[i][j]를 1로 표현합니다. computer[i][i]는 항상 1입니다."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://yshghid.github.io/docs/study/algorithm/algo7/"><meta property="og:site_name" content=" "><meta property="og:title" content="#6 네트워크"><meta property="og:description" content="#6 네트워크 # #2025-07-19
문제: 컴퓨터 A와 컴퓨터 B가 직접적으로 연결되어있고, 컴퓨터 B와 컴퓨터 C가 직접적으로 연결되어 있을 때 컴퓨터 A와 컴퓨터 C도 간접적으로 연결되어 정보를 교환할 수 있습니다. 이때 컴퓨터 A, B, C는 모두 같은 네트워크 상에 있다고 할 수 있습니다. 컴퓨터의 개수 n, 연결에 대한 정보가 담긴 2차원 배열 computers가 매개변수로 주어질 때, 네트워크의 개수를 return 하도록 solution 함수를 작성하시오.
제한사항: 컴퓨터의 개수 n은 1 이상 200 이하인 자연수입니다. 각 컴퓨터는 0부터 n-1인 정수로 표현합니다. i번 컴퓨터와 j번 컴퓨터가 연결되어 있으면 computers[i][j]를 1로 표현합니다. computer[i][i]는 항상 1입니다."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2025-07-19T00:00:00+00:00"><meta property="article:modified_time" content="2025-07-19T00:00:00+00:00"><meta property="article:tag" content="2025-07"><title>#6 네트워크 |</title><link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://yshghid.github.io/docs/study/algorithm/algo7/><link rel=stylesheet href=/book.min.6217d077edb4189fd0578345e84bca1a884dfdee121ff8dc9a0f55cfe0852bc9.css integrity="sha256-YhfQd+20GJ/QV4NF6EvKGohN/e4SH/jcmg9Vz+CFK8k=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.f4fbc35b8ac66ca9bba3b674afc7dc17ba89f6444a20c8ba3ace9a984bf2fcdb.js integrity="sha256-9PvDW4rGbKm7o7Z0r8fcF7qJ9kRKIMi6Os6amEvy/Ns=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/logo.png alt=Logo class=book-icon><span></span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><span>기록</span><ul><li><a href=/docs/hobby/book/>글</a><ul></ul></li><li><a href=/docs/hobby/daily/>일상</a><ul></ul></li><li><a href=/docs/hobby/shopping/>쇼핑</a><ul></ul></li><li><a href=/docs/hobby/youtube/>유튜브</a><ul></ul></li><li><a href=/docs/hobby/music/>음악</a><ul></ul></li><li><a href=/docs/hobby/baking/>베이킹</a><ul></ul></li><li><a href=/docs/hobby/movie/>영화</a><ul></ul></li></ul></li><li class=book-section-flat><span>공부</span><ul><li><a href=/docs/study/ai/>AI</a><ul></ul></li><li><a href=/docs/study/sw/>SW</a><ul></ul></li><li><a href=/docs/study/bioinformatics/>Bioinformatics</a><ul></ul></li><li><a href=/docs/study/algorithm/>코테</a><ul></ul></li><li><a href=/docs/study/career/>취업</a><ul></ul></li><li><a href=/docs/study/github/>깃허브</a><ul></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>#6 네트워크</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents></nav></aside></header><article class="markdown book-article"><h1 id=6-네트워크>#6 네트워크
<a class=anchor href=#6-%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac>#</a></h1><p>#2025-07-19</p><hr><p>문제: 컴퓨터 A와 컴퓨터 B가 직접적으로 연결되어있고, 컴퓨터 B와 컴퓨터 C가 직접적으로 연결되어 있을 때 컴퓨터 A와 컴퓨터 C도 간접적으로 연결되어 정보를 교환할 수 있습니다. 이때 컴퓨터 A, B, C는 모두 같은 네트워크 상에 있다고 할 수 있습니다. 컴퓨터의 개수 n, 연결에 대한 정보가 담긴 2차원 배열 computers가 매개변수로 주어질 때, 네트워크의 개수를 return 하도록 solution 함수를 작성하시오.</p><p>제한사항: 컴퓨터의 개수 n은 1 이상 200 이하인 자연수입니다. 각 컴퓨터는 0부터 <code>n-1</code>인 정수로 표현합니다. i번 컴퓨터와 j번 컴퓨터가 연결되어 있으면 computers[i][j]를 1로 표현합니다. computer[i][i]는 항상 1입니다.</p><p>입력: <code>n=3</code>, <code>computers=[[1, 1, 0], [1, 1, 0], [0, 0, 1]]</code></p><p>출력: <code>2</code></p><p>풀이:</p><p>주어진 입력은 컴퓨터의 개수 <code>n = 3</code>이고, 컴퓨터 간의 연결 상태를 나타내는 2차원 리스트 <code>computers = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]</code>이다. 여기서 <code>computers[i][j] = 1</code>이면 i번 컴퓨터와 j번 컴퓨터가 직접적으로 연결되어 있다는 뜻이다. 같은 컴퓨터끼리는 항상 연결되어 있으므로 대각선 원소인 <code>computers[i][i]</code>는 항상 1이다. 초기에는 방문 여부를 확인하기 위해 <code>visited = [False, False, False]</code>로 설정되어 있다. 각 컴퓨터가 방문되었는지를 표시하기 위한 리스트이다.</p><p>네트워크 탐색은 반복문과 함께 DFS(깊이 우선 탐색)를 사용하여 구현한다. 전체 컴퓨터를 0번부터 n-1번까지 차례로 탐색하면서, 아직 방문되지 않은 컴퓨터를 발견하면 그 컴퓨터를 시작으로 DFS를 수행하여 해당 네트워크에 속한 모든 컴퓨터를 방문 표시하고, 네트워크의 수를 하나 증가시킨다. 우선 i = 0부터 시작한다. visited[0]은 False이므로 아직 방문하지 않은 상태다. 따라서 0번 컴퓨터를 시작점으로 DFS를 수행한다. <code>dfs(0)</code>을 호출한다. dfs 함수 내부에서는 먼저 <code>visited[0] = True</code>로 설정하여 0번 컴퓨터를 방문 처리한다. 이후 <code>for next_node in range(n)</code> 반복문을 통해, 0번 컴퓨터와 연결된 다른 컴퓨터들을 확인한다. 0번 컴퓨터의 연결 상태는 <code>computers[0] = [1, 1, 0]</code>이므로, 0번 자신과 1번 컴퓨터는 연결되어 있고 2번 컴퓨터는 연결되어 있지 않다. 먼저 next_node = 0일 때, <code>computers[0][0] == 1</code>이지만 이미 visited[0]이 True이므로 넘어간다. next_node = 1일 때, <code>computers[0][1] == 1</code>이고 <code>visited[1] == False</code>이므로 1번 컴퓨터와 연결되어 있고 아직 방문되지 않았다는 의미다. 따라서 <code>dfs(1)</code>을 호출한다. 1번 컴퓨터로 깊이 들어가는 것이다. 이제 dfs(1) 내부로 들어간다. 여기서도 <code>visited[1] = True</code>로 처리하고, 다시 0, 1, 2번 컴퓨터를 확인한다. <code>computers[1] = [1, 1, 0]</code>이므로 0번, 1번과 연결되어 있다. next_node = 0일 때, <code>computers[1][0] == 1</code>이고 <code>visited[0] == True</code>이므로 이미 방문한 노드이므로 무시한다. next_node = 1은 자기 자신이므로 역시 넘어간다. next_node = 2일 때는 <code>computers[1][2] == 0</code>이므로 연결이 없어서 무시한다. dfs(1)은 더 이상 확장할 수 없으므로 종료된다. 다시 dfs(0)으로 돌아온다. now_node = 0에서 next_node = 2를 확인하는 순서다. <code>computers[0][2] == 0</code>이므로 연결이 없고, DFS로 더 들어갈 수 없다. 따라서 dfs(0)도 종료된다. 이로써 0번을 시작으로 한 DFS는 0번과 1번 컴퓨터를 하나의 네트워크로 묶었으며, visited 리스트는 <code>[True, True, False]</code>가 된다. 이제 전체 반복문에서 i = 0은 이미 방문된 컴퓨터이므로 건너뛴다. i = 1 역시 visited[1]이 True이므로 건너뛴다. 다음으로 i = 2를 확인한다. visited[2]는 False이므로 아직 방문되지 않은 컴퓨터다. 즉, 새로운 네트워크의 시작점이 될 수 있다. 따라서 <code>dfs(2)</code>를 호출한다. 2번 컴퓨터는 자기 자신과만 연결되어 있으며, <code>computers[2] = [0, 0, 1]</code>이다. visited[2]를 True로 설정하고, 다시 for 루프를 통해 연결된 컴퓨터를 확인한다. next_node = 0, 1은 모두 연결 상태가 0이므로 건너뛰고, next_node = 2는 자기 자신으로 연결되어 있으나 이미 방문했으므로 무시한다. 더 이상 확장할 수 없으므로 dfs(2)도 종료된다.</p><p>이렇게 모든 컴퓨터를 순회하면서 방문하지 않은 컴퓨터를 만날 때마다 DFS를 시작하고, 네트워크 수를 1 증가시키는 방식으로 탐색한 결과, 총 2번 DFS가 실행되었다. 첫 번째 DFS는 0번을 시작으로 0번과 1번 컴퓨터를 묶었고, 두 번째 DFS는 2번을 시작으로 자기 자신만 포함한 별개의 네트워크를 구성하였다. 따라서 최종적으로 네트워크의 개수는 2가 된다. 이 문제는 결국 컴퓨터 간 연결 관계를 정점 간 연결로 표현한 그래프에서 연결 요소(Connected Components)의 개수를 세는 문제로 이해할 수 있다. DFS는 연결 요소를 한 번의 재귀 호출로 모두 방문 처리할 수 있기 때문에 효율적으로 네트워크 수를 세는 데에 적합하다. 예를 들어, 0번 컴퓨터에서 DFS를 수행하면 그와 연결된 모든 컴퓨터를 따라가며 방문 처리하므로, 하나의 연결 요소(네트워크)를 정확하게 방문하고 마무리할 수 있다. 이런 방식으로 전체 컴퓨터를 반복하면서 새로운 방문이 필요할 때마다 DFS를 수행하면, 연결되지 않은 새로운 네트워크의 시작점이라는 뜻이므로 네트워크 수를 하나씩 늘려주면 된다. 결과적으로 visited 리스트는 모든 컴퓨터가 한 번 이상 방문되어야만 모든 네트워크가 탐색된 것이고, <code>answer</code>는 DFS를 몇 번 수행했는지, 즉 네트워크의 수가 된다. 이 문제에서는 [0, 1]이 하나의 네트워크, [2]가 하나의 네트워크로 총 2개의 네트워크가 있는 것이다. 이처럼 DFS를 이용한 연결 요소 탐색은 컴퓨터 네트워크, 친구 관계, 전염병 확산 모델링 등 다양한 실제 문제에 활용될 수 있는 기본적이면서도 강력한 알고리즘 전략 중 하나다.</p><p>입력 2: <code>n=3</code>, <code>computers=[[1, 1, 0], [1, 1, 1], [0, 1, 1]]</code></p><p>출력 2: <code>1</code></p><p>풀이 2:</p><p>주어진 입력은 컴퓨터의 개수 <code>n = 3</code>이고, 컴퓨터 간의 연결 상태를 나타내는 2차원 배열 <code>computers = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]</code>이다. 이 행렬은 각각의 컴퓨터가 어떤 다른 컴퓨터와 연결되어 있는지를 나타낸다. 예를 들어 <code>computers[0][1] == 1</code>이면 0번 컴퓨터와 1번 컴퓨터가 직접적으로 연결되어 있다는 의미이며, <code>computers[2][0] == 0</code>이면 2번 컴퓨터와 0번 컴퓨터는 연결되어 있지 않다는 뜻이다. 그리고 <code>computers[i][i] == 1</code>인 이유는 각 컴퓨터는 자기 자신과는 항상 연결되어 있다고 가정하기 때문이다. 처음에는 모든 컴퓨터가 방문되지 않은 상태이므로, <code>visited = [False, False, False]</code>로 초기화한다. 여기서 visited[i]는 i번째 컴퓨터가 이미 네트워크 탐색 과정에서 방문되었는지를 나타낸다. 이제 0번부터 n-1번 컴퓨터까지 순차적으로 확인하면서, 아직 방문하지 않은 컴퓨터가 있다면 그 컴퓨터를 시작으로 DFS를 수행하고 네트워크 개수를 하나 증가시킨다.</p><p>먼저 i = 0부터 시작한다. visited[0]이 False이므로 아직 방문되지 않았다. 따라서 이 컴퓨터는 새로운 네트워크의 출발점이 된다. <code>dfs(0)</code>을 호출하며 깊이 우선 탐색을 시작한다. dfs 함수의 내부는 다음과 같이 구성되어 있다. 현재 컴퓨터를 방문 처리하고, 이 컴퓨터와 직접적으로 연결된 다른 컴퓨터들 중 아직 방문하지 않은 컴퓨터가 있다면, 그 컴퓨터로 이동하여 dfs를 재귀적으로 호출하는 방식이다. dfs(0)이 호출되면 먼저 visited[0] = True로 설정한다. 이제 0번 컴퓨터는 방문되었으므로, 이후 다시 접근하지 않는다. computers[0] = [1, 1, 0]이므로 0번은 자기 자신과 1번 컴퓨터와 연결되어 있고, 2번과는 연결되어 있지 않다. 반복문을 통해 각 next_node를 순회한다. next_node = 0일 때는 자기 자신이고 이미 방문되었으므로 무시한다. next_node = 1일 때, computers[0][1] == 1이고 visited[1] == False이므로 아직 방문되지 않은 연결된 컴퓨터이다. 따라서 <code>dfs(1)</code>을 호출한다. dfs(1)에 진입하면 마찬가지로 visited[1] = True로 처리한다. 이제 1번 컴퓨터도 방문한 상태다. computers[1] = [1, 1, 0]이므로 1번은 0번과 1번과 연결되어 있고 2번과는 연결되어 있지 않다. next_node = 0일 때, computers[1][0] == 1이지만 visited[0] == True이므로 이미 방문한 노드이므로 다시 dfs를 호출하지 않는다. next_node = 1은 자기 자신이므로 무시한다. next_node = 2는 computers[1][2] == 0이므로 연결되어 있지 않으므로 역시 무시된다. 결과적으로 dfs(1)은 더 이상 탐색할 컴퓨터가 없으므로 종료된다. 다시 dfs(0)으로 돌아온다. 이제 next_node = 2를 확인한다. computers[0][2] == 0이므로 2번 컴퓨터는 0번과 연결되어 있지 않으며, dfs 탐색 대상이 아니다. dfs(0) 역시 종료된다. 이로써 DFS를 통해 하나의 연결 요소, 즉 하나의 네트워크를 완전히 탐색한 것이다. 현재 visited 리스트는 [True, True, False]가 된다. 즉 0번과 1번 컴퓨터는 같은 네트워크로 묶였고, 2번은 아직 방문되지 않은 상태다. 다시 메인 루프에서 i = 1을 확인한다. visited[1] == True이므로 이미 이전 DFS에서 방문되었으므로 건너뛴다. i = 2를 확인한다. visited[2] == False이므로 아직 방문되지 않았다. 따라서 2번 컴퓨터는 아직 어떤 네트워크에도 포함되지 않았다는 의미이며, 새로운 네트워크의 시작점이 된다. dfs(2)를 호출한다. dfs(2)에 진입하면 visited[2] = True로 설정한다. computers[2] = [0, 0, 1]이므로 2번은 자기 자신 외에는 어느 누구와도 연결되어 있지 않다. next_node = 0, 1은 모두 연결 상태가 0이므로 dfs 호출 없이 건너뛴다. next_node = 2는 자기 자신이므로 무시한다. 따라서 dfs(2)는 더 이상 확장할 수 없으며 즉시 종료된다. 이 DFS 호출을 통해 2번 컴퓨터 단독으로 구성된 하나의 네트워크가 추가되었고, 이제 visited 리스트는 [True, True, True]가 되어 모든 컴퓨터가 방문되었다.</p><p>결과적으로 이 문제에서 DFS는 두 번 호출되었다. 첫 번째 DFS는 0번에서 시작해서 1번까지 확장되며 [0, 1]을 하나의 네트워크로 묶었고, 두 번째 DFS는 2번에서 시작하여 자기 자신만 포함한 [2] 네트워크를 구성하였다. 따라서 네트워크의 총 개수는 2개가 되며, 이것이 문제의 최종 출력이다.</p><p>정답:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>solution</span>(n, computers):
</span></span><span style=display:flex><span>    visited <span style=color:#f92672>=</span> [<span style=color:#66d9ef>False</span>] <span style=color:#f92672>*</span> n
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>dfs</span>(node):
</span></span><span style=display:flex><span>        visited[node] <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> next_node <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> computers[node][next_node] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>and</span> <span style=color:#f92672>not</span> visited[next_node]:
</span></span><span style=display:flex><span>                dfs(next_node)
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>    answer <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> visited[i]:
</span></span><span style=display:flex><span>            dfs(i)
</span></span><span style=display:flex><span>            answer <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> answer
</span></span></code></pre></div><h1><a class=anchor href=#>#</a></h1><p>링크: <a href=https://school.programmers.co.kr/learn/courses/30/lessons/43162>https://school.programmers.co.kr/learn/courses/30/lessons/43162</a></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=yshghid/yshghid.github.io data-repo-id=R_kgDONkMkNg data-category-id=DIC_kwDONkMkNs4CloJh data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents></nav></div></aside></main></body></html>
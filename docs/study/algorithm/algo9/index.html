<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  MutClust 코드 리펙토링 #3 utils
  #

#2025-08-01

MutClust 알고리즘의 코드 구성은 아래와 같은데
MutClust
├── sc/
│    └── lib.py
│    └── arg_parser.py
│    └── utils.py // 전처리 및 분석
└── Test
utils.py는 데이터 전처리 및 분석 함수를 포함한다.
# === Fasta 전처리 ===
def fasta2csv(home_dir, nation_dir, filechunk, ref, outdir):
    for file in filechunk:
        path = os.path.join(home_dir, nation_dir, file)
        filename = os.path.splitext(os.path.basename(file))[0]
        outpath = os.path.join(outdir, f&#34;{filename}.csv&#34;)
        if not os.path.exists(outpath):
            df = DataFrame({'ref': ref.values, 'pos': ref.index})
            seq = ''.join(open(path).readlines()[1:]).strip()
            df['mut'] = [a if a != ref[i] else '' for i, a in enumerate(seq)]
            df.to_csv(outpath, index=False)

def gisaid_fasta2csv(homedir=f&#34;{GISAID_DIR}/Sequence/Preprocessed/&#34;):
    inputdir = os.path.join(homedir, 'MSA_fasta')
    outdir = os.path.join(homedir, 'MSA_mutationinfo')
    Path(outdir).mkdir(exist_ok=True, parents=True)
    core_n = 100
    args_list = []
    for nation_dir in get_dirnames_list(inputdir):
        filelist = get_filenames_list(os.path.join(inputdir, nation_dir))
        for chunk in array_split(filelist, core_n):
            args_list.append((inputdir, nation_dir, chunk, ref_seq, outdir))
    with Pool(core_n) as pool:
        pool.map(fasta2csv, args_list)

# === Nucleotide 전처리 ===
def get_nucleotide_sequence_dict(seq_dir):
    seq_dict = dict()
    seq_list = get_filenames_list(seq_dir)
    for file in seq_list:
        filepath = os.path.join(seq_dir, file)
        df = read_csv(filepath, index_col=0)
        df.name = file.split('.')[0]
        df = df.reset_index(drop=True)
        seq_dict[df.name] = df
    return seq_dict

def getNucleotideRefSeqbyGene():
    return read_csv('/data3/projects/2020_MUTCLUST/Data/Annotation/Nucleotide/covid_annotation.tsv', sep=' ')

def make_nucleotide_mutclust_input(outdir, name, seq_dict=None):
    if not os.path.exists(outdir):
        print(outdir + ' is not exist')
        return

    output_path = os.path.join(outdir, name + '_mutclust_input.tsv')
    freq_df_ATGC_path = os.path.join(outdir, name + '_freq_ATGC.csv') 

    pos_list, freq_list, per_list, entropy_list = [], [], [], []

    if not os.path.exists(freq_df_ATGC_path):
        if seq_dict is None:
            print('load seq_dict')
            return 
        freq_df = DataFrame.from_dict(seq_dict).transpose().fillna(0).astype(int)
        freq_df = freq_df.sort_index()
        freq_df = freq_df[list(IUPAC_CODES.keys())][['A','T','G','C']]
        freq_df.to_csv(freq_df_ATGC_path)
    else:
        freq_df = read_csv(freq_df_ATGC_path, index_col=0)

    for pos in freq_df.index:
        freq = freq_df.loc[pos]
        cnt_n = freq.sum()
        percentage = freq / cnt_n
        entrpy = entropy(percentage, base=2)

        percentage.drop(ref_seq[pos], inplace=True)
        freq.drop(ref_seq[pos], inplace=True)

        pos_list.append(int(pos))
        freq_list.append(freq.sum())
        per_list.append(percentage.sum())
        entropy_list.append(entrpy)

    mutclust_input_df = DataFrame({
        'Position': pos_list,
        'Frequency': freq_list,
        'Percentages': per_list,
        'Entropy': entropy_list
    })
    mutclust_input_df.to_csv(output_path, sep='\t', index=False)
    return mutclust_input_df

# === Mutation 데이터 병렬 처리 ===
def read_thead(filepathlist, return_list, i):
    ref_seq_sr = getNucleotideRefSeq()
    sub_dict = {pos: Counter({k: 0 for k in IUPAC_CODES.keys()}) for pos in ref_seq_sr.index}

    for filepath in filepathlist:
        df = read_csv(filepath, index_col=0).fillna('').reset_index(drop=True)
        for index, mut in enumerate(df['mut']):
            symbol = mut if mut else ref_seq_sr[index + 1]
            if symbol in sub_dict[index + 1]:
                sub_dict[index + 1][symbol] += 1
            else:
                sub_dict[index + 1][symbol] = 1

    return_list.append(sub_dict)
    print(f&#34;{i}th process complete!&#34;)

def merge_thread(poslist, sub_dict_list, return_dict):
    for pos in poslist:
        count_dict = sum([d[pos] for d in sub_dict_list], Counter())
        merged_dict = {k: count_dict.get(k, 0) for k in IUPAC_CODES.keys()}
        return_dict[pos] = merged_dict

def load_mutationinfo(input_dir=COVID19_MUTATIONINFO_DIR, sample_list=None):
    core_n, split_n = 100, 1000 
    sub_dict_list = Manager().list()
    filelist = get_file_paths_recursive(input_dir)
    
    if sample_list:
        filelist = [f for f in filelist if os.path.basename(f).split('.')[0] in sample_list]
    print(f'sample_n: {len(sample_list)}')

    splited_filepaths = array_split(filelist, split_n)
    parameter_list = [(chunk, sub_dict_list, i) for i, chunk in enumerate(splited_filepaths)]
    print('read thread start!')
    multi_processing(read_thead, parameter_list, core_n=core_n)
    print('read thread end!')

    merged_dict = Manager().dict()
    poslist = ref_seq.index
    splited_poslist = array_split(poslist, split_n)
    sub_dict_list = list(sub_dict_list)
    parameter_list = [(pos_chunk, sub_dict_list, merged_dict) for pos_chunk in splited_poslist]

    print('merge thread start!')
    multi_processing(merge_thread, parameter_list, core_n=core_n)
    print('merge thread end!')
    return dict(merged_dict)

# === Matrix 생성 병렬 처리 ===
def make_matrix_thread(file_list):
    clusters_df = pd.read_csv(os.path.join(GISAID_MUTCLUST_OUTPUT_DIR, 'clusters_hscore.txt'), sep='\t')
    column_list = [f&#34;c{i}({row['left_position']},{row['right_position']})&#34; for i, row in clusters_df.iterrows()]
    cluster_df = pd.DataFrame(columns=column_list)

    for path in file_list:
        df = pd.read_csv(path)
        patient_name = os.path.splitext(os.path.basename(path))[0]
        cluster_df.loc[patient_name] = 0
        for pos in df[df['mut'].notnull()]['pos']:
            cluster_idx = clusters_df[(clusters_df['left_position'] <= pos) & (pos <= clusters_df['right_position'])].index
            cluster_df.loc[patient_name][cluster_idx] += 1
    return cluster_df

def make_matrix(mutationinfo_dir, out_dir, tag, cpu_n=60):
    print('starting make matrix!')
    pool = Pool(processes=cpu_n)
    file_list = get_file_paths_recursive(mutationinfo_dir)
    results = pool.map(make_matrix_thread, array_split(file_list, cpu_n))
    pd.concat(results).to_csv(os.path.join(out_dir, f'cluster_matrix_{tag}.csv'))
    pool.close()
    pool.join()

# === H-score 계산 ===
def add_HSCORE():
    df = pd.read_csv(os.path.join(MUTCLUST_INPUT_DIR, 'gisaid_mutclust_input.tsv'), sep='\t')
    df[HSCORE] = df[PER] * df[ENT]
    df.to_csv(os.path.join(MUTCLUST_INPUT_DIR, 'gisaid_mutclust_input_with_score.tsv'), sep='\t', index=False)

# === 주석(Annotation) ===
def annotation():
    import ast
    mapping_df = pd.read_csv(os.path.join(GISAID_METADATA_DIR, 'merged_info.tsv'), sep='\t', index_col=0)
    for i, row in mapping_df.iterrows():
        mapping_df.loc[i] = [ast.literal_eval(val) for val in row]
    print(mapping_df)

def make_clade_divide_mutation():
    clade_dir = './clade_divide_mutation'
    start_dict = getStartDict()
    for file in get_filenames_list(clade_dir):
        df = read_csv(os.path.join(clade_dir, file), sep='\t')
        print(df)

# === 병렬 처리 유틸리티 ===
def multi_processing(func, parameter_list, core_n=100):
    proc, proc_excution, proc_end = [], [], []
    for param in parameter_list:
        proc.append(Process(target=func, args=param))

    while proc or proc_excution:
        for _ in range(len(proc)):
            if len(proc_excution) < core_n:
                p = proc.pop(0)
                p.start()
                proc_excution.append(p)
            else:
                break
        for p in proc_excution[:]:
            if not p.is_alive():
                proc_excution.remove(p)
                p.join()
                p.close()
                proc_end.append(p)

# === 메인 실행 ===
if __name__ == '__main__':
    annotation()

  
  #

#code information"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://yshghid.github.io/docs/study/algorithm/algo9/"><meta property="og:site_name" content=" "><meta property="og:title" content="MutClust 코드 리펙토링 #3 utils"><meta property="og:description" content="MutClust 코드 리펙토링 #3 utils # #2025-08-01
MutClust 알고리즘의 코드 구성은 아래와 같은데
MutClust ├── sc/ │ └── lib.py │ └── arg_parser.py │ └── utils.py // 전처리 및 분석 └── Test utils.py는 데이터 전처리 및 분석 함수를 포함한다.
# === Fasta 전처리 === def fasta2csv(home_dir, nation_dir, filechunk, ref, outdir): for file in filechunk: path = os.path.join(home_dir, nation_dir, file) filename = os.path.splitext(os.path.basename(file))[0] outpath = os.path.join(outdir, f&#34;{filename}.csv&#34;) if not os.path.exists(outpath): df = DataFrame({'ref': ref.values, 'pos': ref.index}) seq = ''.join(open(path).readlines()[1:]).strip() df['mut'] = [a if a != ref[i] else '' for i, a in enumerate(seq)] df.to_csv(outpath, index=False) def gisaid_fasta2csv(homedir=f&#34;{GISAID_DIR}/Sequence/Preprocessed/&#34;): inputdir = os.path.join(homedir, 'MSA_fasta') outdir = os.path.join(homedir, 'MSA_mutationinfo') Path(outdir).mkdir(exist_ok=True, parents=True) core_n = 100 args_list = [] for nation_dir in get_dirnames_list(inputdir): filelist = get_filenames_list(os.path.join(inputdir, nation_dir)) for chunk in array_split(filelist, core_n): args_list.append((inputdir, nation_dir, chunk, ref_seq, outdir)) with Pool(core_n) as pool: pool.map(fasta2csv, args_list) # === Nucleotide 전처리 === def get_nucleotide_sequence_dict(seq_dir): seq_dict = dict() seq_list = get_filenames_list(seq_dir) for file in seq_list: filepath = os.path.join(seq_dir, file) df = read_csv(filepath, index_col=0) df.name = file.split('.')[0] df = df.reset_index(drop=True) seq_dict[df.name] = df return seq_dict def getNucleotideRefSeqbyGene(): return read_csv('/data3/projects/2020_MUTCLUST/Data/Annotation/Nucleotide/covid_annotation.tsv', sep=' ') def make_nucleotide_mutclust_input(outdir, name, seq_dict=None): if not os.path.exists(outdir): print(outdir + ' is not exist') return output_path = os.path.join(outdir, name + '_mutclust_input.tsv') freq_df_ATGC_path = os.path.join(outdir, name + '_freq_ATGC.csv') pos_list, freq_list, per_list, entropy_list = [], [], [], [] if not os.path.exists(freq_df_ATGC_path): if seq_dict is None: print('load seq_dict') return freq_df = DataFrame.from_dict(seq_dict).transpose().fillna(0).astype(int) freq_df = freq_df.sort_index() freq_df = freq_df[list(IUPAC_CODES.keys())][['A','T','G','C']] freq_df.to_csv(freq_df_ATGC_path) else: freq_df = read_csv(freq_df_ATGC_path, index_col=0) for pos in freq_df.index: freq = freq_df.loc[pos] cnt_n = freq.sum() percentage = freq / cnt_n entrpy = entropy(percentage, base=2) percentage.drop(ref_seq[pos], inplace=True) freq.drop(ref_seq[pos], inplace=True) pos_list.append(int(pos)) freq_list.append(freq.sum()) per_list.append(percentage.sum()) entropy_list.append(entrpy) mutclust_input_df = DataFrame({ 'Position': pos_list, 'Frequency': freq_list, 'Percentages': per_list, 'Entropy': entropy_list }) mutclust_input_df.to_csv(output_path, sep='\t', index=False) return mutclust_input_df # === Mutation 데이터 병렬 처리 === def read_thead(filepathlist, return_list, i): ref_seq_sr = getNucleotideRefSeq() sub_dict = {pos: Counter({k: 0 for k in IUPAC_CODES.keys()}) for pos in ref_seq_sr.index} for filepath in filepathlist: df = read_csv(filepath, index_col=0).fillna('').reset_index(drop=True) for index, mut in enumerate(df['mut']): symbol = mut if mut else ref_seq_sr[index + 1] if symbol in sub_dict[index + 1]: sub_dict[index + 1][symbol] += 1 else: sub_dict[index + 1][symbol] = 1 return_list.append(sub_dict) print(f&#34;{i}th process complete!&#34;) def merge_thread(poslist, sub_dict_list, return_dict): for pos in poslist: count_dict = sum([d[pos] for d in sub_dict_list], Counter()) merged_dict = {k: count_dict.get(k, 0) for k in IUPAC_CODES.keys()} return_dict[pos] = merged_dict def load_mutationinfo(input_dir=COVID19_MUTATIONINFO_DIR, sample_list=None): core_n, split_n = 100, 1000 sub_dict_list = Manager().list() filelist = get_file_paths_recursive(input_dir) if sample_list: filelist = [f for f in filelist if os.path.basename(f).split('.')[0] in sample_list] print(f'sample_n: {len(sample_list)}') splited_filepaths = array_split(filelist, split_n) parameter_list = [(chunk, sub_dict_list, i) for i, chunk in enumerate(splited_filepaths)] print('read thread start!') multi_processing(read_thead, parameter_list, core_n=core_n) print('read thread end!') merged_dict = Manager().dict() poslist = ref_seq.index splited_poslist = array_split(poslist, split_n) sub_dict_list = list(sub_dict_list) parameter_list = [(pos_chunk, sub_dict_list, merged_dict) for pos_chunk in splited_poslist] print('merge thread start!') multi_processing(merge_thread, parameter_list, core_n=core_n) print('merge thread end!') return dict(merged_dict) # === Matrix 생성 병렬 처리 === def make_matrix_thread(file_list): clusters_df = pd.read_csv(os.path.join(GISAID_MUTCLUST_OUTPUT_DIR, 'clusters_hscore.txt'), sep='\t') column_list = [f&#34;c{i}({row['left_position']},{row['right_position']})&#34; for i, row in clusters_df.iterrows()] cluster_df = pd.DataFrame(columns=column_list) for path in file_list: df = pd.read_csv(path) patient_name = os.path.splitext(os.path.basename(path))[0] cluster_df.loc[patient_name] = 0 for pos in df[df['mut'].notnull()]['pos']: cluster_idx = clusters_df[(clusters_df['left_position'] <= pos) & (pos <= clusters_df['right_position'])].index cluster_df.loc[patient_name][cluster_idx] += 1 return cluster_df def make_matrix(mutationinfo_dir, out_dir, tag, cpu_n=60): print('starting make matrix!') pool = Pool(processes=cpu_n) file_list = get_file_paths_recursive(mutationinfo_dir) results = pool.map(make_matrix_thread, array_split(file_list, cpu_n)) pd.concat(results).to_csv(os.path.join(out_dir, f'cluster_matrix_{tag}.csv')) pool.close() pool.join() # === H-score 계산 === def add_HSCORE(): df = pd.read_csv(os.path.join(MUTCLUST_INPUT_DIR, 'gisaid_mutclust_input.tsv'), sep='\t') df[HSCORE] = df[PER] * df[ENT] df.to_csv(os.path.join(MUTCLUST_INPUT_DIR, 'gisaid_mutclust_input_with_score.tsv'), sep='\t', index=False) # === 주석(Annotation) === def annotation(): import ast mapping_df = pd.read_csv(os.path.join(GISAID_METADATA_DIR, 'merged_info.tsv'), sep='\t', index_col=0) for i, row in mapping_df.iterrows(): mapping_df.loc[i] = [ast.literal_eval(val) for val in row] print(mapping_df) def make_clade_divide_mutation(): clade_dir = './clade_divide_mutation' start_dict = getStartDict() for file in get_filenames_list(clade_dir): df = read_csv(os.path.join(clade_dir, file), sep='\t') print(df) # === 병렬 처리 유틸리티 === def multi_processing(func, parameter_list, core_n=100): proc, proc_excution, proc_end = [], [], [] for param in parameter_list: proc.append(Process(target=func, args=param)) while proc or proc_excution: for _ in range(len(proc)): if len(proc_excution) < core_n: p = proc.pop(0) p.start() proc_excution.append(p) else: break for p in proc_excution[:]: if not p.is_alive(): proc_excution.remove(p) p.join() p.close() proc_end.append(p) # === 메인 실행 === if __name__ == '__main__': annotation() # #code information"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2025-08-01T00:00:00+00:00"><meta property="article:modified_time" content="2025-08-01T00:00:00+00:00"><meta property="article:tag" content="2025-08"><title>MutClust 코드 리펙토링 #3 utils |</title><link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://yshghid.github.io/docs/study/algorithm/algo9/><link rel=stylesheet href=/book.min.30a7836b6a89342da3b88e7afd1036166aeced16c8de12df060ded2031837886.css integrity="sha256-MKeDa2qJNC2juI56/RA2Fmrs7RbI3hLfBg3tIDGDeIY=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.3b2ab34fb13bc527cdbdf57dc972d28208c4a030260a55dae787b0b5afce5f67.js integrity="sha256-OyqzT7E7xSfNvfV9yXLSggjEoDAmClXa54ewta/OX2c=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/logo.png alt=Logo class=book-icon><span></span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><span>기록</span><ul><li><a href=/docs/hobby/daily/>일상</a><ul></ul></li><li><a href=/docs/hobby/book/>글</a><ul></ul></li></ul></li><li class=book-section-flat><span>공부</span><ul><li><a href=/docs/study/bioinformatics/>Bioinformatics</a><ul></ul></li><li><a href=/docs/study/ai/>AI</a><ul></ul></li><li><a href=/docs/study/sw/>SW</a><ul></ul></li><li><a href=/docs/study/algorithm/>알고리즘</a><ul></ul></li><li><a href=/docs/study/career/>취업</a><ul></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>MutClust 코드 리펙토링 #3 utils</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents></nav></aside></header><article class="markdown book-article"><h1 id=mutclust-코드-리펙토링-3-utils>MutClust 코드 리펙토링 #3 utils
<a class=anchor href=#mutclust-%ec%bd%94%eb%93%9c-%eb%a6%ac%ed%8e%99%ed%86%a0%eb%a7%81-3-utils>#</a></h1><p>#2025-08-01</p><hr><p>MutClust 알고리즘의 코드 구성은 아래와 같은데</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>MutClust
</span></span><span style=display:flex><span>├── sc/
</span></span><span style=display:flex><span>│    └── lib.py
</span></span><span style=display:flex><span>│    └── arg_parser.py
</span></span><span style=display:flex><span>│    └── utils.py // 전처리 및 분석
</span></span><span style=display:flex><span>└── Test
</span></span></code></pre></div><p>utils.py는 데이터 전처리 및 분석 함수를 포함한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># === Fasta 전처리 ===</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fasta2csv</span>(home_dir, nation_dir, filechunk, ref, outdir):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> file <span style=color:#f92672>in</span> filechunk:
</span></span><span style=display:flex><span>        path <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(home_dir, nation_dir, file)
</span></span><span style=display:flex><span>        filename <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>splitext(os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>basename(file))[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        outpath <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(outdir, <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>filename<span style=color:#e6db74>}</span><span style=color:#e6db74>.csv&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>exists(outpath):
</span></span><span style=display:flex><span>            df <span style=color:#f92672>=</span> DataFrame({<span style=color:#e6db74>&#39;ref&#39;</span>: ref<span style=color:#f92672>.</span>values, <span style=color:#e6db74>&#39;pos&#39;</span>: ref<span style=color:#f92672>.</span>index})
</span></span><span style=display:flex><span>            seq <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join(open(path)<span style=color:#f92672>.</span>readlines()[<span style=color:#ae81ff>1</span>:])<span style=color:#f92672>.</span>strip()
</span></span><span style=display:flex><span>            df[<span style=color:#e6db74>&#39;mut&#39;</span>] <span style=color:#f92672>=</span> [a <span style=color:#66d9ef>if</span> a <span style=color:#f92672>!=</span> ref[i] <span style=color:#66d9ef>else</span> <span style=color:#e6db74>&#39;&#39;</span> <span style=color:#66d9ef>for</span> i, a <span style=color:#f92672>in</span> enumerate(seq)]
</span></span><span style=display:flex><span>            df<span style=color:#f92672>.</span>to_csv(outpath, index<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>gisaid_fasta2csv</span>(homedir<span style=color:#f92672>=</span><span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>GISAID_DIR<span style=color:#e6db74>}</span><span style=color:#e6db74>/Sequence/Preprocessed/&#34;</span>):
</span></span><span style=display:flex><span>    inputdir <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(homedir, <span style=color:#e6db74>&#39;MSA_fasta&#39;</span>)
</span></span><span style=display:flex><span>    outdir <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(homedir, <span style=color:#e6db74>&#39;MSA_mutationinfo&#39;</span>)
</span></span><span style=display:flex><span>    Path(outdir)<span style=color:#f92672>.</span>mkdir(exist_ok<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>, parents<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>    core_n <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>    args_list <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> nation_dir <span style=color:#f92672>in</span> get_dirnames_list(inputdir):
</span></span><span style=display:flex><span>        filelist <span style=color:#f92672>=</span> get_filenames_list(os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(inputdir, nation_dir))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> chunk <span style=color:#f92672>in</span> array_split(filelist, core_n):
</span></span><span style=display:flex><span>            args_list<span style=color:#f92672>.</span>append((inputdir, nation_dir, chunk, ref_seq, outdir))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> Pool(core_n) <span style=color:#66d9ef>as</span> pool:
</span></span><span style=display:flex><span>        pool<span style=color:#f92672>.</span>map(fasta2csv, args_list)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># === Nucleotide 전처리 ===</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_nucleotide_sequence_dict</span>(seq_dir):
</span></span><span style=display:flex><span>    seq_dict <span style=color:#f92672>=</span> dict()
</span></span><span style=display:flex><span>    seq_list <span style=color:#f92672>=</span> get_filenames_list(seq_dir)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> file <span style=color:#f92672>in</span> seq_list:
</span></span><span style=display:flex><span>        filepath <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(seq_dir, file)
</span></span><span style=display:flex><span>        df <span style=color:#f92672>=</span> read_csv(filepath, index_col<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        df<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> file<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39;.&#39;</span>)[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        df <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>reset_index(drop<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>        seq_dict[df<span style=color:#f92672>.</span>name] <span style=color:#f92672>=</span> df
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> seq_dict
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>getNucleotideRefSeqbyGene</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> read_csv(<span style=color:#e6db74>&#39;/data3/projects/2020_MUTCLUST/Data/Annotation/Nucleotide/covid_annotation.tsv&#39;</span>, sep<span style=color:#f92672>=</span><span style=color:#e6db74>&#39; &#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_nucleotide_mutclust_input</span>(outdir, name, seq_dict<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>exists(outdir):
</span></span><span style=display:flex><span>        print(outdir <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39; is not exist&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    output_path <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(outdir, name <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;_mutclust_input.tsv&#39;</span>)
</span></span><span style=display:flex><span>    freq_df_ATGC_path <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(outdir, name <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;_freq_ATGC.csv&#39;</span>) 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pos_list, freq_list, per_list, entropy_list <span style=color:#f92672>=</span> [], [], [], []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>exists(freq_df_ATGC_path):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> seq_dict <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            print(<span style=color:#e6db74>&#39;load seq_dict&#39;</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> 
</span></span><span style=display:flex><span>        freq_df <span style=color:#f92672>=</span> DataFrame<span style=color:#f92672>.</span>from_dict(seq_dict)<span style=color:#f92672>.</span>transpose()<span style=color:#f92672>.</span>fillna(<span style=color:#ae81ff>0</span>)<span style=color:#f92672>.</span>astype(int)
</span></span><span style=display:flex><span>        freq_df <span style=color:#f92672>=</span> freq_df<span style=color:#f92672>.</span>sort_index()
</span></span><span style=display:flex><span>        freq_df <span style=color:#f92672>=</span> freq_df[list(IUPAC_CODES<span style=color:#f92672>.</span>keys())][[<span style=color:#e6db74>&#39;A&#39;</span>,<span style=color:#e6db74>&#39;T&#39;</span>,<span style=color:#e6db74>&#39;G&#39;</span>,<span style=color:#e6db74>&#39;C&#39;</span>]]
</span></span><span style=display:flex><span>        freq_df<span style=color:#f92672>.</span>to_csv(freq_df_ATGC_path)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        freq_df <span style=color:#f92672>=</span> read_csv(freq_df_ATGC_path, index_col<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> pos <span style=color:#f92672>in</span> freq_df<span style=color:#f92672>.</span>index:
</span></span><span style=display:flex><span>        freq <span style=color:#f92672>=</span> freq_df<span style=color:#f92672>.</span>loc[pos]
</span></span><span style=display:flex><span>        cnt_n <span style=color:#f92672>=</span> freq<span style=color:#f92672>.</span>sum()
</span></span><span style=display:flex><span>        percentage <span style=color:#f92672>=</span> freq <span style=color:#f92672>/</span> cnt_n
</span></span><span style=display:flex><span>        entrpy <span style=color:#f92672>=</span> entropy(percentage, base<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        percentage<span style=color:#f92672>.</span>drop(ref_seq[pos], inplace<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>        freq<span style=color:#f92672>.</span>drop(ref_seq[pos], inplace<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        pos_list<span style=color:#f92672>.</span>append(int(pos))
</span></span><span style=display:flex><span>        freq_list<span style=color:#f92672>.</span>append(freq<span style=color:#f92672>.</span>sum())
</span></span><span style=display:flex><span>        per_list<span style=color:#f92672>.</span>append(percentage<span style=color:#f92672>.</span>sum())
</span></span><span style=display:flex><span>        entropy_list<span style=color:#f92672>.</span>append(entrpy)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    mutclust_input_df <span style=color:#f92672>=</span> DataFrame({
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;Position&#39;</span>: pos_list,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;Frequency&#39;</span>: freq_list,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;Percentages&#39;</span>: per_list,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;Entropy&#39;</span>: entropy_list
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    mutclust_input_df<span style=color:#f92672>.</span>to_csv(output_path, sep<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>&#39;</span>, index<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> mutclust_input_df
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># === Mutation 데이터 병렬 처리 ===</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>read_thead</span>(filepathlist, return_list, i):
</span></span><span style=display:flex><span>    ref_seq_sr <span style=color:#f92672>=</span> getNucleotideRefSeq()
</span></span><span style=display:flex><span>    sub_dict <span style=color:#f92672>=</span> {pos: Counter({k: <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>for</span> k <span style=color:#f92672>in</span> IUPAC_CODES<span style=color:#f92672>.</span>keys()}) <span style=color:#66d9ef>for</span> pos <span style=color:#f92672>in</span> ref_seq_sr<span style=color:#f92672>.</span>index}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> filepath <span style=color:#f92672>in</span> filepathlist:
</span></span><span style=display:flex><span>        df <span style=color:#f92672>=</span> read_csv(filepath, index_col<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>)<span style=color:#f92672>.</span>fillna(<span style=color:#e6db74>&#39;&#39;</span>)<span style=color:#f92672>.</span>reset_index(drop<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> index, mut <span style=color:#f92672>in</span> enumerate(df[<span style=color:#e6db74>&#39;mut&#39;</span>]):
</span></span><span style=display:flex><span>            symbol <span style=color:#f92672>=</span> mut <span style=color:#66d9ef>if</span> mut <span style=color:#66d9ef>else</span> ref_seq_sr[index <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> symbol <span style=color:#f92672>in</span> sub_dict[index <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]:
</span></span><span style=display:flex><span>                sub_dict[index <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][symbol] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                sub_dict[index <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][symbol] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return_list<span style=color:#f92672>.</span>append(sub_dict)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>th process complete!&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>merge_thread</span>(poslist, sub_dict_list, return_dict):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> pos <span style=color:#f92672>in</span> poslist:
</span></span><span style=display:flex><span>        count_dict <span style=color:#f92672>=</span> sum([d[pos] <span style=color:#66d9ef>for</span> d <span style=color:#f92672>in</span> sub_dict_list], Counter())
</span></span><span style=display:flex><span>        merged_dict <span style=color:#f92672>=</span> {k: count_dict<span style=color:#f92672>.</span>get(k, <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>for</span> k <span style=color:#f92672>in</span> IUPAC_CODES<span style=color:#f92672>.</span>keys()}
</span></span><span style=display:flex><span>        return_dict[pos] <span style=color:#f92672>=</span> merged_dict
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>load_mutationinfo</span>(input_dir<span style=color:#f92672>=</span>COVID19_MUTATIONINFO_DIR, sample_list<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>    core_n, split_n <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>1000</span> 
</span></span><span style=display:flex><span>    sub_dict_list <span style=color:#f92672>=</span> Manager()<span style=color:#f92672>.</span>list()
</span></span><span style=display:flex><span>    filelist <span style=color:#f92672>=</span> get_file_paths_recursive(input_dir)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> sample_list:
</span></span><span style=display:flex><span>        filelist <span style=color:#f92672>=</span> [f <span style=color:#66d9ef>for</span> f <span style=color:#f92672>in</span> filelist <span style=color:#66d9ef>if</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>basename(f)<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39;.&#39;</span>)[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>in</span> sample_list]
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;sample_n: </span><span style=color:#e6db74>{</span>len(sample_list)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    splited_filepaths <span style=color:#f92672>=</span> array_split(filelist, split_n)
</span></span><span style=display:flex><span>    parameter_list <span style=color:#f92672>=</span> [(chunk, sub_dict_list, i) <span style=color:#66d9ef>for</span> i, chunk <span style=color:#f92672>in</span> enumerate(splited_filepaths)]
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;read thread start!&#39;</span>)
</span></span><span style=display:flex><span>    multi_processing(read_thead, parameter_list, core_n<span style=color:#f92672>=</span>core_n)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;read thread end!&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    merged_dict <span style=color:#f92672>=</span> Manager()<span style=color:#f92672>.</span>dict()
</span></span><span style=display:flex><span>    poslist <span style=color:#f92672>=</span> ref_seq<span style=color:#f92672>.</span>index
</span></span><span style=display:flex><span>    splited_poslist <span style=color:#f92672>=</span> array_split(poslist, split_n)
</span></span><span style=display:flex><span>    sub_dict_list <span style=color:#f92672>=</span> list(sub_dict_list)
</span></span><span style=display:flex><span>    parameter_list <span style=color:#f92672>=</span> [(pos_chunk, sub_dict_list, merged_dict) <span style=color:#66d9ef>for</span> pos_chunk <span style=color:#f92672>in</span> splited_poslist]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;merge thread start!&#39;</span>)
</span></span><span style=display:flex><span>    multi_processing(merge_thread, parameter_list, core_n<span style=color:#f92672>=</span>core_n)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;merge thread end!&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dict(merged_dict)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># === Matrix 생성 병렬 처리 ===</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_matrix_thread</span>(file_list):
</span></span><span style=display:flex><span>    clusters_df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>read_csv(os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(GISAID_MUTCLUST_OUTPUT_DIR, <span style=color:#e6db74>&#39;clusters_hscore.txt&#39;</span>), sep<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>    column_list <span style=color:#f92672>=</span> [<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;c</span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>(</span><span style=color:#e6db74>{</span>row[<span style=color:#e6db74>&#39;left_position&#39;</span>]<span style=color:#e6db74>}</span><span style=color:#e6db74>,</span><span style=color:#e6db74>{</span>row[<span style=color:#e6db74>&#39;right_position&#39;</span>]<span style=color:#e6db74>}</span><span style=color:#e6db74>)&#34;</span> <span style=color:#66d9ef>for</span> i, row <span style=color:#f92672>in</span> clusters_df<span style=color:#f92672>.</span>iterrows()]
</span></span><span style=display:flex><span>    cluster_df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame(columns<span style=color:#f92672>=</span>column_list)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> path <span style=color:#f92672>in</span> file_list:
</span></span><span style=display:flex><span>        df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>read_csv(path)
</span></span><span style=display:flex><span>        patient_name <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>splitext(os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>basename(path))[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        cluster_df<span style=color:#f92672>.</span>loc[patient_name] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> pos <span style=color:#f92672>in</span> df[df[<span style=color:#e6db74>&#39;mut&#39;</span>]<span style=color:#f92672>.</span>notnull()][<span style=color:#e6db74>&#39;pos&#39;</span>]:
</span></span><span style=display:flex><span>            cluster_idx <span style=color:#f92672>=</span> clusters_df[(clusters_df[<span style=color:#e6db74>&#39;left_position&#39;</span>] <span style=color:#f92672>&lt;=</span> pos) <span style=color:#f92672>&amp;</span> (pos <span style=color:#f92672>&lt;=</span> clusters_df[<span style=color:#e6db74>&#39;right_position&#39;</span>])]<span style=color:#f92672>.</span>index
</span></span><span style=display:flex><span>            cluster_df<span style=color:#f92672>.</span>loc[patient_name][cluster_idx] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> cluster_df
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_matrix</span>(mutationinfo_dir, out_dir, tag, cpu_n<span style=color:#f92672>=</span><span style=color:#ae81ff>60</span>):
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;starting make matrix!&#39;</span>)
</span></span><span style=display:flex><span>    pool <span style=color:#f92672>=</span> Pool(processes<span style=color:#f92672>=</span>cpu_n)
</span></span><span style=display:flex><span>    file_list <span style=color:#f92672>=</span> get_file_paths_recursive(mutationinfo_dir)
</span></span><span style=display:flex><span>    results <span style=color:#f92672>=</span> pool<span style=color:#f92672>.</span>map(make_matrix_thread, array_split(file_list, cpu_n))
</span></span><span style=display:flex><span>    pd<span style=color:#f92672>.</span>concat(results)<span style=color:#f92672>.</span>to_csv(os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(out_dir, <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;cluster_matrix_</span><span style=color:#e6db74>{</span>tag<span style=color:#e6db74>}</span><span style=color:#e6db74>.csv&#39;</span>))
</span></span><span style=display:flex><span>    pool<span style=color:#f92672>.</span>close()
</span></span><span style=display:flex><span>    pool<span style=color:#f92672>.</span>join()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># === H-score 계산 ===</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add_HSCORE</span>():
</span></span><span style=display:flex><span>    df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>read_csv(os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(MUTCLUST_INPUT_DIR, <span style=color:#e6db74>&#39;gisaid_mutclust_input.tsv&#39;</span>), sep<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>    df[HSCORE] <span style=color:#f92672>=</span> df[PER] <span style=color:#f92672>*</span> df[ENT]
</span></span><span style=display:flex><span>    df<span style=color:#f92672>.</span>to_csv(os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(MUTCLUST_INPUT_DIR, <span style=color:#e6db74>&#39;gisaid_mutclust_input_with_score.tsv&#39;</span>), sep<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>&#39;</span>, index<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># === 주석(Annotation) ===</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>annotation</span>():
</span></span><span style=display:flex><span>    <span style=color:#f92672>import</span> ast
</span></span><span style=display:flex><span>    mapping_df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>read_csv(os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(GISAID_METADATA_DIR, <span style=color:#e6db74>&#39;merged_info.tsv&#39;</span>), sep<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>&#39;</span>, index_col<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i, row <span style=color:#f92672>in</span> mapping_df<span style=color:#f92672>.</span>iterrows():
</span></span><span style=display:flex><span>        mapping_df<span style=color:#f92672>.</span>loc[i] <span style=color:#f92672>=</span> [ast<span style=color:#f92672>.</span>literal_eval(val) <span style=color:#66d9ef>for</span> val <span style=color:#f92672>in</span> row]
</span></span><span style=display:flex><span>    print(mapping_df)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_clade_divide_mutation</span>():
</span></span><span style=display:flex><span>    clade_dir <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;./clade_divide_mutation&#39;</span>
</span></span><span style=display:flex><span>    start_dict <span style=color:#f92672>=</span> getStartDict()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> file <span style=color:#f92672>in</span> get_filenames_list(clade_dir):
</span></span><span style=display:flex><span>        df <span style=color:#f92672>=</span> read_csv(os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(clade_dir, file), sep<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>        print(df)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># === 병렬 처리 유틸리티 ===</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>multi_processing</span>(func, parameter_list, core_n<span style=color:#f92672>=</span><span style=color:#ae81ff>100</span>):
</span></span><span style=display:flex><span>    proc, proc_excution, proc_end <span style=color:#f92672>=</span> [], [], []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> param <span style=color:#f92672>in</span> parameter_list:
</span></span><span style=display:flex><span>        proc<span style=color:#f92672>.</span>append(Process(target<span style=color:#f92672>=</span>func, args<span style=color:#f92672>=</span>param))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> proc <span style=color:#f92672>or</span> proc_excution:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(len(proc)):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> len(proc_excution) <span style=color:#f92672>&lt;</span> core_n:
</span></span><span style=display:flex><span>                p <span style=color:#f92672>=</span> proc<span style=color:#f92672>.</span>pop(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                p<span style=color:#f92672>.</span>start()
</span></span><span style=display:flex><span>                proc_excution<span style=color:#f92672>.</span>append(p)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> p <span style=color:#f92672>in</span> proc_excution[:]:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> p<span style=color:#f92672>.</span>is_alive():
</span></span><span style=display:flex><span>                proc_excution<span style=color:#f92672>.</span>remove(p)
</span></span><span style=display:flex><span>                p<span style=color:#f92672>.</span>join()
</span></span><span style=display:flex><span>                p<span style=color:#f92672>.</span>close()
</span></span><span style=display:flex><span>                proc_end<span style=color:#f92672>.</span>append(p)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># === 메인 실행 ===</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    annotation()
</span></span></code></pre></div><h1><a class=anchor href=#>#</a></h1><p>#code information</p><p>Lab github - <a href=https://github.com/cobi-git/mutclust>https://github.com/cobi-git/mutclust</a></p><p><em><del>이지만 본 코드는 게시되지않음.</del></em></p><h1><a class=anchor href=#>#</a></h1></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=yshghid/yshghid.github.io data-repo-id=R_kgDONkMkNg data-category-id=DIC_kwDONkMkNs4CloJh data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents></nav></div></aside></main></body></html>
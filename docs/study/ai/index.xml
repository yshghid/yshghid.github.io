<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AI on</title><link>https://yshghid.github.io/docs/study/ai/</link><description>Recent content in AI on</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 23 Jul 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://yshghid.github.io/docs/study/ai/index.xml" rel="self" type="application/rss+xml"/><item><title>TFT #0 연구 방향</title><link>https://yshghid.github.io/docs/study/ai/ai4/</link><pubDate>Wed, 23 Jul 2025 00:00:00 +0000</pubDate><guid>https://yshghid.github.io/docs/study/ai/ai4/</guid><description>&lt;h1 id="tft-0-연구-방향">
 TFT #0 연구 방향
 &lt;a class="anchor" href="#tft-0-%ec%97%b0%ea%b5%ac-%eb%b0%a9%ed%96%a5">#&lt;/a>
&lt;/h1>
&lt;p>#2025-07-23&lt;/p>
&lt;hr>
&lt;h3 id="0-연구-개요">
 0. 연구 개요
 &lt;a class="anchor" href="#0-%ec%97%b0%ea%b5%ac-%ea%b0%9c%ec%9a%94">#&lt;/a>
&lt;/h3>
&lt;p>목적: 항생제 종류에 따라 NEWS score를 예측&lt;/p>
&lt;p>모델: Temporal Fusion Transformer(TFT)&lt;/p>
&lt;h3 id="1-데이터-구성-및-tft-입력-형식">
 1. 데이터 구성 및 TFT 입력 형식
 &lt;a class="anchor" href="#1-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ea%b5%ac%ec%84%b1-%eb%b0%8f-tft-%ec%9e%85%eb%a0%a5-%ed%98%95%ec%8b%9d">#&lt;/a>
&lt;/h3>
&lt;ol>
&lt;li>데이터 종류&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>Clinical feature (17개, float): Creatinine, Hemoglobin, LDH, Lymphocytes, Neutrophils, Platelet count, WBC count, hs-CRP, D-Dimer, BDTEMP, BREATH, DBP, SBP, PULSE, SPO2, O2_APPLY&lt;/li>
&lt;li>Antibiotics feature (2개, 문자열)&lt;/li>
&lt;li>Treatment: 투여 항생제 목록 (복수 가능, 결측 가능)&lt;/li>
&lt;li>Strain: 감염 균주 (1개)&lt;/li>
&lt;li>NEWS: 중증도&lt;/li>
&lt;li>Code: 환자 식별자&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>
&lt;p>시계열 범위: 항생제 투여 기준 D-3부터 D+6까지 10일&lt;/p></description></item><item><title>RAG #2 출력 파서의 개념, Pydantic/Json 출력 파서</title><link>https://yshghid.github.io/docs/study/ai/ai2/</link><pubDate>Sat, 19 Jul 2025 00:00:00 +0000</pubDate><guid>https://yshghid.github.io/docs/study/ai/ai2/</guid><description>&lt;h1 id="rag-2-출력-파서의-개념-pydanticjson-출력-파서">
 RAG #2 출력 파서의 개념, Pydantic/Json 출력 파서
 &lt;a class="anchor" href="#rag-2-%ec%b6%9c%eb%a0%a5-%ed%8c%8c%ec%84%9c%ec%9d%98-%ea%b0%9c%eb%85%90-pydanticjson-%ec%b6%9c%eb%a0%a5-%ed%8c%8c%ec%84%9c">#&lt;/a>
&lt;/h1>
&lt;p>#2025-07-19&lt;/p>
&lt;hr>
&lt;h3 id="1-출력-파서의-개념과-종류-그리고-세가지-주요-메서드">
 1. 출력 파서의 개념과 종류 그리고 세가지 주요 메서드
 &lt;a class="anchor" href="#1-%ec%b6%9c%eb%a0%a5-%ed%8c%8c%ec%84%9c%ec%9d%98-%ea%b0%9c%eb%85%90%ea%b3%bc-%ec%a2%85%eb%a5%98-%ea%b7%b8%eb%a6%ac%ea%b3%a0-%ec%84%b8%ea%b0%80%ec%a7%80-%ec%a3%bc%ec%9a%94-%eb%a9%94%ec%84%9c%eb%93%9c">#&lt;/a>
&lt;/h3>
&lt;p>출력 파서(output parser)는 LLM에서 생성된 응답을 받아서 우리가 원하는 형식으로 변환해주는 역할을 한다. 쉽게 말해, LLM은 텍스트만 생성하지만 우리는 그 텍스트를 리스트, 딕셔너리, JSON, 숫자 등 구조화된 데이터로 바꾸어서 프로그램에 넘기거나, 다음 단계 체인으로 활용하길 원할 때가 많다. 출력 파서는 이 연결고리 역할을 한다. 출력 파서는 LLM이라는 기계가 말한 인간 언어를 다시 기계가 이해할 수 있는 언어로 &amp;lsquo;번역&amp;rsquo;하는 통역사 같은 존재이다. 예를 들어 LLM이 “답은 아시아입니다”라고 말하면, 이걸 다시 &lt;code>{&amp;quot;answer&amp;quot;: &amp;quot;아시아&amp;quot;}&lt;/code> 같은 JSON 객체로 바꿔주는 게 파서의 역할이다. 반대로 말하면, 출력 파서 없이는 LLM이 말한 결과를 그대로 사람이 읽고 판단하거나 후처리 코드를 추가해야만 한다.&lt;/p></description></item><item><title>RAG #3 자동 대화 이력 관리</title><link>https://yshghid.github.io/docs/study/ai/ai3/</link><pubDate>Sat, 19 Jul 2025 00:00:00 +0000</pubDate><guid>https://yshghid.github.io/docs/study/ai/ai3/</guid><description>&lt;h1 id="rag-3-자동-대화-이력-관리">
 RAG #3 자동 대화 이력 관리
 &lt;a class="anchor" href="#rag-3-%ec%9e%90%eb%8f%99-%eb%8c%80%ed%99%94-%ec%9d%b4%eb%a0%a5-%ea%b4%80%eb%a6%ac">#&lt;/a>
&lt;/h1>
&lt;p>#2025-07-19&lt;/p>
&lt;hr>
&lt;h3 id="1-자동-대화-이력-관리">
 1. 자동 대화 이력 관리
 &lt;a class="anchor" href="#1-%ec%9e%90%eb%8f%99-%eb%8c%80%ed%99%94-%ec%9d%b4%eb%a0%a5-%ea%b4%80%eb%a6%ac">#&lt;/a>
&lt;/h3>
&lt;p>&lt;code>ChatPromptTemplate&lt;/code>을 통해 시스템 메시지를 포함하는 프롬프트를 만든다. 시스템 메시지는 모델에게 “너는 금융 상담사야”라고 역할을 부여하는 것이다. 이어지는 &lt;code>(&amp;quot;placeholder&amp;quot;, &amp;quot;{messages}&amp;quot;)&lt;/code>는 실제 사용자의 질문과 AI의 답변이 이 자리에 채워질 것이라는 의미다. 이 프롬프트는 &lt;code>chat = ChatOpenAI(model=&amp;quot;gpt-4o-mini&amp;quot;)&lt;/code>와 연결되는데, 이는 OpenAI의 gpt-4o-mini 모델을 사용하는 챗 인터페이스이다. 이 프롬프트와 모델을 &lt;code>prompt | chat&lt;/code>이라는 LCEL 표현으로 묶으면, 하나의 체인이 만들어진다. 이 체인은 주어진 메시지 목록을 받아, GPT 모델에 전달하고 응답을 생성하는 구조다.&lt;/p></description></item><item><title>RAG #1 랭체인, LCEL, 프롬프트</title><link>https://yshghid.github.io/docs/study/ai/ai1/</link><pubDate>Thu, 17 Jul 2025 00:00:00 +0000</pubDate><guid>https://yshghid.github.io/docs/study/ai/ai1/</guid><description>&lt;h1 id="rag-1-랭체인-lcel-프롬프트">
 RAG #1 랭체인, LCEL, 프롬프트
 &lt;a class="anchor" href="#rag-1-%eb%9e%ad%ec%b2%b4%ec%9d%b8-lcel-%ed%94%84%eb%a1%ac%ed%94%84%ed%8a%b8">#&lt;/a>
&lt;/h1>
&lt;p>#2025-07-17&lt;/p>
&lt;hr>
&lt;h3 id="1-랭체인-생태계의-주요-패키지">
 1. 랭체인 생태계의 주요 패키지
 &lt;a class="anchor" href="#1-%eb%9e%ad%ec%b2%b4%ec%9d%b8-%ec%83%9d%ed%83%9c%ea%b3%84%ec%9d%98-%ec%a3%bc%ec%9a%94-%ed%8c%a8%ed%82%a4%ec%a7%80">#&lt;/a>
&lt;/h3>
&lt;p>랭체인(LangChain)은 LLM(Large Language Model)을 활용한 애플리케이션을 쉽게 만들 수 있도록 돕는 프레임워크이다. 이 생태계는 단일 라이브러리로 구성된 것이 아니라 여러 개의 하위 패키지로 나뉘어 있고, 각각의 역할이 명확하게 분리되어 있다. 랭체인의 주요 목적은 LLM을 단순한 텍스트 생성 도구가 아니라, 여러 시스템과 결합하여 유의미한 작업을 수행하는 &amp;ldquo;생각하고 행동하는&amp;rdquo; 에이전트로 만드는 것이다. 이 생태계의 핵심 구성 요소들을 쉽게 설명하자면, 마치 LLM이라는 뇌에 주변 감각기관과 기억장치, 도구들, 그리고 의사결정 능력을 붙여주는 것이라고 보면 된다.&lt;/p></description></item></channel></rss>
<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Java #1 객체지향 프로그래밍: 캡슐화, 추상화, 다형성, 상속
  #

#2025-09-01


  목차
  #


캡슐화
추상화
다형성
상속
공통 특성: 인터페이스와 구현의 분리


  
  #


  1. 캡슐화
  #

#1 개념 및 목적

개념

객체지향 프로그래밍에서 객체의 속성(필드)을 외부로부터 숨기고, 공개된 메서드(getter/setter)를 통해서만 접근하도록 만드는 원칙
필드를 private으로 선언하고, 외부에서 직접 접근하지 못하게 제한하고,  public 메서드인 getter와 setter를 제공해 값을 읽거나 수정할 수 있도록 한다. setter 내부에는 유효성 검사 로직을 넣어 잘못된 값이 들어오는 것을 막을 수도 있다.


목적

데이터 보호: 잘못된 값이 직접 들어가는 것을 막고, setter 내부에서 규칙을 강제함으로써 객체의 상태를 안정적으로 유지
정보 은닉: 내부 구현이 어떻게 되어 있는지는 숨겨 두고, 외부에는 단순한 사용 방법만 제공함으로써 객체 사용자가 불필요한 복잡성을 신경 쓰지 않도록 한다.
유지보수와 확장성: 내부 로직이 바뀌더라도 외부 인터페이스(getter/setter)가 같으면 사용하는 코드는 수정할 필요가 없으므로 프로그램 전체의 안정성이 높아지고 유지보수가 쉬워진다.




  
  #

#2 샘플 코드"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://yshghid.github.io/docs/study/sw/sw28/"><meta property="og:site_name" content=" "><meta property="og:title" content="Java #1 객체지향 프로그래밍: 캡슐화, 추상화, 다형성, 상속"><meta property="og:description" content="Java #1 객체지향 프로그래밍: 캡슐화, 추상화, 다형성, 상속 # #2025-09-01
목차 # 캡슐화 추상화 다형성 상속 공통 특성: 인터페이스와 구현의 분리 # 1. 캡슐화 # #1 개념 및 목적
개념 객체지향 프로그래밍에서 객체의 속성(필드)을 외부로부터 숨기고, 공개된 메서드(getter/setter)를 통해서만 접근하도록 만드는 원칙 필드를 private으로 선언하고, 외부에서 직접 접근하지 못하게 제한하고, public 메서드인 getter와 setter를 제공해 값을 읽거나 수정할 수 있도록 한다. setter 내부에는 유효성 검사 로직을 넣어 잘못된 값이 들어오는 것을 막을 수도 있다. 목적 데이터 보호: 잘못된 값이 직접 들어가는 것을 막고, setter 내부에서 규칙을 강제함으로써 객체의 상태를 안정적으로 유지 정보 은닉: 내부 구현이 어떻게 되어 있는지는 숨겨 두고, 외부에는 단순한 사용 방법만 제공함으로써 객체 사용자가 불필요한 복잡성을 신경 쓰지 않도록 한다. 유지보수와 확장성: 내부 로직이 바뀌더라도 외부 인터페이스(getter/setter)가 같으면 사용하는 코드는 수정할 필요가 없으므로 프로그램 전체의 안정성이 높아지고 유지보수가 쉬워진다. # #2 샘플 코드"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2025-09-01T00:00:00+00:00"><meta property="article:modified_time" content="2025-09-01T00:00:00+00:00"><meta property="article:tag" content="2025-09"><title>Java #1 객체지향 프로그래밍: 캡슐화, 추상화, 다형성, 상속 |</title><link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://yshghid.github.io/docs/study/sw/sw28/><link rel=stylesheet href=/book.min.30a7836b6a89342da3b88e7afd1036166aeced16c8de12df060ded2031837886.css integrity="sha256-MKeDa2qJNC2juI56/RA2Fmrs7RbI3hLfBg3tIDGDeIY=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.3bf5a8eb84ece87d37908bffeec6793c8405f21704d444b434bf457a51c96f8b.js integrity="sha256-O/Wo64Ts6H03kIv/7sZ5PIQF8hcE1ES0NL9FelHJb4s=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/logo.png alt=Logo class=book-icon><span></span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><span>기록</span><ul><li><a href=/docs/hobby/book/>글</a><ul></ul></li><li><a href=/docs/hobby/daily/>일상</a><ul></ul></li></ul></li><li class=book-section-flat><span>공부</span><ul><li><a href=/docs/study/bioinformatics/>Bioinformatics</a><ul></ul></li><li><a href=/docs/study/ai/>AI</a><ul></ul></li><li><a href=/docs/study/sw/>SW</a><ul></ul></li><li><a href=/docs/study/algorithm/>알고리즘</a><ul></ul></li><li><a href=/docs/study/career/>취업</a><ul></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Java #1 객체지향 프로그래밍: 캡슐화, 추상화, 다형성, 상속</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#목차>목차</a></li><li></li><li><a href=#1-캡슐화>1. 캡슐화</a></li><li></li><li></li><li></li><li><a href=#2-추상화>2. 추상화</a></li><li></li><li></li><li></li><li><a href=#3-다형성>3. 다형성</a></li><li></li><li></li><li></li><li></li><li><a href=#4-상속>4. 상속</a></li><li></li><li></li><li></li><li><a href=#5-공통-특성-인터페이스와-구현의-분리>5. 공통 특성: 인터페이스와 구현의 분리</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=java-1-객체지향-프로그래밍-캡슐화-추상화-다형성-상속>Java #1 객체지향 프로그래밍: 캡슐화, 추상화, 다형성, 상속
<a class=anchor href=#java-1-%ea%b0%9d%ec%b2%b4%ec%a7%80%ed%96%a5-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d-%ec%ba%a1%ec%8a%90%ed%99%94-%ec%b6%94%ec%83%81%ed%99%94-%eb%8b%a4%ed%98%95%ec%84%b1-%ec%83%81%ec%86%8d>#</a></h1><p>#2025-09-01</p><hr><h3 id=목차>목차
<a class=anchor href=#%eb%aa%a9%ec%b0%a8>#</a></h3><ol><li>캡슐화</li><li>추상화</li><li>다형성</li><li>상속</li><li>공통 특성: 인터페이스와 구현의 분리</li></ol><h3><a class=anchor href=#>#</a></h3><h3 id=1-캡슐화>1. 캡슐화
<a class=anchor href=#1-%ec%ba%a1%ec%8a%90%ed%99%94>#</a></h3><p><mark>#1 개념 및 목적</mark></p><ul><li>개념<ul><li>객체지향 프로그래밍에서 객체의 속성(필드)을 외부로부터 숨기고, 공개된 메서드(getter/setter)를 통해서만 접근하도록 만드는 원칙</li><li>필드를 private으로 선언하고, 외부에서 직접 접근하지 못하게 제한하고, public 메서드인 getter와 setter를 제공해 값을 읽거나 수정할 수 있도록 한다. setter 내부에는 유효성 검사 로직을 넣어 잘못된 값이 들어오는 것을 막을 수도 있다.</li></ul></li><li>목적<ol><li>데이터 보호: 잘못된 값이 직접 들어가는 것을 막고, setter 내부에서 규칙을 강제함으로써 객체의 상태를 안정적으로 유지</li><li>정보 은닉: 내부 구현이 어떻게 되어 있는지는 숨겨 두고, 외부에는 단순한 사용 방법만 제공함으로써 객체 사용자가 불필요한 복잡성을 신경 쓰지 않도록 한다.</li><li>유지보수와 확장성: 내부 로직이 바뀌더라도 외부 인터페이스(getter/setter)가 같으면 사용하는 코드는 수정할 필요가 없으므로 프로그램 전체의 안정성이 높아지고 유지보수가 쉬워진다.</li></ol></li></ul><h3><a class=anchor href=#>#</a></h3><p><mark>#2 샘플 코드</mark></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Stock</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1. 필드는 외부에서 직접 접근 불가능 (private)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>double</span> price;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 생성자</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Stock</span>(String name, <span style=color:#66d9ef>double</span> price) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>        setPrice(price); <span style=color:#75715e>// setter 사용 → 유효성 검사 포함</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. Getter (읽기 전용)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> name;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>getPrice</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> price;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3. Setter (쓰기 전용, 유효성 검사 추가)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setPrice</span>(<span style=color:#66d9ef>double</span> price) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (price <span style=color:#f92672>&gt;</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>price</span> <span style=color:#f92672>=</span> price;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;❌ 잘못된 가격: &#34;</span> <span style=color:#f92672>+</span> price);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EncapsulationExample</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 정상적인 객체 생성</span>
</span></span><span style=display:flex><span>        Stock s1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Stock(<span style=color:#e6db74>&#34;스칼라 AI&#34;</span>, 17000);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(s1.<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 현재가: &#34;</span> <span style=color:#f92672>+</span> s1.<span style=color:#a6e22e>getPrice</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// setter를 통한 가격 변경 (올바른 값)</span>
</span></span><span style=display:flex><span>        s1.<span style=color:#a6e22e>setPrice</span>(18000);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;업데이트 후 가격: &#34;</span> <span style=color:#f92672>+</span> s1.<span style=color:#a6e22e>getPrice</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// setter를 통한 잘못된 값 입력 (음수)</span>
</span></span><span style=display:flex><span>        s1.<span style=color:#a6e22e>setPrice</span>(<span style=color:#f92672>-</span>5000); <span style=color:#75715e>// → 유효성 검사에서 거부</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;최종 가격: &#34;</span> <span style=color:#f92672>+</span> s1.<span style=color:#a6e22e>getPrice</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>class Stock</p><ul><li>private String name;<ul><li>주식의 이름(예: &ldquo;스칼라 AI&rdquo;)<ul><li>private이기 때문에 클래스 외부에서는 s1.name처럼 직접 접근 불가</li></ul></li></ul></li><li>private double price;<ul><li>주식의 가격을 저장하는 변수</li><li>private이기 때문에 클래스 외부에서는 직접 접근 불가</li></ul></li><li>public Stock<ul><li>this.name = name;<ul><li>생성 시 입력된 이름을 객체의 name 에 저장</li></ul></li><li>setPrice(price);<ul><li>가격은 바로 대입하지 않고 setPrice() 메서드를 통해 저장</li></ul></li></ul></li><li>Getter<ul><li>getName(): 주식 이름</li><li>getPrice(): 주식 가격</li></ul></li><li>Setter<ul><li>if (price > 0): 유효성 검사<ul><li>올바른 가격(0보다 큰 수)이면 저장, 잘못된 값이면 거부하고 메시지를 출력하기.</li></ul></li></ul></li></ul><p>public class EncapsulationExample</p><ul><li>public static void main(String[] args)<ul><li>Stock 객체를 실제로 만들어서 테스트하는 클래스.</li></ul></li><li>Stock s1 = new Stock(&ldquo;스칼라 AI&rdquo;, 17000);<ul><li>&ldquo;스칼라 AI"라는 이름과 17000이라는 가격으로 객체 생성.<ul><li>생성자 내부에서 setPrice(17000)이 호출되므로 유효성 검사가 통과되므로 저장된다.</li></ul></li></ul></li><li>System.out.println(s1.getName() + " 현재가: " + s1.getPrice());<ul><li>getName()과 getPrice()로 값을 출력</li></ul></li><li>s1.setPrice(18000);<ul><li>setter를 통한 가격 변경<ul><li>setPrice(18000)은 유효성 검사를 통과하므로 price가 18000으로 업데이트된다.</li></ul></li></ul></li><li>setPrice(-5000)<ul><li>setter 내부 조건문이 거부예정.<ul><li>&ldquo;잘못된 가격: -5000&rdquo; 메시지만 출력되고, price 값은 바뀌지 않고, getPrice()로 확인하면 여전히 이전 값 18000이 유지된다.</li></ul></li></ul></li></ul><h3><a class=anchor href=#>#</a></h3><p><mark>#4 의문점</mark></p><p>캡슐화의 의미?</p><ul><li>중요한 데이터는 직접 노출하지 않고 private으로 은닉하며, getter/setter 같은 메서드를 통해서만 접근하도록 만들기.</li></ul><p><code>this.price = price;</code> 하지않고 <code>setPrice(price)</code> 한 이유?</p><ul><li>이 값이 올바른지 아닌지 검사하는 로직을 넣기위해서.</li><li>생성자에서 this.price = price;를 바로 쓰면 잘못된 값도 그대로 들어와 버릴 수 있다. 예를 들어 new Stock(&ldquo;삼성&rdquo;, -1000) 같은 유효하지않은 객체가 생성될수있는데 setPrice(price);를 쓰면 생성되는 순간에 그 값이 유효한지 검사하고 잘못된 값은 차단할 수 있다.</li><li>결론<ul><li>생성자 안에서 직접 대입하지 않고 setter를 호출하면 내부 로직이 항상 같은 규칙을 따르게 함으로써 어디서 값을 넣든지 간에 일관성과 안전성이 유지된다.</li></ul></li></ul><h3><a class=anchor href=#>#</a></h3><h3 id=2-추상화>2. 추상화
<a class=anchor href=#2-%ec%b6%94%ec%83%81%ed%99%94>#</a></h3><p><mark>#1 개념 및 목적</mark></p><ul><li>개념<ul><li>객체지향 프로그래밍에서 복잡한 시스템을 단순화하기 위해 핵심적인 개념과 동작만 남기고 불필요한 세부사항을 감추는 원칙</li><li>추상 클래스와 인터페이스<ul><li>추상 클래스: 공통된 속성과 기본 동작을 정의하면서, 일부 메서드를 추상 메서드로 남겨 자식 클래스가 반드시 구현하도록 한다.</li><li>인터페이스: 특정 기능에 대한 규약을 정의하며, 이를 구현하는 클래스가 해당 메서드를 구체적으로 작성하도록 강제한다.</li></ul></li></ul></li><li>목적<ol><li>복잡성 단순화: 사용자나 개발자는 내부의 복잡한 구조를 알 필요 없이, 제공되는 메서드 시그니처만 보고 객체를 사용할 수 있다.</li><li>코드의 유연성과 유지보수성 향상: 외부에서 바라보는 표면(메서드 선언)만 일정하게 유지하면 내부 구현은 자유롭게 변경하거나 최적화할 수 있다.</li><li>일관성과 확장성 확보: 추상 클래스는 공통 뼈대를 재사용하게 해주고, 인터페이스는 다양한 클래스들이 동일한 규약을 따르도록 만들어 여러 객체를 일관된 방식으로 다룰 수 있게 한다. 이를 통해 협업과 테스트가 쉬워지고, 새로운 기능 확장이 용이해진다.</li></ol></li></ul><h3><a class=anchor href=#>#</a></h3><p><mark>#2 샘플 코드</mark></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 추상 클래스: 공통 자산</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Asset</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>double</span> price;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Asset</span>(String name, <span style=color:#66d9ef>double</span> price) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>price</span> <span style=color:#f92672>=</span> price;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 자식 클래스들이 반드시 구현해야 하는 추상 메서드</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>printInfo</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 인터페이스</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Valuable</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>printInfo</span>(); <span style=color:#75715e>// 반드시 구현해야 함</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// default 메서드 (인터페이스도 구현 제공 가능)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>default</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>updatePrice</span>(<span style=color:#66d9ef>double</span> price) {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;가격을 &#34;</span> <span style=color:#f92672>+</span> price <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;원으로 업데이트했습니다.&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 일반주 클래스: 추상 클래스 상속 + 인터페이스 구현</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Stock</span> <span style=color:#66d9ef>extends</span> Asset <span style=color:#66d9ef>implements</span> Valuable {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Stock</span>(String name, <span style=color:#66d9ef>double</span> price) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>(name, price);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>printInfo</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;[일반주] 종목: &#34;</span> <span style=color:#f92672>+</span> name <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; / 현재가: &#34;</span> <span style=color:#f92672>+</span> price <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;원&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 우선주 클래스: 추상 클래스 상속 + 인터페이스 구현</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PreferredStock</span> <span style=color:#66d9ef>extends</span> Asset <span style=color:#66d9ef>implements</span> Valuable {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>double</span> dividendRate;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>PreferredStock</span>(String name, <span style=color:#66d9ef>double</span> price, <span style=color:#66d9ef>double</span> dividendRate) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>(name, price);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>dividendRate</span> <span style=color:#f92672>=</span> dividendRate;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>printInfo</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;[우선주] 종목: &#34;</span> <span style=color:#f92672>+</span> name <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                           <span style=color:#e6db74>&#34; / 현재가: &#34;</span> <span style=color:#f92672>+</span> price <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;원&#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                           <span style=color:#e6db74>&#34; / 배당률: &#34;</span> <span style=color:#f92672>+</span> dividendRate <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;%&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 실행 클래스</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AbstractionExample</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 추상 클래스는 직접 인스턴스화 불가 → 자식 클래스를 통해 사용</span>
</span></span><span style=display:flex><span>        Asset samsung <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Stock(<span style=color:#e6db74>&#34;삼성전자&#34;</span>, 72000);
</span></span><span style=display:flex><span>        Asset lgPref <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> PreferredStock(<span style=color:#e6db74>&#34;LG전자우&#34;</span>, 83000, 4.<span style=color:#a6e22e>5</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 다형성: 같은 printInfo() 호출이지만 실제 객체에 따라 다르게 동작</span>
</span></span><span style=display:flex><span>        samsung.<span style=color:#a6e22e>printInfo</span>();
</span></span><span style=display:flex><span>        lgPref.<span style=color:#a6e22e>printInfo</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 인터페이스 default 메서드 사용</span>
</span></span><span style=display:flex><span>        Valuable v <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Stock(<span style=color:#e6db74>&#34;카카오&#34;</span>, 57000);
</span></span><span style=display:flex><span>        v.<span style=color:#a6e22e>updatePrice</span>(58000);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>추상 클래스 Asset</p><ul><li>abstract class Asset<ul><li>추상 클래스 정의</li></ul></li><li>protected String name, protected double price<ul><li>name, price 필드</li><li>protected 접근제어자 사용해서 같은 패키지 내부와 자식 클래스에서만 접근 가능하게한다.</li></ul></li><li>public Asset(String name, double price) {this.name = name; this.price = price;}<ul><li>name과 price를 초기화</li></ul></li><li>public abstract void printInfo();<ul><li>printInfo()는 추상 메서드로 선언되어 있고 구현은 없다.<ul><li>sset을 상속받는 자식 클래스들은 반드시 printInfo()를 구현해야한다 즉 Asset은 &ldquo;공통 자산"이라는 추상적인 개념만 정의하고 구체적인 세부 내용은 자식 클래스에서 맡기는 구조.</li></ul></li></ul></li></ul><p>인터페이스 Valuable</p><ul><li>interface Valuable<ul><li>객체가 가져야 할 행동 규약</li></ul></li><li>void printInfo();<ul><li>선언만 되어 있고 구현은 없음. 인터페이스를 구현하는 클래스는 반드시 이 메서드를 작성해야한다.</li></ul></li><li>default void updatePrice(double price) {System.out.println(&ldquo;가격을 " + price + &ldquo;원으로 업데이트했습니다.&rdquo;);}<ul><li>기본 구현: “가격을 업데이트했습니다”라는 메시지를 출력하기.</li></ul></li></ul><p>Stock 클래스</p><ul><li>class Stock extends Asset implements Valuable<ul><li>추상 클래스 Asset을 상속하고 인터페이스 Valuable을 구현한다.</li></ul></li><li>public Stock(String name, double price) {super(name, price);}<ul><li>생성자가 부모 클래스 Asset의 생성자를 호출해 name, price를 초기화한다.</li></ul></li><li>@Override public void printInfo()<ul><li>printInfo() 메서드를 오버라이딩하여 일반주 종목 정보를 출력.</li></ul></li></ul><p>PreferredStock 클래스</p><ul><li>PreferredStock extends Asset implements Valuable<ul><li><code>Asset</code>을 상속, <code>Valuable</code>을 구현.</li></ul></li><li>private double dividendRate;<ul><li>추가로 <code>dividendRate</code>(배당률)라는 필드를 가짐.</li></ul></li><li>public PreferredStock(String name, double price, double dividendRate) {super(name, price); this.dividendRate = dividendRate; }<ul><li>생성자를 통해 <code>name</code>, <code>price</code>, <code>dividendRate</code>를 초기화.</li></ul></li><li>@Override public void printInfo()<ul><li><code>printInfo()</code>를 오버라이딩하여 우선주의 정보(배당률 포함)를 출력하기.</li></ul></li></ul><h3><a class=anchor href=#>#</a></h3><p><mark>#3 의문점</mark></p><p>Asset, Valuable의 Stock으로의 흐름과 Asset, Valuable의 PreferredStock으로의 흐름?</p><ul><li>추상 클래스 Asset<ul><li>“모든 자산이라면 name과 price를 가져야 하며, 자신을 소개하는 방법인 printInfo() 메서드를 반드시 가져야 한다”라는 기본 골격을 생성하고 printInfo()를 선언만 해둔다.</li></ul></li><li>인터페이스 Valuable<ul><li>“가치 있는 자산이라면 반드시 printInfo()를 구현해야 한다”라는 규약을 정의하고, 추가로 updatePrice(double price)라는 기본 기능을 메뉴얼에 적어둔다.</li></ul></li><li>Stock 클래스<ol><li>Asset을 상속받아서 name과 price 필드를 물려받음</li><li>printInfo()를 구현하면서 “나는 일반주이고, 종목명은 name, 현재가는 price원이다”라는 구체적인 출력 내용을 정의</li><li>동시에 Valuable 인터페이스를 구현</li><li>규약을 확인해보니 printInfo()는 이미 Asset에서 추상 메서드로 선언되어 있었고, Stock이 그것을 구체적으로 작성했으므로 인터페이스 규약을 만족</li><li>Valuable 인터페이스를 구현했으므로 printInfo()와 updatePrice(double price) 메서드를 사용할 수 있음</li><li>결국 Asset에서 내려온 골격(name, price, printInfo())과 Valuable에서 정한 규칙 및 기능(printInfo(), updatePrice(double price))이 Stock 클래스 안에서 결합됨</li></ol></li><li>PreferredStock 클래스<ol><li>Asset을 상속받아 기본 필드인 name과 price를 물려받고, printInfo를 구현</li><li>일반주와는 다르게 배당률이라는 고유한 특징이 있으므로 새로운 필드 dividendRate를 추가.</li><li>printInfo에서는 이름, 가격과 함께 배당률도 출력.</li></ol></li><li>결론<ul><li>Asset이 제공하는 공통 골격(name, price, printInfo())과 Valuable이 정한 규약(printInfo()) 및 기능(updatePrice(double price))이 Stock과 PreferredStock에 각각 결합되어 Stock은 일반주로서 name과 price를 출력하고 PreferredStock은 여기에 dividendRate를 더해 고유 특성을 반영한다.</li></ul></li></ul><h3><a class=anchor href=#>#</a></h3><h3 id=3-다형성>3. 다형성
<a class=anchor href=#3-%eb%8b%a4%ed%98%95%ec%84%b1>#</a></h3><p><mark>#1 개념 및 목적</mark></p><ul><li>개념<ul><li>객체지향 프로그래밍에서 하나의 타입으로 여러 형태의 동작을 표현 즉 같은 이름의 메서드를 호출하더라도 객체의 실제 타입에 따라 실행되는 동작이 달라지는 특성</li><li>이를 가능하게 하는 조건은 상속과 메서드 오버라이딩으로 구현되고 보통 업캐스팅과 함께 활용된다.<ul><li>부모 클래스 타입의 참조 변수를 통해 메서드를 호출하면, 실행 시점에는 실제 객체 타입에 맞는 오버라이딩된 메서드가 실행된다.</li></ul></li></ul></li><li>목적<ul><li>코드의 유연성 확보: 하나의 부모 타입으로 여러 자식 객체를 다룰 수 있기 때문에, 코드 구조를 단순하게 유지하면서 다양한 객체를 일관된 방식으로 처리할 수 있어서 새로운 자식 클래스가 추가되더라도 기존 코드를 거의 수정하지 않고 확장이 가능하다.</li></ul></li></ul><h3><a class=anchor href=#>#</a></h3><p><mark>#2 샘플 코드</mark></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 부모 클래스</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Stock</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>double</span> price;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Stock</span>(String name, <span style=color:#66d9ef>double</span> price) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>price</span> <span style=color:#f92672>=</span> price;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 부모 메서드</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>printInfo</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;[일반주] 종목: &#34;</span> <span style=color:#f92672>+</span> name <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;, 가격: &#34;</span> <span style=color:#f92672>+</span> price <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;원&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 자식 클래스</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PreferredStock</span> <span style=color:#66d9ef>extends</span> Stock {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> dividendRate;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>PreferredStock</span>(String name, <span style=color:#66d9ef>double</span> price, <span style=color:#66d9ef>double</span> dividendRate) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>(name, price);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>dividendRate</span> <span style=color:#f92672>=</span> dividendRate;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 부모 메서드를 오버라이딩</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>printInfo</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;[우선주] 종목: &#34;</span> <span style=color:#f92672>+</span> name <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;, 가격: &#34;</span> <span style=color:#f92672>+</span> price <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;원, 배당률: &#34;</span> <span style=color:#f92672>+</span> dividendRate <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;%&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 자식 클래스만 가진 메서드</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>showDividend</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;배당률은 &#34;</span> <span style=color:#f92672>+</span> dividendRate <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;% 입니다.&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 실행 클래스</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PolymorphismExample</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 업캐스팅 (자식 → 부모 타입)</span>
</span></span><span style=display:flex><span>        Stock stock <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> PreferredStock(<span style=color:#e6db74>&#34;스칼라 AI&#34;</span>, 17500, 5.<span style=color:#a6e22e>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 부모 타입으로 참조했지만, 실제 실행은 자식 클래스의 메서드가 호출됨</span>
</span></span><span style=display:flex><span>        stock.<span style=color:#a6e22e>printInfo</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 다운캐스팅 (부모 타입 → 자식 타입)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (stock <span style=color:#66d9ef>instanceof</span> PreferredStock) {
</span></span><span style=display:flex><span>            PreferredStock ps <span style=color:#f92672>=</span> (PreferredStock) stock;
</span></span><span style=display:flex><span>            ps.<span style=color:#a6e22e>showDividend</span>(); <span style=color:#75715e>// 자식 클래스 고유 메서드 사용 가능</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Stock</p><ul><li>class Stock<ul><li>주식 개념 부모 클래스</li></ul></li><li>protected String name; protected double price;<ul><li>주식의 이름과 가격을 저장하는 필드(멤버 변수)</li><li>protected<ul><li>같은 패키지 내부나 상속받은 자식 클래스에서 접근 가능하다. 외부에서는 직접 접근 불가하다.</li></ul></li></ul></li><li><code>public Stock(String name, double price)</code><ul><li>생성자(Constructor)</li><li><code>name</code>과 <code>price</code>를 받아 초기화</li></ul></li><li><code>public void printInfo()</code><ul><li>주식 정보를 출력</li><li>System.out.println("[일반주] 종목: " + name + &ldquo;, 가격: " + price + &ldquo;원&rdquo;);<ul><li>“일반주”라고 표시하고 종목명과 가격을 보여준다</li></ul></li><li>자식 클래스에서 오버라이딩 대상인 메서드</li></ul></li></ul><p>PreferredStock</p><ul><li>class PreferredStock extends Stock<ul><li>Stock을 상속받은 자식 클래스.</li><li>상속을 통해 name과 price를 물려받았는데 배당률(dividendRate)이라는 속성을 추가하여 “우선주”를 구체화함.</li><li>super(name, price);<ul><li>부모 클래스의 생성자를 호출</li></ul></li><li>@Override public void printInfo()<ul><li>부모 클래스 printInfo()를 오버라이딩</li><li>실행 시점에는 동적 바인딩에 의해, 객체의 실제 타입이 PreferredStock이면 이 메서드가 실행된다.</li></ul></li></ul></li><li>public void showDividend()<ul><li>자식 클래스에만 있는 메서드. 배당률을 따로 출력하는 기능.</li><li>부모 타입 변수로는 접근할 수 없고, 자식 타입으로 다운캐스팅해야 호출할 수 있다.</li></ul></li></ul><h3><a class=anchor href=#>#</a></h3><p><mark>#3 의문점</mark></p><p>“@Override public void printInfo()를 오버라이딩하면 실행 시점에 객체의 실제 타입에 맞는 메서드가 호출된다”의 의미?</p><ul><li>@Override public void printInfo()를 오버라이딩?<ul><li>부모 Stock에는 printInfo()가 있는데 자식 PreferredStock이 똑같은 메서드 시그니처(메서드 이름, 매개변수 목록, 반환형이 동일)로 다시 정의하면 그게 오버라이딩.</li></ul></li><li>printInfo() 실행 시점에 객체의 실제 타입에 맞는 메서드가 호출된다?<ul><li>printInfo()같은 인스턴스 메서드는 2단계로 처리되는데<ol><li>메서드 호출<ul><li>컴파일러는? 변수의 선언 타입을 보고 “이 메서드를 불러도 되는지” 확인한다.</li><li>Stock s = new PreferredStock(&mldr;) 일때 s.printInfo(); 하면 s가 Stock 타입이니까, Stock 클래스에 printInfo()가 있는지만 확인한다.</li></ul></li><li>실제 구현<ul><li>JVM은? 실제 객체가 누구인지 확인하는데</li><li>지금 s가 참조하는 건 Stock이 아니라 PreferredStock 객체니까 “PreferredStock에 printInfo()가 오버라이딩돼 있네? 그럼 이걸 실행해야겠다.” 하고 결정한다.</li></ul></li></ol></li></ul></li><li>결론<ul><li>printInfo() 호출하면 컴파일러는 변수선언을 보고 s가 Stock 타입이고 Stock 안에 printInfo() 있으니까 호출 승인하고, 어떤 버전의 printInfo()가 실행될지는 아직 정해지지 않았고, JVM이 객체를 확인했을때 Stock객체라면 부모 클래스 버전 <code>printInfo</code>()이 실행, PreferredStock이라면 그 클래스에서 정의된<code>printInfo</code>()를 실행한다.</li></ul></li></ul><h3><a class=anchor href=#>#</a></h3><p>동적 바인딩?</p><ul><li>실행할 때 객체의 실제 타입을 보고 그에 맞는 메서드를 선택하는게 동적 바인딩. (s라는 변수가 Stock 타입으로 선언되어 있어도, new PreferredStock(&mldr;)로 만든 객체를 가리키고 있다면 자식 쪽에 오버라이딩된 메서드가 실행됨)</li></ul><h3><a class=anchor href=#>#</a></h3><h3 id=4-상속>4. 상속
<a class=anchor href=#4-%ec%83%81%ec%86%8d>#</a></h3><p><mark>1. 개념 및 목적</mark></p><ul><li>개념<ul><li>기존(부모) 클래스가 가진 속성과 메서드를 새로운(자식) 클래스가 계승하여 활용할 수 있도록 하는 개념</li><li>자식 클래스는 부모 클래스가 정의한 필드와 메서드를 직접 사용할 수 있다.<ul><li>필요에 따라 새로운 속성과 기능을 추가하거나, 부모 메서드를 오버라이딩(Overriding)하여 구체적인 동작을 재정의할 수 있고</li><li>이를 통해 자식 클래스는 부모 클래스가 제공하는 공통 기능을 기반으로 기본 구조와 일관성을 유지하면서도, 고유한 특성과 요구 사항을 반영하여 더욱 구체적이고 특화된 클래스로 확장될 수 있다.</li></ul></li></ul></li><li>목적<ol><li>코드 재사용성: 부모 클래스에 정의된 공통 속성과 기능을 여러 자식 클래스에서 공유할 수 있어, 중복 코드를 줄이고 전체 코드 구조를 간결하게 만든다.</li><li>유지보수성과 확장성: 공통 로직은 부모 클래스에만 수정하면 되고, 자식 클래스는 필요에 따라 기능을 덧붙이거나 오버라이딩을 통해 동작을 변경할 수 있어 유지보수가 쉽고 새로운 기능 추가도 용이하다.</li><li>다형성 기반 마련: 부모 타입으로 자식 객체를 다룰 수 있고, 실행 시점에는 실제 객체의 타입에 맞는 동작이 수행되므로 유연한 구조를 만들 수 있다.</li></ol></li></ul><h3><a class=anchor href=#>#</a></h3><p><mark>2. 샘플 코드</mark></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 부모 클래스</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Stock</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> String name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>double</span> price;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Stock</span>(String name, <span style=color:#66d9ef>double</span> price) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>price</span> <span style=color:#f92672>=</span> price;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 부모 메서드</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>printInfo</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;[일반주] 종목: &#34;</span> <span style=color:#f92672>+</span> name <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;, 가격: &#34;</span> <span style=color:#f92672>+</span> price <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;원&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 자식 클래스</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PreferredStock</span> <span style=color:#66d9ef>extends</span> Stock {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> dividendRate;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>PreferredStock</span>(String name, <span style=color:#66d9ef>double</span> price, <span style=color:#66d9ef>double</span> dividendRate) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>(name, price);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>dividendRate</span> <span style=color:#f92672>=</span> dividendRate;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 부모 메서드를 오버라이딩</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>printInfo</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;[우선주] 종목: &#34;</span> <span style=color:#f92672>+</span> name <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;, 가격: &#34;</span> <span style=color:#f92672>+</span> price <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;원, 배당률: &#34;</span> <span style=color:#f92672>+</span> dividendRate <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;%&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 자식 클래스만 가진 메서드</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>showDividend</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;배당률은 &#34;</span> <span style=color:#f92672>+</span> dividendRate <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;% 입니다.&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 실행 클래스</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PolymorphismExample</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 업캐스팅 (자식 → 부모 타입)</span>
</span></span><span style=display:flex><span>        Stock stock <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> PreferredStock(<span style=color:#e6db74>&#34;스칼라 AI&#34;</span>, 17500, 5.<span style=color:#a6e22e>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 부모 타입으로 참조했지만, 실제 실행은 자식 클래스의 메서드가 호출됨</span>
</span></span><span style=display:flex><span>        stock.<span style=color:#a6e22e>printInfo</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 다운캐스팅 (부모 타입 → 자식 타입)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (stock <span style=color:#66d9ef>instanceof</span> PreferredStock) {
</span></span><span style=display:flex><span>            PreferredStock ps <span style=color:#f92672>=</span> (PreferredStock) stock;
</span></span><span style=display:flex><span>            ps.<span style=color:#a6e22e>showDividend</span>(); <span style=color:#75715e>// 자식 클래스 고유 메서드 사용 가능</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>부모 클래스 Stock</p><ul><li>class Stock<ul><li>주식 개념 부모 클래스</li></ul></li><li>protected String name; protected double price;<ul><li>주식의 이름과 가격을 저장하는 필드(멤버 변수)</li><li>protected<ul><li>같은 패키지 내부나 상속받은 자식 클래스에서 접근 가능하다. 외부에서는 직접 접근 불가하다.</li></ul></li></ul></li><li><code>public Stock(String name, double price)</code><ul><li>생성자(Constructor)</li><li><code>name</code>과 <code>price</code>를 받아 초기화</li></ul></li><li><code>public void printInfo()</code><ul><li>주식 정보를 출력</li><li>System.out.println("[일반주] 종목: " + name + &ldquo;, 가격: " + price + &ldquo;원&rdquo;);<ul><li>“일반주”라고 표시하고 종목명과 가격을 보여준다</li></ul></li><li>자식 클래스에서 오버라이딩 대상인 메서드</li></ul></li></ul><p>자식 클래스 PreferredStock</p><ul><li>class PreferredStock extends Stock<ul><li>Stock을 상속받은 자식 클래스.</li><li>상속을 통해 name과 price를 물려받았는데 배당률(dividendRate)이라는 속성을 추가하여 “우선주”를 구체화함.</li><li>super(name, price);<ul><li>부모 클래스의 생성자를 호출</li></ul></li><li>@Override public void printInfo()<ul><li>부모 클래스 printInfo()를 오버라이딩</li><li>실행 시점에는 동적 바인딩에 의해, 객체의 실제 타입이 PreferredStock이면 이 메서드가 실행된다.</li></ul></li></ul></li><li>public void showDividend()<ul><li>자식 클래스에만 있는 메서드. 배당률을 따로 출력하는 기능.</li><li>부모 타입 변수로는 접근할 수 없고, 자식 타입으로 다운캐스팅해야 호출할 수 있다.</li></ul></li></ul><h3><a class=anchor href=#>#</a></h3><p><mark>#3 의문점</mark></p><p>그래서 업캐스팅과 다운캐스팅이 어떻게적용되는가?</p><ul><li>업캐스팅<ul><li>자식 객체를 부모 타입 변수에 담는것</li><li>PreferredStock이 Stock을 상속받는 상황에서 Stock stock = new PreferredStock(&mldr;);처럼 쓰면 실제 객체는 PreferredStock이지만 참조 변수의 타입을 Stock으로 지정했기 때문에 컴파일러는 이 객체를 부모 클래스 객체 형식으로 인지한다.</li><li>실행 시점에 stock.printInfo()를 호출하면 실제 객체가 PreferredStock이므로 자식이 오버라이딩한 메서드가 실행된다. 핵심은 부모객체처럼 인지되면서도 실제동작은 자식클래스의 성질이 반영된다.</li></ul></li><li>업캐스팅 하는이유?<ul><li>여러 종류의 자식 클래스를 일괄적으로 묶어서 처리할수있기때문에 코드가 단순해진다.</li></ul></li><li>다운캐스팅<ul><li>부모 타입 변수에 들어 있는 객체를 다시 자식 타입 변수로 변환하는것.</li><li>Stock stock이라는 부모 타입 참조가 있지만, 실제 객체가 PreferredStock이라면 (PreferredStock) stock으로 형변환을 거치면 자식 타입 변수로 다룰수있다 즉 자식만이 가진 고유한 메서드 showDividend() 를 호출할수있다.</li></ul></li><li>결론<ul><li>상속 구조에서는 같은 객체를 필요에 따라 업캐스팅 ↔ 다운캐스팅으로 부모 클래스 ↔ 자식 클래스로 바꿔 다루면서 공통성과 특수성을 효율적으로 반영할수있다.</li></ul></li></ul><h3><a class=anchor href=#>#</a></h3><h3 id=5-공통-특성-인터페이스와-구현의-분리>5. 공통 특성: 인터페이스와 구현의 분리
<a class=anchor href=#5-%ea%b3%b5%ed%86%b5-%ed%8a%b9%ec%84%b1-%ec%9d%b8%ed%84%b0%ed%8e%98%ec%9d%b4%ec%8a%a4%ec%99%80-%ea%b5%ac%ed%98%84%ec%9d%98-%eb%b6%84%eb%a6%ac>#</a></h3><ul><li>캡슐화, 추상화, 다형성, 상속은 결국 인터페이스와 구현이 분리되는걸 활용하는게 포인트인것같은데 인터페이스와 구현의 분리가 각각 어떻게 활용되었는가?<ul><li>캡슐화 - 데이터(구현)를 숨기고 메서드(인터페이스)만 공개</li><li>추상화 - “무엇을 할 수 있는가”(인터페이스)와 “어떻게 할 것인가”(구현)를 분리</li><li>다형성 - 부모의 틀(인터페이스)은 유지하면서, 자식에서 구체 구현을 다양하게 정의</li><li>상속 - 호출하는 쪽은 부모 타입(인터페이스)만 보고, 실행되는 쪽은 실제 객체의 구현을 따른다.</li></ul></li></ul><h1><a class=anchor href=#>#</a></h1></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=yshghid/yshghid.github.io data-repo-id=R_kgDONkMkNg data-category-id=DIC_kwDONkMkNs4CloJh data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#목차>목차</a></li><li></li><li><a href=#1-캡슐화>1. 캡슐화</a></li><li></li><li></li><li></li><li><a href=#2-추상화>2. 추상화</a></li><li></li><li></li><li></li><li><a href=#3-다형성>3. 다형성</a></li><li></li><li></li><li></li><li></li><li><a href=#4-상속>4. 상속</a></li><li></li><li></li><li></li><li><a href=#5-공통-특성-인터페이스와-구현의-분리>5. 공통 특성: 인터페이스와 구현의 분리</a></li></ul></li></ul></nav></div></aside></main></body></html>
<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  DBMS 및 SQL 활용 #3 집계함수, 고급 객체기능, 고급 인덱스
  #

#2025-08-28


  1. GROUPBY
  #

GROUP BY


테이블 안에 있는 데이터를 특정 기준으로 묶어서 요약.


테이블 embedding_store에서


id, user_id, cluster_id, similarity, tag 5개 컬럼이 있는데

있는 그대로보면 큰 그림을 보기 힘들다 즉 해석이 어렵다.
GROUP BY를 쓰면 요약 정보를 만들수있는데

user_id로 묶으면 “사용자 A는 총 10건, 사용자 B는 총 5건” 같은 식으로 정리 / cluster_id로 묶으면 “클러스터 1은 평균 유사도가 0.8, 클러스터 2는 0.5” / tag로 묶으면 “계약 태그는 100건, 고객상담 태그는 30건” 같은 결과가 나오고 이렇게 하면 데이터의 전체 분포와 패턴을 이해할 수 있다.







AI 연계?"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://yshghid.github.io/docs/study/sw/sw26/"><meta property="og:site_name" content=" "><meta property="og:title" content="DBMS 및 SQL 활용 #3 집계함수, 고급 객체기능, 고급 인덱스"><meta property="og:description" content="DBMS 및 SQL 활용 #3 집계함수, 고급 객체기능, 고급 인덱스 # #2025-08-28
1. GROUPBY # GROUP BY
테이블 안에 있는 데이터를 특정 기준으로 묶어서 요약.
테이블 embedding_store에서
id, user_id, cluster_id, similarity, tag 5개 컬럼이 있는데 있는 그대로보면 큰 그림을 보기 힘들다 즉 해석이 어렵다. GROUP BY를 쓰면 요약 정보를 만들수있는데 user_id로 묶으면 “사용자 A는 총 10건, 사용자 B는 총 5건” 같은 식으로 정리 / cluster_id로 묶으면 “클러스터 1은 평균 유사도가 0.8, 클러스터 2는 0.5” / tag로 묶으면 “계약 태그는 100건, 고객상담 태그는 30건” 같은 결과가 나오고 이렇게 하면 데이터의 전체 분포와 패턴을 이해할 수 있다. AI 연계?"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2025-08-28T00:00:00+00:00"><meta property="article:modified_time" content="2025-08-28T00:00:00+00:00"><meta property="article:tag" content="2025-08"><title>DBMS 및 SQL 활용 #3 집계함수, 고급 객체기능, 고급 인덱스 |</title><link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://yshghid.github.io/docs/study/sw/sw26/><link rel=stylesheet href=/book.min.30a7836b6a89342da3b88e7afd1036166aeced16c8de12df060ded2031837886.css integrity="sha256-MKeDa2qJNC2juI56/RA2Fmrs7RbI3hLfBg3tIDGDeIY=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.02995aeb325e985e375e0aaf6f4517fae0912888cc7a25f8cdf1b60ed573f20b.js integrity="sha256-Apla6zJemF43Xgqvb0UX+uCRKIjMeiX4zfG2DtVz8gs=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/logo.png alt=Logo class=book-icon><span></span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><span>기록</span><ul><li><a href=/docs/hobby/book/>글</a><ul></ul></li><li><a href=/docs/hobby/daily/>일상</a><ul></ul></li></ul></li><li class=book-section-flat><span>공부</span><ul><li><a href=/docs/study/bioinformatics/>Bioinformatics</a><ul></ul></li><li><a href=/docs/study/ai/>AI</a><ul></ul></li><li><a href=/docs/study/sw/>SW</a><ul></ul></li><li><a href=/docs/study/career/>취업</a><ul></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>DBMS 및 SQL 활용 #3 집계함수, 고급 객체기능, 고급 인덱스</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#1-groupby>1. GROUPBY</a></li><li></li><li></li><li></li><li></li><li></li><li><a href=#2-rollup--cube>2. ROLLUP & CUBE</a></li><li></li><li></li><li></li><li></li><li><a href=#3-udf--시퀀스--저장-프로시저--udt--트리거>3. UDF & 시퀀스 & 저장 프로시저 & UDT & 트리거</a></li><li></li><li></li><li></li><li></li><li></li><li><a href=#4-윈도우-함수>4. 윈도우 함수</a></li><li></li><li></li><li></li><li><a href=#5-고급-인덱스>5. 고급 인덱스</a></li><li></li><li></li><li></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=dbms-및-sql-활용-3-집계함수-고급-객체기능-고급-인덱스>DBMS 및 SQL 활용 #3 집계함수, 고급 객체기능, 고급 인덱스
<a class=anchor href=#dbms-%eb%b0%8f-sql-%ed%99%9c%ec%9a%a9-3-%ec%a7%91%ea%b3%84%ed%95%a8%ec%88%98-%ea%b3%a0%ea%b8%89-%ea%b0%9d%ec%b2%b4%ea%b8%b0%eb%8a%a5-%ea%b3%a0%ea%b8%89-%ec%9d%b8%eb%8d%b1%ec%8a%a4>#</a></h1><p>#2025-08-28</p><hr><h3 id=1-groupby>1. GROUPBY
<a class=anchor href=#1-groupby>#</a></h3><p>GROUP BY</p><ul><li><p>테이블 안에 있는 데이터를 특정 기준으로 묶어서 요약.</p></li><li><p>테이블 embedding_store에서</p><img width=704 height=470 alt=image src=https://github.com/user-attachments/assets/e666bec3-43d2-4c64-8268-64168dd409c9><ul><li>id, user_id, cluster_id, similarity, tag 5개 컬럼이 있는데<ul><li>있는 그대로보면 큰 그림을 보기 힘들다 즉 해석이 어렵다.</li><li>GROUP BY를 쓰면 요약 정보를 만들수있는데<ul><li>user_id로 묶으면 “사용자 A는 총 10건, 사용자 B는 총 5건” 같은 식으로 정리 / cluster_id로 묶으면 “클러스터 1은 평균 유사도가 0.8, 클러스터 2는 0.5” / tag로 묶으면 “계약 태그는 100건, 고객상담 태그는 30건” 같은 결과가 나오고 이렇게 하면 데이터의 전체 분포와 패턴을 이해할 수 있다.</li></ul></li></ul></li></ul></li></ul><p>AI 연계?</p><ul><li><p>벡터 데이터에서 클러스터링을 하고 나면 각 클러스터의 특징을 봐야되는데</p><img width=700 height=482 alt=image src=https://github.com/user-attachments/assets/16fe0341-f273-4762-83f1-6e30da76827a><ul><li>SQL로 GROUP BY cluster_id를 해서 평균 유사도, 최소 유사도 등을 구해서 평균 유사도가 지나치게 낮은 클러스터가 발견되면 “이 클러스터는 불분명하게 묶였네” 이런식으로 클러스터를 판단할수있다</li><li>SQL로 GROUP BY tag 해서 클러스터내 사용자별 태그 분포를 보면 어떤 사용자가 어떤 패턴을 많이 보이는지를 확인할수있다.</li></ul></li><li><p>이런식으로 단순 SQL 집계가 단순 통계가 아니라 이상치 탐색, 품질 저하 감지, 태그 자동 분류 같은 AI 전처리 과정에 활용 가능.</p></li></ul><h3><a class=anchor href=#>#</a></h3><p>Vector DB 분석에서 GROUP BY 활용</p><ul><li>벡터 데이터는?<ul><li>문장, 이미지 같은 걸 임베딩해서 저장해둔 값</li></ul></li><li>클러스터링을 하고 나면 각 클러스터가 잘 묶였는지를 확인해야 하고 이때 GROUP BY cluster_id로 묶어서 평균 유사도를 보면 클러스터를 판단할수있다</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- 클러스터별 평균 유사도와 최소 유사도
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> cluster_id,
</span></span><span style=display:flex><span>       ROUND(<span style=color:#66d9ef>AVG</span>(similarity), <span style=color:#ae81ff>3</span>) <span style=color:#66d9ef>AS</span> avg_sim,
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>MIN</span>(similarity) <span style=color:#66d9ef>AS</span> min_sim
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> embedding_store
</span></span><span style=display:flex><span><span style=color:#66d9ef>GROUP</span> <span style=color:#66d9ef>BY</span> cluster_id;
</span></span></code></pre></div><ul><li>여기서 평균 유사도가 0.9 이상이면 잘 뭉쳐진 클러스터일 가능성이 크고 0.5 이하라면 내부 데이터가 제각각이라 불분명하게 묶인 클러스터라고 판단가능</li><li>이렇게 SQL 집계로 클러스터 품질을 확인할수있다.</li></ul><h3><a class=anchor href=#>#</a></h3><p>AI 결과 검증에서 GROUP BY 활용</p><ul><li>AI 모델이 분류 작업을 했을때<ul><li>실제 라벨(true_label)과 예측 결과(pred_label)가 테이블에 있고 카테고리별 정확도를 구할 수 있다</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- 카테고리별 정확도 집계
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> true_label,
</span></span><span style=display:flex><span>       ROUND(<span style=color:#66d9ef>SUM</span>(<span style=color:#66d9ef>CASE</span> <span style=color:#66d9ef>WHEN</span> true_label <span style=color:#f92672>=</span> pred_label <span style=color:#66d9ef>THEN</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>ELSE</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>END</span>)::decimal
</span></span><span style=display:flex><span>             <span style=color:#f92672>/</span> <span style=color:#66d9ef>COUNT</span>(<span style=color:#f92672>*</span>), <span style=color:#ae81ff>3</span>) <span style=color:#66d9ef>AS</span> accuracy
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> prediction_results
</span></span><span style=display:flex><span><span style=color:#66d9ef>GROUP</span> <span style=color:#66d9ef>BY</span> true_label;
</span></span></code></pre></div><ul><li>이렇게 하면 “카테고리 A의 정확도는 0.95, 카테고리 B는 0.62” 같은 결과가 나오니까 어떤 클래스에서 모델이 잘 못 맞추는지 바로 확인할 수 있고 이는 모델 개선 포인트로 이어진다.</li></ul><h3><a class=anchor href=#>#</a></h3><p>추천 시스템에서 GROUP BY 활용</p><ul><li>추천 시스템에서는 사용자가 어떤 아이템을 자주 고르는지, 또는 어떤 유형의 아이템을 선호하는지를 분석해야 하는데<ul><li>사용자별 선택 기록을 GROUP BY user_id나 GROUP BY item_category로 묶으면 개인의 선호를 확인 가능하다</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- 사용자별 아이템 선택 패턴
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> user_id, item_category, <span style=color:#66d9ef>COUNT</span>(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>AS</span> choice_count
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> user_choice_log
</span></span><span style=display:flex><span><span style=color:#66d9ef>GROUP</span> <span style=color:#66d9ef>BY</span> user_id, item_category
</span></span><span style=display:flex><span><span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> user_id, choice_count <span style=color:#66d9ef>DESC</span>;
</span></span></code></pre></div><ul><li>이렇게 하면 “사용자 A는 주로 액션 영화를 많이 선택, 사용자 B는 로맨스 위주” 같은 패턴이 보이고 이를 활용해서 토대로 개인화 추천을 강화할 수 있다.</li></ul><h3><a class=anchor href=#>#</a></h3><p>분류 성능 비교에서 GROUP BY 활용</p><ul><li>분류 모델이 여러 개 있다면 카테고리별로 각 모델의 성능을 나란히 비교할수있다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- 모델별, 카테고리별 정확도 비교
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> model_name, true_label,
</span></span><span style=display:flex><span>       ROUND(<span style=color:#66d9ef>SUM</span>(<span style=color:#66d9ef>CASE</span> <span style=color:#66d9ef>WHEN</span> true_label <span style=color:#f92672>=</span> pred_label <span style=color:#66d9ef>THEN</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>ELSE</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>END</span>)::decimal
</span></span><span style=display:flex><span>             <span style=color:#f92672>/</span> <span style=color:#66d9ef>COUNT</span>(<span style=color:#f92672>*</span>), <span style=color:#ae81ff>3</span>) <span style=color:#66d9ef>AS</span> accuracy
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> prediction_results
</span></span><span style=display:flex><span><span style=color:#66d9ef>GROUP</span> <span style=color:#66d9ef>BY</span> model_name, true_label;
</span></span></code></pre></div><ul><li>이렇게 하면 “모델 A는 카테고리 X에서는 정확도가 높지만, 카테고리 Y에서는 낮다” 같은 판단(비교) 가능.</li></ul><h3><a class=anchor href=#>#</a></h3><h3 id=2-rollup--cube>2. ROLLUP & CUBE
<a class=anchor href=#2-rollup--cube>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>-- 원본데이터
</span></span><span style=display:flex><span>region | product | amount
</span></span><span style=display:flex><span>-------+---------+-------
</span></span><span style=display:flex><span>East   | A       | 100
</span></span><span style=display:flex><span>East   | B       | 150
</span></span><span style=display:flex><span>West   | A       | 200
</span></span><span style=display:flex><span>West   | B       |  50
</span></span></code></pre></div><p>sales_summary 테이블</p><ul><li>지역(region), 제품(product), 매출액(amount)</li><li>East 지역의 A 제품 매출 100, B 제품 매출 150 / West 지역의 A 제품 200, B 제품 50</li><li>일반적인 GROUP BY region, product를 쓰면?</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- 기본 GROUP BY
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> region, product, <span style=color:#66d9ef>SUM</span>(amount) <span style=color:#66d9ef>AS</span> total
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> sales_summary
</span></span><span style=display:flex><span><span style=color:#66d9ef>GROUP</span> <span style=color:#66d9ef>BY</span> region, product;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>region | product | total
</span></span><span style=display:flex><span>-------+---------+------
</span></span><span style=display:flex><span>East   | A       | 100
</span></span><span style=display:flex><span>East   | B       | 150
</span></span><span style=display:flex><span>West   | A       | 200
</span></span><span style=display:flex><span>West   | B       |  50
</span></span></code></pre></div><ul><li>SUM()으로 합계를 계산했고 그대로 네 줄이 다시 나오면서 매출액이 합계로 정리된다<ul><li>그런데 이렇게 하면 지역별 합계나 전체 합계를 따로 보려면 다시 쿼리를 작성해야함.</li></ul></li></ul><h3><a class=anchor href=#>#</a></h3><ul><li>GROUP BY ROLLUP(region, product)를 쓰면?</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- GROUP BY ROLLUP
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> region, product, <span style=color:#66d9ef>SUM</span>(amount) <span style=color:#66d9ef>AS</span> total
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> sales_summary
</span></span><span style=display:flex><span><span style=color:#66d9ef>GROUP</span> <span style=color:#66d9ef>BY</span> <span style=color:#66d9ef>ROLLUP</span>(region, product);
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>region | product | total
</span></span><span style=display:flex><span>-------+---------+------
</span></span><span style=display:flex><span>East   | A       | 100
</span></span><span style=display:flex><span>East   | B       | 150
</span></span><span style=display:flex><span>East   | NULL    | 250   &lt;- East 소계
</span></span><span style=display:flex><span>West   | A       | 200
</span></span><span style=display:flex><span>West   | B       |  50
</span></span><span style=display:flex><span>West   | NULL    | 250   &lt;- West 소계
</span></span><span style=display:flex><span>NULL   | NULL    | 500   &lt;- 전체 합계
</span></span></code></pre></div><ul><li>네 줄의 상세 데이터에 더해서 지역별 소계와 전체 합계까지 자동으로 붙는다.<ul><li>East 소계: East 지역은 A 100, B 150을 합쳐 250</li><li>West 소계: West는 A 200, B 50을 합쳐 250</li><li>전체 합계: 500<ul><li>소계를 표시할 때는 product 칸이 NULL로 나타나고 전체 합계는 region과 product가 모두 NULL로 표시.</li></ul></li></ul></li></ul><h3><a class=anchor href=#>#</a></h3><ul><li>GROUP BY CUBE(region, product)를 쓰면?</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- GROUP BY CUBE
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> region, product, <span style=color:#66d9ef>SUM</span>(amount) <span style=color:#66d9ef>AS</span> total
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> sales_summary
</span></span><span style=display:flex><span><span style=color:#66d9ef>GROUP</span> <span style=color:#66d9ef>BY</span> <span style=color:#66d9ef>CUBE</span>(region, product);
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>region | product | total
</span></span><span style=display:flex><span>-------+---------+------
</span></span><span style=display:flex><span>East   | A       | 100
</span></span><span style=display:flex><span>East   | B       | 150
</span></span><span style=display:flex><span>East   | NULL    | 250   &lt;- East 소계
</span></span><span style=display:flex><span>West   | A       | 200
</span></span><span style=display:flex><span>West   | B       |  50
</span></span><span style=display:flex><span>West   | NULL    | 250   &lt;- West 소계
</span></span><span style=display:flex><span>NULL   | A       | 300   &lt;- 제품 A 전체 합계
</span></span><span style=display:flex><span>NULL   | B       | 200   &lt;- 제품 B 전체 합계
</span></span><span style=display:flex><span>NULL   | NULL    | 500   &lt;- 전체 합계
</span></span></code></pre></div><ul><li>지역별 합계와 전체 합계뿐 아니라 제품별 합계도 같이 나온다.<ul><li>East-A, East-B, West-A, West-B 같은 상세 데이터가 나오고 (기본 GROUP BY)</li><li>East 전체, West 전체, 그냥 전체 데이터가 나오고 (GROUP BY ROLLUP)</li><li>제품 A 전체, 제품 B 전체 데이터도 나온다.</li></ul></li></ul><h3><a class=anchor href=#>#</a></h3><p>ROLLUP과 CUBE의 차이?</p><ul><li>ROLLUP은 계층적으로 요약<ul><li>ROLLUP(region, product)이면<ul><li>첫 번째 컬럼(region)을 기준으로 묶고 -> 그 &ldquo;안에서&rdquo; 두 번째 컬럼(product)을 묶고 -> 마지막으로 전체 합계까지 올라감</li><li>East-A 100, East-B 150, East 전체 250 / West-A 200, West-B 50, West 전체 250 / 전체 500<ul><li>보면 East / West 로 묶고 -> East 안에서 A/B로 묶고 -> 전체 500 함.</li></ul></li></ul></li></ul></li><li>CUBE는 가능한 모든 조합<ul><li>CUBE(region, product)이면<ul><li>East-A 100, East-B 150, East 전체 250 / West-A 200, West-B 50, West 전체 250 / 제품 A 전체 300 / 제품 B 전체 200 / 전체 500<ul><li>보면 East / West 로 묶고 -> East 안에서 A/B로 묶고 -> A/B로 묶고 -> A안에서 East/West로 묶는건 의미없으니 없고 -> 전체 500 함.</li></ul></li></ul></li></ul></li></ul><h3><a class=anchor href=#>#</a></h3><h3 id=3-udf--시퀀스--저장-프로시저--udt--트리거>3. UDF & 시퀀스 & 저장 프로시저 & UDT & 트리거
<a class=anchor href=#3-udf--%ec%8b%9c%ed%80%80%ec%8a%a4--%ec%a0%80%ec%9e%a5-%ed%94%84%eb%a1%9c%ec%8b%9c%ec%a0%80--udt--%ed%8a%b8%eb%a6%ac%ea%b1%b0>#</a></h3><p>(p.95-101)</p><p>UDF</p><ul><li>SQL 문법만으로는 반복적인 계산이나 특정 규칙 적용이 어려운데<ul><li>UDF를 만들어놓으면 데이터베이스 안에 내장된 함수 외에도 필요할 때 불러다 쓸 수 있다.</li></ul></li><li>is_similar 함수<ul><li>두 개의 실수값이 주어진 임계치 이상으로 가까운지를 판별하는함수</li></ul></li><li>실질적 활용?<ul><li>임베딩 스토어에서 코사인 유사도가 일정 기준 이상인 후보만 필터링하는 기능이니까<ul><li>데이터베이스 안에서 바로 AI 예측 후보 선별에 쓸수있다.</li></ul></li></ul></li></ul><h3><a class=anchor href=#>#</a></h3><p>시퀀스</p><ul><li>자동으로 증가하는 고유 ID를 만들어줌<ul><li>테이블에 데이터를 넣을 때 시퀀스를 만들어 두고 nextval로 꺼내 쓰면 순차적으로 값이 올라가니까 데이터마다 일일이 ID를 붙이지 않아도 된다.</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- 시퀀스 생성
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> SEQUENCE my_seq <span style=color:#66d9ef>START</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 임베딩을 저장하는 테이블 embedding_store
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> embedding_store (
</span></span><span style=display:flex><span>    id BIGINT <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span> <span style=color:#66d9ef>DEFAULT</span> nextval(<span style=color:#e6db74>&#39;my_seq&#39;</span>),
</span></span><span style=display:flex><span>    user_text TEXT,
</span></span><span style=display:flex><span>    embedding VECTOR(<span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- nextval(&#39;my_seq&#39;)로 자동 증가하는 ID를 달아주기
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> embedding_store (user_text, embedding)
</span></span><span style=display:flex><span><span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;hello world&#39;</span>, <span style=color:#e6db74>&#39;[0.1, 0.2, 0.3, 0.4]&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 또 다른 데이터를 넣으면 ID가 자동으로 2가 됨
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> embedding_store (user_text, embedding)
</span></span><span style=display:flex><span><span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;how are you&#39;</span>, <span style=color:#e6db74>&#39;[0.5, 0.6, 0.7, 0.8]&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 확인해보면?
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> embedding_store;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>id |   user_text   |      embedding
</span></span><span style=display:flex><span>---+---------------+------------------------
</span></span><span style=display:flex><span> 1 | hello world   | [0.1, 0.2, 0.3, 0.4]
</span></span><span style=display:flex><span> 2 | how are you   | [0.5, 0.6, 0.7, 0.8]
</span></span></code></pre></div><ul><li>예시<ul><li>CREATE SEQUENCE my_seq START 1; -> 이렇게 만들어 두면</li><li>DEFAULT nextval(&lsquo;my_seq&rsquo;)를 컬럼에 달아주면</li><li>INSERT INTO embedding_store (user_text, embedding) 할 때 자동으로 ID가 올라간다<ul><li>매번 새로운 번호가 붙기 때문에 중복 없는 고유 ID를 쉽게 관리할수있다.</li></ul></li></ul></li><li>실질적 활용?<ul><li>모델 예측 결과나 벡터 데이터가 쌓일 때 결과를 추적하거나 버전을 구분할때<ul><li>벡터를 하나씩 저장할 때마다 고유 번호를 자동으로 달아주면 나중에 “이 임베딩이 어떤 실험에서 나온 것인지”를 관리하기 쉽다.</li></ul></li><li>결과 추적?<ul><li>어떤 문장을 임베딩해서 384차원짜리 벡터를 만들었고 -> 벡터를 테이블에 저장할건데 -> 임베딩은 숫자 배열이므로 나중에 “이 벡터가 언제, 어떤 실험, 어떤 모델로 만들어진 건지”를 추적하기 어려운데 -> 이때 시퀀스로 생성한 고유 ID를 같이 붙여 주면?<ul><li>첫 번째 벡터 저장 → ID = 1000</li><li>두 번째 벡터 저장 → ID = 1001</li><li>세 번째 벡터 저장 → ID = 1002</li><li>이렇게 고유 ID가 붙으면 나중에 분석할 때 “ID=1002인 벡터는 실험 X에서 나온 결과다” 하고 연결하기 쉽다.</li></ul></li></ul></li><li>버전 관리?<ul><li>같은 문장을 두번 실험에 다르게 임베딩했으면 1차 실험 때는 모델 버전 1로 뽑은 벡터 2차 실험 때는 모델 버전 2로 뽑은 벡터가 있을 수 있고 -> 이럴 때 고유 ID를 붙여 두면 “실험 1번에서 나온 ID 1010 벡터와, 실험 2번에서 나온 ID 2020 벡터를 비교하자” 이렇게 버전 관리 할수있다.</li></ul></li></ul></li></ul><h3><a class=anchor href=#>#</a></h3><p>저장 프로시저</p><ul><li>여러 SQL 문장을 묶어 하나의 절차처럼 실행</li><li>예시<ul><li>예측 결과 테이블 prediction_results가 있고 실제 라벨(true_label)과 모델이 예측한 라벨(pred_label)이 있다.</li><li>AI 모델이 예측한 결과를 5개 저장하려고 한다.</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- 예측 결과 테이블 prediction_results
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> prediction_results (
</span></span><span style=display:flex><span>    id BIGSERIAL <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>    true_label TEXT,
</span></span><span style=display:flex><span>    pred_label TEXT,
</span></span><span style=display:flex><span>    created_at <span style=color:#66d9ef>TIMESTAMP</span> <span style=color:#66d9ef>DEFAULT</span> NOW()
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 저장 프로시저 insert_prediction_batch
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>OR</span> <span style=color:#66d9ef>REPLACE</span> <span style=color:#66d9ef>PROCEDURE</span> insert_prediction_batch(
</span></span><span style=display:flex><span>    p_true_label TEXT,
</span></span><span style=display:flex><span>    p_pred_label TEXT,
</span></span><span style=display:flex><span>    p_count INT
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>LANGUAGE</span> plpgsql
</span></span><span style=display:flex><span><span style=color:#66d9ef>AS</span> <span style=color:#960050;background-color:#1e0010>$$</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>BEGIN</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>FOR</span> i <span style=color:#66d9ef>IN</span> <span style=color:#ae81ff>1</span>..p_count LOOP
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> prediction_results (true_label, pred_label)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>VALUES</span> (p_true_label, p_pred_label);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>END</span> LOOP;
</span></span><span style=display:flex><span><span style=color:#66d9ef>END</span>;
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>$$</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- AI 모델의 예측 결과 저장하기
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- 저장 프로시저 안쓴경우
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> prediction_results (true_label, pred_label) <span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;spam&#39;</span>, <span style=color:#e6db74>&#39;spam&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> prediction_results (true_label, pred_label) <span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;spam&#39;</span>, <span style=color:#e6db74>&#39;spam&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> prediction_results (true_label, pred_label) <span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;spam&#39;</span>, <span style=color:#e6db74>&#39;spam&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> prediction_results (true_label, pred_label) <span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;spam&#39;</span>, <span style=color:#e6db74>&#39;spam&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> prediction_results (true_label, pred_label) <span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;spam&#39;</span>, <span style=color:#e6db74>&#39;spam&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 저장 프로시저를 쓴 경우
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>CALL</span> insert_prediction_batch(<span style=color:#e6db74>&#39;spam&#39;</span>, <span style=color:#e6db74>&#39;spam&#39;</span>, <span style=color:#ae81ff>5</span>);
</span></span></code></pre></div><ul><li>저장 프로시저가 없으면 개발자가 직접 5번 INSERT 문을 날려야하는데</li><li>저장 프로시저가 있으면 똑같이 5건을 넣어야 하는 상황에서 CALL 한 줄만 쓰면 된다.<ul><li>프로시저 내부에 반복문(FOR i IN 1..p_count)이 있어서 알아서 5번 INSERT를 실행해준다</li></ul></li></ul><h3><a class=anchor href=#>#</a></h3><p>사용자 정의 데이터 타입(UDT)</p><ul><li>보통 테이블 컬럼은 숫자, 문자열 같은 단순 타입인데 내가 원하는 구조를 만들어서 하나의 타입처럼 쓸 수 있다.</li><li>예측 결과를 저장하려고 할때.<ul><li>썼을때와 안썼을때의 차이를 보면?</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- 안 썼을 때
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- 예측 테이블 prediction_logs_plain 생성
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> prediction_logs_plain (
</span></span><span style=display:flex><span>    id SERIAL <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>    model_name TEXT,
</span></span><span style=display:flex><span>    label TEXT,
</span></span><span style=display:flex><span>    score FLOAT,
</span></span><span style=display:flex><span>    created_at <span style=color:#66d9ef>TIMESTAMP</span> <span style=color:#66d9ef>DEFAULT</span> NOW()
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 데이터 넣기
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> prediction_logs_plain (model_name, label, score)
</span></span><span style=display:flex><span><span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;spam_detector&#39;</span>, <span style=color:#e6db74>&#39;spam&#39;</span>, <span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>92</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 조회
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> id, model_name, label, score
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> prediction_logs_plain;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span> id | model_name    | label | score
</span></span><span style=display:flex><span>----+---------------+-------+-------
</span></span><span style=display:flex><span>  1 | spam_detector | spam  | 0.92
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- 썼을 때
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- UDT로 (label, score)를 하나의 덩어리로 정의
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TYPE</span> prediction_result_type <span style=color:#66d9ef>AS</span> (
</span></span><span style=display:flex><span>    label TEXT,
</span></span><span style=display:flex><span>    score FLOAT
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 예측 테이블 prediction_logs_udt 생성
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> prediction_logs_udt (
</span></span><span style=display:flex><span>    id SERIAL <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>    model_name TEXT,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>result</span> prediction_result_type,
</span></span><span style=display:flex><span>    created_at <span style=color:#66d9ef>TIMESTAMP</span> <span style=color:#66d9ef>DEFAULT</span> NOW()
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 데이터 넣기
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> prediction_logs_udt (model_name, <span style=color:#66d9ef>result</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;spam_detector&#39;</span>, <span style=color:#66d9ef>ROW</span>(<span style=color:#e6db74>&#39;spam&#39;</span>, <span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>92</span>)::prediction_result_type);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 조회
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> id, model_name, (<span style=color:#66d9ef>result</span>).label, (<span style=color:#66d9ef>result</span>).score
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> prediction_logs_udt;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span> id | model_name    | label | score
</span></span><span style=display:flex><span>----+---------------+-------+-------
</span></span><span style=display:flex><span>  1 | spam_detector | spam  | 0.92
</span></span></code></pre></div><ul><li>구체적으로 어디가 다르냐면<ul><li>데이터 넣기<ul><li>안썼을때: (model_name, label, score) -> label과 score를 각각 컬럼에 직접 넣는다.</li><li>udt 썼을때: (model_name, result) -> label과 score를 ROW()로 묶어서 result라는 한 컬럼에 넣는다.</li></ul></li><li>조회<ul><li>안썼을때: SELECT label, score -> 그냥 컬럼 이름(label, score)으로 바로 꺼낸다.</li><li>udt 썼을때: SELECT (result).label, (result).score -> result 안에서 필드를 꺼내는 방식으로 꺼낸다.</li></ul></li></ul></li><li>의문점<ul><li>출력 결과가 똑같은데 왜쓰는거지?</li></ul></li><li>답<ul><li>출력 결과만 비교하면 같지만 확장성에서 차이가있다.<ul><li>안 썼을 때는 함수가 여러 개 값을 리턴해야 하면 RETURNS TABLE(label TEXT, score FLOAT) 같은 형태로 정의해야 하는데 썼을 때는 함수가 RETURNS prediction_result_type로 정의되니까 “이 함수는 예측 결과 하나를 리턴한다”라고 직관적으로 쓸 수 있다 즉 데이터 구조를 하나의 타입으로 추상화할 수 있다.</li><li>안 썼을 때는 label, score를 다른 테이블에서도 쓰려면 매번 두 컬럼을 복사해야 하는데 썼을 때는 그냥 result prediction_result_type 하나만 선언하면 되니까 중복 정의를 줄이고 일관성 유지 가능(이건 예시에선 2개여서 메리트 없어보이는데 개수 늘어나면 납득됨)</li><li>복잡한 구조 확장<ul><li>예측 결과가 단순히 label+score로 끝나지 않고 label, score, confidence_interval, metadata 같이 커질 수 있는데 안 썼을 때는 컬럼이 점점 늘어나고 테이블마다 다 복사해야 하지만 썼을 때는 타입만 확장하면 모든 테이블·함수에서 동일하게 활용 가능하다.</li></ul></li></ul></li></ul></li></ul><h3><a class=anchor href=#>#</a></h3><p>트리거</p><ul><li>데이터가 삽입, 수정, 삭제될 때 자동으로 실행되는 규칙</li><li>예시<ul><li>새로운 벡터가 들어왔는데 유사도가 0.5보다 낮으면 경고 테이블에 따로 기록하려고 할때?</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- 트리거 안 썼을 때
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- 1. 메인 테이블
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> embedding_store_plain (
</span></span><span style=display:flex><span>    id SERIAL <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>    text_input TEXT,
</span></span><span style=display:flex><span>    similarity FLOAT
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> similarity_warnings_plain (
</span></span><span style=display:flex><span>    warning_id SERIAL <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>    embedding_id INT,
</span></span><span style=display:flex><span>    similarity FLOAT,
</span></span><span style=display:flex><span>    warning_msg TEXT,
</span></span><span style=display:flex><span>    created_at <span style=color:#66d9ef>TIMESTAMP</span> <span style=color:#66d9ef>DEFAULT</span> NOW()
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 2. 데이터 넣을 때
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- 새 데이터 삽입
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> embedding_store_plain (text_input, similarity)
</span></span><span style=display:flex><span><span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;bad case&#39;</span>, <span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 임계치 체크 후 경고 삽입
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> similarity_warnings_plain (embedding_id, similarity, warning_msg)
</span></span><span style=display:flex><span><span style=color:#66d9ef>VALUES</span> (currval(<span style=color:#e6db74>&#39;embedding_store_plain_id_seq&#39;</span>), <span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>3</span>, <span style=color:#e6db74>&#39;Similarity below threshold&#39;</span>);
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- 트리거 썼을 때
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- 1. 메인 테이블 + 경고 테이블
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> embedding_store (
</span></span><span style=display:flex><span>    id SERIAL <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>    text_input TEXT,
</span></span><span style=display:flex><span>    similarity FLOAT
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> similarity_warnings (
</span></span><span style=display:flex><span>    warning_id SERIAL <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>    embedding_id INT,
</span></span><span style=display:flex><span>    similarity FLOAT,
</span></span><span style=display:flex><span>    warning_msg TEXT,
</span></span><span style=display:flex><span>    created_at <span style=color:#66d9ef>TIMESTAMP</span> <span style=color:#66d9ef>DEFAULT</span> NOW()
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 2. 트리거 함수 + 트리거 생성
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>OR</span> <span style=color:#66d9ef>REPLACE</span> <span style=color:#66d9ef>FUNCTION</span> check_similarity_threshold()
</span></span><span style=display:flex><span><span style=color:#66d9ef>RETURNS</span> <span style=color:#66d9ef>TRIGGER</span> <span style=color:#66d9ef>AS</span> <span style=color:#960050;background-color:#1e0010>$$</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>BEGIN</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>IF</span> <span style=color:#66d9ef>NEW</span>.similarity <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>5</span> <span style=color:#66d9ef>THEN</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> similarity_warnings (embedding_id, similarity, warning_msg)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>VALUES</span> (<span style=color:#66d9ef>NEW</span>.id, <span style=color:#66d9ef>NEW</span>.similarity, <span style=color:#e6db74>&#39;Similarity below threshold&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>END</span> <span style=color:#66d9ef>IF</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>RETURN</span> <span style=color:#66d9ef>NEW</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>END</span>;
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>$$</span> <span style=color:#66d9ef>LANGUAGE</span> plpgsql;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TRIGGER</span> trg_check_similarity
</span></span><span style=display:flex><span><span style=color:#66d9ef>AFTER</span> <span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>ON</span> embedding_store
</span></span><span style=display:flex><span><span style=color:#66d9ef>FOR</span> <span style=color:#66d9ef>EACH</span> <span style=color:#66d9ef>ROW</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>EXECUTE</span> <span style=color:#66d9ef>FUNCTION</span> check_similarity_threshold();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 3. 데이터 넣기
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> embedding_store (text_input, similarity)
</span></span><span style=display:flex><span><span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;bad case&#39;</span>, <span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>3</span>);
</span></span></code></pre></div><ul><li>궁극적인 차이는<ul><li>메인 테이블 + 경고 테이블: 트리거를 쓰든 안 쓰든 구조는 똑같음</li><li>데이터 넣을 때<ul><li>트리거 안 쓰면: INSERT (메인 테이블), INSERT (경고 테이블, 조건 만족 시) -> N개의 쿼리를 개발자가 직접 작성</li><li>트리거 쓰면: INSERT (메인 테이블) -> → 1줄만 작성하면 나머지(조건 체크 + 경고 INSERT)는 DB가 자동 처리.</li></ul></li></ul></li></ul><h3><a class=anchor href=#>#</a></h3><h3 id=4-윈도우-함수>4. 윈도우 함수
<a class=anchor href=#4-%ec%9c%88%eb%8f%84%ec%9a%b0-%ed%95%a8%ec%88%98>#</a></h3><p>(p.126-129)</p><p>집계함수와 윈도우함수 차이</p><ul><li>비슷하지만 GROUP BY처럼 그룹을 한 줄로 압축하지 않고, 각 행마다 순위, 누적합, 이전 값 같은 걸 계산함</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- scores 데이터
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> scores (
</span></span><span style=display:flex><span>    student TEXT,
</span></span><span style=display:flex><span>    subject TEXT,
</span></span><span style=display:flex><span>    score INT
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> scores <span style=color:#66d9ef>VALUES</span>
</span></span><span style=display:flex><span>(<span style=color:#e6db74>&#39;철수&#39;</span>, <span style=color:#e6db74>&#39;수학&#39;</span>, <span style=color:#ae81ff>80</span>),
</span></span><span style=display:flex><span>(<span style=color:#e6db74>&#39;철수&#39;</span>, <span style=color:#e6db74>&#39;영어&#39;</span>, <span style=color:#ae81ff>90</span>),
</span></span><span style=display:flex><span>(<span style=color:#e6db74>&#39;영희&#39;</span>, <span style=color:#e6db74>&#39;수학&#39;</span>, <span style=color:#ae81ff>95</span>),
</span></span><span style=display:flex><span>(<span style=color:#e6db74>&#39;영희&#39;</span>, <span style=color:#e6db74>&#39;영어&#39;</span>, <span style=color:#ae81ff>85</span>),
</span></span><span style=display:flex><span>(<span style=color:#e6db74>&#39;민수&#39;</span>, <span style=color:#e6db74>&#39;수학&#39;</span>, <span style=color:#ae81ff>70</span>),
</span></span><span style=display:flex><span>(<span style=color:#e6db74>&#39;민수&#39;</span>, <span style=color:#e6db74>&#39;영어&#39;</span>, <span style=color:#ae81ff>75</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- 집계 함수 GROUP BY로 학생별 평균 점수 구하기
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> student, <span style=color:#66d9ef>AVG</span>(score) <span style=color:#66d9ef>AS</span> avg_score
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> scores
</span></span><span style=display:flex><span><span style=color:#66d9ef>GROUP</span> <span style=color:#66d9ef>BY</span> student;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>student | avg_score
</span></span><span style=display:flex><span>--------+----------
</span></span><span style=display:flex><span>철수     |   85
</span></span><span style=display:flex><span>영희     |   90
</span></span><span style=display:flex><span>민수     |   72.5
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- 윈도우 함수 OVER로 학생별 평균 점수 구하기
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> student, subject, score,
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>AVG</span>(score) OVER (PARTITION <span style=color:#66d9ef>BY</span> student) <span style=color:#66d9ef>AS</span> avg_score
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> scores;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>student | subject | score | avg_score
</span></span><span style=display:flex><span>--------+---------+-------+----------
</span></span><span style=display:flex><span>철수     | 수학    |  80   |   85
</span></span><span style=display:flex><span>철수     | 영어    |  90   |   85
</span></span><span style=display:flex><span>영희     | 수학    |  95   |   90
</span></span><span style=display:flex><span>영희     | 영어    |  85   |   90
</span></span><span style=display:flex><span>민수     | 수학    |  70   |  72.5
</span></span><span style=display:flex><span>민수     | 영어    |  75   |  72.5
</span></span></code></pre></div><ul><li>GROUPBY -> 학생(그룹) 단위로 묶어서 한 줄로 결과를 압축했다.</li><li>OVER (PARTITION BY student) -> 학생(그룹)별로 평균을 계산하되 결과는 행마다 달아줬다.</li></ul><h3><a class=anchor href=#>#</a></h3><p>윈도우 함수</p><ul><li>ROW_NUMBER()<ul><li>그룹 안에서 순번을 매긴다.<ul><li>사용자별로 점수를 내림차순 정렬하고 ROW_NUMBER를 매기면, 그 사용자 안에서 1등, 2등, 3등을 구할 수 있다.</li></ul></li></ul></li><li>RANK()<ul><li>동점이 있을 때 같은 순위를 부여하고 건너뛰기가 발생한다.<ul><li>1등이 두 명이면 다음 순위는 3등.</li></ul></li></ul></li><li>DENSE_RANK()<ul><li>같은 순위가 있더라도 건너뛰지 않고 다음을 2등으로 붙인다.</li></ul></li><li>NTILE(n)<ul><li>데이터를 n개 구간으로 자른다.</li><li>100명을 NTILE(5)로 나누면 성적을 기준으로 20명씩 다섯 구간으로 나눌 수 있다.</li></ul></li><li>LAG() & LEAD()<ul><li>현재 행 기준으로 앞 행이나 뒤 행 값을 참고할 수 있어서 시간 순서대로 점수를 나열해 두면 바로 직전 점수와 비교하거나 다음 점수를 미리 볼 수 있다</li></ul></li><li>SUM() OVER, AVG() OVER<ul><li>누적합이나 누적평균 구한다.</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>-- ROW_NUMBER()
</span></span><span style=display:flex><span>student | subject | score | rownum
</span></span><span style=display:flex><span>--------+---------+-------+-------
</span></span><span style=display:flex><span>철수     | 수학    |  95   |   1
</span></span><span style=display:flex><span>철수     | 영어    |  95   |   2
</span></span><span style=display:flex><span>철수     | 과학    |  90   |   3
</span></span><span style=display:flex><span>영희     | 수학    | 100   |   1
</span></span><span style=display:flex><span>영희     | 영어    |  80   |   2
</span></span><span style=display:flex><span>민수     | 수학    |  70   |   1
</span></span><span style=display:flex><span>민수     | 과학    |  70   |   2
</span></span><span style=display:flex><span>민수     | 영어    |  60   |   3
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>-- RANK()
</span></span><span style=display:flex><span>student | subject | score | rnk
</span></span><span style=display:flex><span>--------+---------+-------+----
</span></span><span style=display:flex><span>철수     | 수학    |  95   | 1
</span></span><span style=display:flex><span>철수     | 영어    |  95   | 1
</span></span><span style=display:flex><span>철수     | 과학    |  90   | 3
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>-- NTILE(n)
</span></span><span style=display:flex><span>student | subject | score | bucket
</span></span><span style=display:flex><span>--------+---------+-------+-------
</span></span><span style=display:flex><span>철수     | 수학    | 95    | 1
</span></span><span style=display:flex><span>철수     | 영어    | 95    | 1
</span></span><span style=display:flex><span>철수     | 과학    | 90    | 2
</span></span><span style=display:flex><span>-- 상위 절반 = 그룹 1, 하위 절반 = 그룹 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>-- LAG() &amp; LEAD()
</span></span><span style=display:flex><span>student | subject | score | prev_score | next_score
</span></span><span style=display:flex><span>--------+---------+-------+------------+------------
</span></span><span style=display:flex><span>민수     | 과학    |  70   |   (null)   |  60
</span></span><span style=display:flex><span>민수     | 수학    |  70   |    70      |  60
</span></span><span style=display:flex><span>민수     | 영어    |  60   |    70      | (null)
</span></span><span style=display:flex><span>-- 직전 점수와 다음 점수 참조: 민수의 행마다 앞뒤 점수가 달라 붙음.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>-- SUM() OVER, AVG() OVER
</span></span><span style=display:flex><span>student | subject | score | running_total | avg_score
</span></span><span style=display:flex><span>--------+---------+-------+----------------+----------
</span></span><span style=display:flex><span>철수     | 수학    |  95   |       95       |   93.3
</span></span><span style=display:flex><span>철수     | 영어    |  95   |      190       |   93.3
</span></span><span style=display:flex><span>철수     | 과학    |  90   |      280       |   93.3
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- running_total은 점수 누적합, avg_score는 평균.
</span></span></code></pre></div><h3><a class=anchor href=#>#</a></h3><p>AI 연계</p><ul><li>예측 결과를 저장한 prediction_logs 테이블</li><li>활용<ul><li>여러 모델 버전이 같은 사용자에 대해 점수를 매겼을 때 그중 가장 높은 점수를 고르기.<ul><li>ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY pred_score DESC) -> rownum = 1인 행만 선택</li></ul></li><li>모델 간 성능 비교<ul><li>RANK() OVER (PARTITION BY user_id ORDER BY pred_score DESC)</li></ul></li><li>예측 점수 상위 20% 사용자 그룹을 뽑기<ul><li>NTILE(5) OVER (ORDER BY pred_score DESC) -> bucket = 1인 행만 선택</li></ul></li><li>이전 점수와 비교해 사용자의 점수가 올랐는지 떨어졌는지 확인<ul><li>LAG(pred_score) OVER (PARTITION BY user_id ORDER BY created_at) -> pred_score - prev_score 차이 계산</li></ul></li><li>모델 정확도의 누적 변화 확인<ul><li>SUM(pred_score) OVER (&mldr;), AVG(pred_score) OVER (&mldr;)</li></ul></li></ul></li></ul><h3><a class=anchor href=#>#</a></h3><h3 id=5-고급-인덱스>5. 고급 인덱스
<a class=anchor href=#5-%ea%b3%a0%ea%b8%89-%ec%9d%b8%eb%8d%b1%ec%8a%a4>#</a></h3><p>(p.144-148)</p><p>고급 인덱스?</p><ul><li>일반적인 데이터베이스 인덱스는 B-Tree 인덱스.</li><li>AI에서 다루는 데이터는 단순 숫자 키가 아니라 JSON 문서, 벡터, 시계열 로그처럼 복잡하거나 대용량 특성이 있어서 다른 종류의 인덱스들이 필요하다.</li></ul><h3><a class=anchor href=#>#</a></h3><p>GIN 인덱스</p><ul><li>Inverted Index: 거꾸로 색인.<ul><li>보통 행 -> 마다 단어가 있는데</li><li>&ldquo;찾고 싶은 단어 -> 그 단어가 들어 있는 행"으로 인덱스를 만든다.</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{<span style=color:#f92672>&#34;category&#34;</span>: <span style=color:#e6db74>&#34;esg&#34;</span>, <span style=color:#f92672>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;finance&#34;</span>} <span style=color:#960050;background-color:#1e0010>-&gt;</span> <span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>행</span>
</span></span><span style=display:flex><span>{<span style=color:#f92672>&#34;category&#34;</span>: <span style=color:#e6db74>&#34;ai&#34;</span>, <span style=color:#f92672>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;tech&#34;</span>} <span style=color:#960050;background-color:#1e0010>-&gt;</span> <span style=color:#ae81ff>2</span><span style=color:#960050;background-color:#1e0010>행</span>
</span></span><span style=display:flex><span>{<span style=color:#f92672>&#34;category&#34;</span>: <span style=color:#e6db74>&#34;esg&#34;</span>, <span style=color:#f92672>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;policy&#34;</span>} <span style=color:#960050;background-color:#1e0010>-&gt;</span> <span style=color:#ae81ff>3</span><span style=color:#960050;background-color:#1e0010>행</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>&#34;category&#34;=&#34;esg&#34; -&gt; 1행, 3행
</span></span><span style=display:flex><span>&#34;category&#34;=&#34;ai&#34; -&gt; 2행
</span></span><span style=display:flex><span>&#34;type&#34;=&#34;finance&#34; -&gt; 1행
</span></span><span style=display:flex><span>&#34;type&#34;=&#34;tech&#34; -&gt; 2행
</span></span><span style=display:flex><span>&#34;type&#34;=&#34;policy&#34; -&gt; 3행
</span></span></code></pre></div><ul><li>&ldquo;category&rdquo;=&ldquo;esg"인 행을 찾고 싶으면 테이블을 처음부터 끝까지 보지 않고 인덱스를 통해 곧바로 1, 3행을 볼수있다.</li></ul><h3><a class=anchor href=#>#</a></h3><p>GiST 인덱스</p><ul><li>AI에서 쓰는 벡터 데이터에서의 인덱싱은<ul><li>사전처럼 정확한 값을 빠르게 찾기보다는 이 벡터와 가장 비슷한 벡터를 찾는, 정확히 같은 값이 아니라 가까운 값을 찾는 경우가 많다.</li><li>GiST 인덱스는 “거리 기반” 검색을 빠르게 해 주는 구조여서 가까운 것을 찾는 인덱싱에 적합하다.</li></ul></li></ul><h3><a class=anchor href=#>#</a></h3><p>BRIN 인덱스</p><ul><li>범위별 최소·최대 값만 기록해 두고, 그 안에 데이터가 있을 거라고 좁혀 가는 방식</li><li>일기장이 날짜 순으로<ul><li>1월 1일~1월 10일 -> 1권</li><li>1월 11일~1월 20일 -> 2권</li><li>1월 21일~1월 31일 -> 3권<ul><li>이렇게 적혀있으면 1월 15일 일기를 찾으려고하면 2권만 열어 보면 된다.</li></ul></li></ul></li><li>빠른 이유는 범위만 보고 필요한 블록만 열어보면 되기 때문.<ul><li>잘 맞는 경우는 로그, 시계열 데이터</li><li>잘 안 맞는 경우는 무작위 데이터. 왜냐면 “최소~최대”로 구간을 좁힐 수 없기 때문에 범위가 의미가 없다.</li></ul></li></ul><h1><a class=anchor href=#>#</a></h1></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=yshghid/yshghid.github.io data-repo-id=R_kgDONkMkNg data-category-id=DIC_kwDONkMkNs4CloJh data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#1-groupby>1. GROUPBY</a></li><li></li><li></li><li></li><li></li><li></li><li><a href=#2-rollup--cube>2. ROLLUP & CUBE</a></li><li></li><li></li><li></li><li></li><li><a href=#3-udf--시퀀스--저장-프로시저--udt--트리거>3. UDF & 시퀀스 & 저장 프로시저 & UDT & 트리거</a></li><li></li><li></li><li></li><li></li><li></li><li><a href=#4-윈도우-함수>4. 윈도우 함수</a></li><li></li><li></li><li></li><li><a href=#5-고급-인덱스>5. 고급 인덱스</a></li><li></li><li></li><li></li></ul></li></ul></nav></div></aside></main></body></html>
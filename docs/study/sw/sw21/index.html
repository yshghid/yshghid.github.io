<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  python #2 객체지향 프로그래밍, 병렬처리
  #

#2025-08-13


  1. 객체지향 프로그래밍
  #

#1 property & dataclass (p.139-140)
  
  
@property

diameter 메서드는 사실 _radius * 2라는 계산을 수행하지만 외부에선 c.diameter라고 쓰면 바로 10이라는 결과를 얻을 수 있다.
@diameter.setter를 사용하면 c.diameter = 20 형태로 diameter을 수정할수있고

내부에서는 diameter을 받아 _radius=10으로 변환 저장한다.


fastapi에서 젤많이쓰는 기능이 속성화이다.

@dataclass

보통 클래스를 만들면 __init__으로 생성자, __repr__으로 객체 출력 형식, __eq__로 동등성 비교 등을 직접 정의해야 하는데 @dataclass를 붙이면 이런 메서드들이 자동 생성된다.
Point 클래스는 x, y 좌표만 Point(1,2)로 정의했는데 이 상태로 객체 p1, p2를 생성하고 출력하면 Point(x=1, y=2)처럼 형식맞춰 나온다.

그리고 == 비교 시 자동으로 True도 나온다.




  
  #

#2 @property"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://yshghid.github.io/docs/study/sw/sw21/"><meta property="og:site_name" content=" "><meta property="og:title" content="python #2 객체지향 프로그래밍, 병렬처리"><meta property="og:description" content="python #2 객체지향 프로그래밍, 병렬처리 # #2025-08-13
1. 객체지향 프로그래밍 # #1 property & dataclass (p.139-140)
@property
diameter 메서드는 사실 _radius * 2라는 계산을 수행하지만 외부에선 c.diameter라고 쓰면 바로 10이라는 결과를 얻을 수 있다. @diameter.setter를 사용하면 c.diameter = 20 형태로 diameter을 수정할수있고 내부에서는 diameter을 받아 _radius=10으로 변환 저장한다. fastapi에서 젤많이쓰는 기능이 속성화이다. @dataclass
보통 클래스를 만들면 __init__으로 생성자, __repr__으로 객체 출력 형식, __eq__로 동등성 비교 등을 직접 정의해야 하는데 @dataclass를 붙이면 이런 메서드들이 자동 생성된다. Point 클래스는 x, y 좌표만 Point(1,2)로 정의했는데 이 상태로 객체 p1, p2를 생성하고 출력하면 Point(x=1, y=2)처럼 형식맞춰 나온다. 그리고 == 비교 시 자동으로 True도 나온다. # #2 @property"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2025-08-13T00:00:00+00:00"><meta property="article:modified_time" content="2025-08-13T00:00:00+00:00"><meta property="article:tag" content="2025-08"><title>python #2 객체지향 프로그래밍, 병렬처리 |</title><link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://yshghid.github.io/docs/study/sw/sw21/><link rel=stylesheet href=/book.min.30a7836b6a89342da3b88e7afd1036166aeced16c8de12df060ded2031837886.css integrity="sha256-MKeDa2qJNC2juI56/RA2Fmrs7RbI3hLfBg3tIDGDeIY=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.7ee5e0fca7a1004f000c527c91605c29edc9f484601fc091f6667e380732236b.js integrity="sha256-fuXg/KehAE8ADFJ8kWBcKe3J9IRgH8CR9mZ+OAcyI2s=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/logo.png alt=Logo class=book-icon><span></span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><span>기록</span><ul><li><a href=/docs/hobby/daily/>일상</a><ul></ul></li><li><a href=/docs/hobby/book/>글</a><ul></ul></li></ul></li><li class=book-section-flat><span>공부</span><ul><li><a href=/docs/study/bioinformatics/>Bioinformatics</a><ul></ul></li><li><a href=/docs/study/ai/>AI</a><ul></ul></li><li><a href=/docs/study/sw/>SW</a><ul></ul></li><li><a href=/docs/study/career/>취업</a><ul></ul></li></ul></li><li><a href=/docs/portfolio/>#portfolio</a><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>python #2 객체지향 프로그래밍, 병렬처리</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#1-객체지향-프로그래밍>1. 객체지향 프로그래밍</a></li><li></li><li></li><li></li><li></li><li></li><li><a href=#2-병렬처리>2. 병렬처리</a></li><li></li><li></li><li></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=python-2-객체지향-프로그래밍-병렬처리>python #2 객체지향 프로그래밍, 병렬처리
<a class=anchor href=#python-2-%ea%b0%9d%ec%b2%b4%ec%a7%80%ed%96%a5-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d-%eb%b3%91%eb%a0%ac%ec%b2%98%eb%a6%ac>#</a></h1><p>#2025-08-13</p><hr><h3 id=1-객체지향-프로그래밍>1. 객체지향 프로그래밍
<a class=anchor href=#1-%ea%b0%9d%ec%b2%b4%ec%a7%80%ed%96%a5-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d>#</a></h3><p><mark>#1 property & dataclass</mark> (p.139-140)</p><img width=490 height=311.5 alt=image src=https://github.com/user-attachments/assets/0cd4a773-af47-4e60-9a70-4cad3db0adec>
<img width=488 height=340 alt=image src=https://github.com/user-attachments/assets/c478b989-8c01-476e-96e4-59ba42d657cc><p>@property</p><ul><li>diameter 메서드는 사실 _radius * 2라는 계산을 수행하지만 외부에선 c.diameter라고 쓰면 바로 10이라는 결과를 얻을 수 있다.</li><li>@diameter.setter를 사용하면 c.diameter = 20 형태로 diameter을 수정할수있고<ul><li>내부에서는 diameter을 받아 _radius=10으로 변환 저장한다.</li></ul></li><li>fastapi에서 젤많이쓰는 기능이 속성화이다.</li></ul><p>@dataclass</p><ul><li>보통 클래스를 만들면 __init__으로 생성자, __repr__으로 객체 출력 형식, __eq__로 동등성 비교 등을 직접 정의해야 하는데 @dataclass를 붙이면 이런 메서드들이 자동 생성된다.</li><li>Point 클래스는 x, y 좌표만 Point(1,2)로 정의했는데 이 상태로 객체 p1, p2를 생성하고 출력하면 Point(x=1, y=2)처럼 형식맞춰 나온다.<ul><li>그리고 == 비교 시 자동으로 True도 나온다.</li></ul></li></ul><h3><a class=anchor href=#>#</a></h3><p><mark>#2 @property</mark></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Order 클래스: 주문 내역 저장</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Order</span>: 
</span></span><span style=display:flex><span>    __slots__ <span style=color:#f92672>=</span> (<span style=color:#e6db74>&#34;beverage&#34;</span>, <span style=color:#e6db74>&#34;quantity&#34;</span>) <span style=color:#75715e># 인스턴스 속성을 beverage와 quantity로 고정하여 메모리 절약</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, beverage: Beverage, quantity: int) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>: <span style=color:#75715e># beverage 타입 명시(Beverage), quantity 타입 명시 (int)</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>beverage <span style=color:#f92672>=</span> beverage <span style=color:#75715e># self 객체에 beverage 객체 저장</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>quantity <span style=color:#f92672>=</span> quantity <span style=color:#75715e># 주문 수량 quantity 저장</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@property</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>total_price</span>(self) <span style=color:#f92672>-&gt;</span> float: <span style=color:#75715e># total_price 프로퍼티: 주문금액 = 음료 가격 × 수량 자동 계산</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>beverage<span style=color:#f92672>.</span>price <span style=color:#f92672>*</span> self<span style=color:#f92672>.</span>quantity
</span></span></code></pre></div><ul><li>class Order<ul><li>주문 정보를 저장하는 클래스</li><li>속성: beverage, quantity<ul><li>__slots__를 사용해 이 두 속성만 인스턴스에 저장할 수 있도록 제한했기 때문에 메모리 사용량이 줄고 실수로 다른 속성을 추가하는 것도 방지함.</li></ul></li><li>total_price 메서드<ul><li>@property로 정의됨</li><li>주문 금액을 계산하는 로직을 담고 있지만 속성 접근처럼 쓸 수 있다 즉 order.total_price()가 아니라 order.total_price로 쓸수있다.</li></ul></li></ul></li></ul><p>cf) @property 안썼으면?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Order 클래스 1: @property 사용</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OrderWithProperty</span>:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@property</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>total_price</span>(self) <span style=color:#f92672>-&gt;</span> float:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>beverage<span style=color:#f92672>.</span>price <span style=color:#f92672>*</span> self<span style=color:#f92672>.</span>quantity
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Order 클래스 2: @property 미사용</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OrderWithoutProperty</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>total_price</span>(self) <span style=color:#f92672>-&gt;</span> float:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>beverage<span style=color:#f92672>.</span>price <span style=color:#f92672>*</span> self<span style=color:#f92672>.</span>quantity
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 테스트</span>
</span></span><span style=display:flex><span>coffee <span style=color:#f92672>=</span> Beverage(<span style=color:#e6db74>&#34;아메리카노&#34;</span>, <span style=color:#ae81ff>3000</span>, [<span style=color:#e6db74>&#34;커피&#34;</span>, <span style=color:#e6db74>&#34;아메리카노&#34;</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>order1 <span style=color:#f92672>=</span> OrderWithProperty(coffee, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>order2 <span style=color:#f92672>=</span> OrderWithoutProperty(coffee, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;=== @property 사용 ===&#34;</span>)
</span></span><span style=display:flex><span>print(order1<span style=color:#f92672>.</span>total_price)   <span style=color:#75715e># 괄호 없이 속성처럼 접근</span>
</span></span><span style=display:flex><span><span style=color:#75715e># print(order1.total_price())  # 이렇게 하면 TypeError 발생</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;=== @property 미사용 ===&#34;</span>)
</span></span><span style=display:flex><span>print(order2<span style=color:#f92672>.</span>total_price()) <span style=color:#75715e># 반드시 괄호를 붙여 메서드 호출</span>
</span></span><span style=display:flex><span>print(order2<span style=color:#f92672>.</span>total_price)   <span style=color:#75715e># 괄호 없이 접근하면 메서드 객체가 출력됨</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>=== @property 사용 ===
</span></span><span style=display:flex><span>6000
</span></span></code></pre></div><ul><li>@property 사용하면 order.total_price로 괄호 없이 접근했을때, 내부에서 계산된 결과가 바로 반환되고</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>=== @property 미사용 ===
</span></span><span style=display:flex><span>6000
</span></span><span style=display:flex><span>&lt;bound method OrderWithoutProperty.total_price of &lt;__main__.OrderWithoutProperty object at 0x...&gt;&gt;
</span></span></code></pre></div><ul><li>@property 사용 안하면 order.total_price()로 호출하면 6000이 나오고 괄호없이 호출하면 메서드 객체 참조만 나온다.</li></ul><h3><a class=anchor href=#>#</a></h3><p><mark>#3 @dataclass</mark></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Beverage 클래스: 음료 데이터 정의</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@dataclass</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Beverage</span>: 
</span></span><span style=display:flex><span>    name: str <span style=color:#75715e># 음료 이름 속성</span>
</span></span><span style=display:flex><span>    price: float <span style=color:#75715e># 가격 속성</span>
</span></span><span style=display:flex><span>    tags: List[str] <span style=color:#75715e># 분류 태그 속성</span>
</span></span></code></pre></div><ul><li>class Beverage<ul><li>음료 정보를 저장하는 데이터 전용 클래스</li><li>속성: name(문자열), price(실수형), tags(문자열 리스트)</li><li>@dataclass로 자동으로 <code>__init__</code>(생성자), <code>__repr__</code>(객체를 보기 좋게 출력), <code>__eq__</code>(값 비교) 같은 기본 메서드가 생성.</li></ul></li></ul><p>cf) @dataclass 안썼으면?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> typing <span style=color:#f92672>import</span> List
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Beverage</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, name: str, price: float, tags: List[str]):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>price <span style=color:#f92672>=</span> price
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>tags <span style=color:#f92672>=</span> tags
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__repr__</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Beverage(name=</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>name<span style=color:#e6db74>!r}</span><span style=color:#e6db74>, price=</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>price<span style=color:#e6db74>!r}</span><span style=color:#e6db74>, tags=</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>tags<span style=color:#e6db74>!r}</span><span style=color:#e6db74>)&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__eq__</span>(self, other):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> isinstance(other, Beverage):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (self<span style=color:#f92672>.</span>name, self<span style=color:#f92672>.</span>price, self<span style=color:#f92672>.</span>tags) <span style=color:#f92672>==</span> (other<span style=color:#f92672>.</span>name, other<span style=color:#f92672>.</span>price, other<span style=color:#f92672>.</span>tags)
</span></span></code></pre></div><ul><li><code>__init__</code> : 매개변수를 받아 속성을 초기화 / <code>__repr__</code> : 객체를 보기 좋게 문자열로 표현 / <code>__eq__</code> : 객체 간 동등성 비교 로직 작성 이렇게 하나하나 추가해야한다.</li></ul><h3><a class=anchor href=#>#</a></h3><p><mark>#4 decorator & closer</mark> (p.168-169)</p><img width=488 height=246 alt=image src=https://github.com/user-attachments/assets/419797d8-daa4-49ff-a63c-d7ea493b8517>
<img width=496 height=263.5 alt=image src=https://github.com/user-attachments/assets/efceee87-f618-4184-96bf-c31727f63d60><p>decorator</p><ul><li>데코레이터 (timer)<ul><li>함수 실행시간을 자동으로 측정</li><li>내부에 wrapper 함수를 정의해서 slow function을 감싼다.</li></ul></li><li>흐름<ul><li>wrapper는 시작시간기록, slow function 실행결과를 result에 저장하고 종료시간 기록, 걸린시간 계산, result를 반환</li><li>@timer -> slow function을 호출하면 사실상 wrapper가 실행된다. wrapper 안에서 slow function이 호출 -> 2초 대기 -> 작업완료 출력 -> 실행시간 result 출력</li></ul></li><li>의의<ul><li>함수를 호출하기 전후에 원하는 로직을 끼워 넣어 원래 함수의 기능은 그대로 두고 부가적인 기능을 쉽게 추가할 수 있게.</li></ul></li></ul><p>closure</p><ul><li>outer()가 실행되면?<ul><li>x = 10이 만들어지고 inner 함수가 정의됨</li><li>outer()는 inner 함수를 그 자체로 반환함 (inner의 결과를 반환하는게 아니고)</li></ul></li><li>closure = outer()?<ul><li>closure에 <strong>inner 함수</strong>가 저장</li><li>이때 inner 함수는 자신이 정의될 당시의 환경(= x=10이 있던 outer의 스코프)을 함께 기억함</li><li>그래서 outer가 끝나서 x 변수가 사라진 것처럼 보여도 closure()를 실행하면 여전히 x = 10에 접근 가능.</li></ul></li><li>closure는 decorator처럼 @문법을 붙이지 않아도 적용된다.</li></ul><h3><a class=anchor href=#>#</a></h3><p><mark>#5 decorator와 closure 함께사용하기</mark></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># timeit을 사용하여 실행 성능 측정</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>measure_time</span>(func):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>wrapper</span>(<span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs):
</span></span><span style=display:flex><span>        elapsed_time <span style=color:#f92672>=</span> timeit<span style=color:#f92672>.</span>timeit(<span style=color:#66d9ef>lambda</span>: func(<span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs), number<span style=color:#f92672>=</span><span style=color:#ae81ff>100</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> elapsed_time
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> wrapper
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@measure_time</span> <span style=color:#75715e># 데코레이터: run_typed 실행시 자동으로 실행</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run_typed</span>(test_data): 
</span></span><span style=display:flex><span>    sum_of_squares_typed(test_data)
</span></span></code></pre></div><p>decorator</p><ul><li>데코레이터 measure_time<ul><li>실행 시간 측정</li><li>내부에 wrapper 함수를 정의해서 run_typed을 감싼다.</li></ul></li><li>흐름<ul><li>wrapper는 run_typed 실행결과를 elapsed_time에 저장한 뒤 반환</li><li>@measure_time -> run_typed을 호출하면 사실상 wrapper가 실행된다. wrapper 안에서 run_typed가 호출 -> 실행시간 elapsed_time 출력</li></ul></li></ul><p>closure</p><ul><li>measure_time이 실행되면?<ul><li>wrapper 함수가 정의됨, measure_time은 wrapper 함수를 그 자체로 반환함 (wrapper의 결과를 반환하는게 아니고)</li></ul></li><li>run_typed에 @measure_time이 적용되면?<ul><li>run_typed 함수 객체가 measure_time의 매개변수 func로 전달</li><li>measure_time 안에서 정의된 wrapper 함수는 자신이 정의될 당시의 환경(자기 바깥 함수의 지역 변수인 func)를 기억</li><li>그래서 measure_time이 종료되어 원래 지역 변수 func가사라진 것처럼 보여도 wrapper 함수 내부에는 여전히 func에 대한 참조가 살아 있다.</li></ul></li></ul><h3><a class=anchor href=#>#</a></h3><h3 id=2-병렬처리>2. 병렬처리
<a class=anchor href=#2-%eb%b3%91%eb%a0%ac%ec%b2%98%eb%a6%ac>#</a></h3><p><mark>#1 multithreading</mark> (p.189)</p><img width=502.5 height=293.5 alt=image src=https://github.com/user-attachments/assets/39bae8b1-15d1-4bb9-aea6-d16817d5482c><ul><li>스레드가 같은 프로세스 내부에서 실행되며 메모리와 실행 환경을 공유</li><li>예제 코드<ul><li>print_numbers와 print_letters를 각각 thread1 thread2로 실행</li><li>결과<ul><li>숫자 1부터 5까지와 알파벳 A부터 E까지가 1초 간격으로 번갈아 출력</li></ul></li></ul></li></ul><h3><a class=anchor href=#>#</a></h3><p><mark>#2 mutliprocessing</mark> (p.191)</p><img width=500 height=299.5 alt=image src=https://github.com/user-attachments/assets/b034daa5-2f61-4132-b01e-fa11a902dea3><ul><li>함수가 완전히 독립된 프로세스로 실행</li><li>예제 코드<ul><li>print_numbers와 print_letters를 독립적인 프로세스 process1 process2로 실행</li><li>결과<ul><li>두 프로세스가 동시에 시작되더라도 실행 타이밍과 OS 스케줄링 우선순위, 프로세스 생성 시점의 지연 때문에 한 프로세스가 먼저 실행을 많이 진행하고 다른 프로세스가 뒤따라 실행되게되고</li><li>그 결과 숫자 1-5를 전부 찍고 난 후 알파벳 A-E를 찍는 식으로 출력이 묶음 단위로 나타난다.</li></ul></li></ul></li></ul><h3><a class=anchor href=#>#</a></h3><p><mark>#3 multithreading & mutliprocessing</mark></p><p>multithreading</p><ul><li>두 스레드가 같은 프로세스 내부에서 실행되며 메모리와 실행 환경을 공유한다.</li><li>예제에서 숫자를 찍는 함수와 알파벳을 찍는 함수 각각이 독립적인 스레드로 동작하지만 동일한 프로세스의 GIL(Global Interpreter Lock)을 공유하기 때문에 한 번에 한 스레드만 실제로 파이썬 바이트코드를 실행한다.</li><li>time.sleep(1)로 실행 권한을 번갈아 준 결과 숫자를 하나 찍고 잠시 멈춘 사이 다른 스레드가 알파벳을 찍는 식으로 출력이 교차되고 실행 타이밍에 따라 순서가 조금씩 섞여 나타난다 즉 두 작업이 거의 동시에 진행되는 것처럼 보이지만 사실은 GIL과 sleep 호출에 의해 미세하게 번갈아 실행된다.</li></ul><p>mutliprocessing</p><ul><li>각 함수가 완전히 독립된 프로세스로 실행된다.</li><li>두 프로세스가 동시에 시작되더라도 실행 타이밍과 OS 스케줄링 우선순위 때문에 한 프로세스가 먼저 실행을 많이 진행하고 다른 프로세스가 뒤따라 실행되게되고 그 결과 숫자 1-5를 전부 찍고 난 후에 알파벳 A-E를 찍는 식으로, 출력이 묶음 단위로 나타나게 된다.</li></ul><p><del><em>사실잘모르겟다&mldr;어렵다,,,,</em></del></p><p>결론</p><ul><li>멀티스레딩은 하나의 프로세스 안에서 협력적으로 실행을 나누기 때문에 출력이 교차되거나 순서가 섞이기 쉽고, 멀티프로세싱은 프로세스 단위로 완전히 병렬 실행되지만 OS 스케줄링 특성상 한쪽이 먼저 실행을 마쳐 출력이 블록처럼 모이는 경우가 많다.</li></ul><h3><a class=anchor href=#>#</a></h3><p><mark>#4 MutClust에서 mutliprocessing 코드</mark></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_mutInfo</span>(target_dir, meta_df, savefilepath):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>exists(savefilepath):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> readPickle(savefilepath)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 병렬 처리를 위한 프로세스 풀 생성</span>
</span></span><span style=display:flex><span>    num_processes <span style=color:#f92672>=</span> <span style=color:#ae81ff>50</span>  <span style=color:#75715e># 병렬로 처리할 프로세스 수를 조정</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> Pool(num_processes) <span style=color:#66d9ef>as</span> pool:
</span></span><span style=display:flex><span>        mutInfo_files <span style=color:#f92672>=</span> [a <span style=color:#66d9ef>for</span> a <span style=color:#f92672>in</span> get_file_paths_recursive(target_dir) <span style=color:#66d9ef>if</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>basename(a)<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39;.&#39;</span>)[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>in</span> meta_df<span style=color:#f92672>.</span>index]
</span></span><span style=display:flex><span>        results <span style=color:#f92672>=</span> pool<span style=color:#f92672>.</span>map(process_mutInfo, mutInfo_files)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 결과를 딕셔너리로 변환</span>
</span></span><span style=display:flex><span>    seq_dict <span style=color:#f92672>=</span> {sid: mutInfo_df <span style=color:#66d9ef>for</span> sid, mutInfo_df <span style=color:#f92672>in</span> results}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    total_df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame()<span style=color:#f92672>.</span>from_dict(seq_dict)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    savePickle(savefilepath, total_df)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> total_df
</span></span></code></pre></div><p>MutClust 예전 utils 코드중에서 병렬처리 코드 있었던거같아서 찾아봣다</p><p>흐름은</p><ol><li>multiprocessing.Pool을 이용해 최대 50개의 프로세스를 동시에 실행할 수 있도록 풀을 생성</li><li>target_dir 디렉토리 내 파일이 meta_df의 인덱스 이름에 포함되어 있는 경우만 남겨서 mutInfo_files 생성</li><li>mutInfo_files를 pool.map(process_mutInfo, mutInfo_files)에 전달<ul><li>process_mutInfo: 병렬로 process_mutInfo 함수에 의해 처리(mutInfo_files를 읽고 sid, mutInfo_df 생성)</li></ul></li><li>key가 sid, 값이 mutInfo_df인 딕셔너리 seq_dict로 만들고 total_df로 정리</li></ol><p>결론</p><ul><li>변이 정보를 병렬 프로세스(50개)로 빠르게 처리하고 결과를 df로 정리해서 저장해놓고 썼다.</li><li>결과파일 저장해놓은뒤로 사용한적없어서 utils에서 빠진거같고 기억에서도 빠진것같다(..)</li></ul><h1><a class=anchor href=#>#</a></h1></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=yshghid/yshghid.github.io data-repo-id=R_kgDONkMkNg data-category-id=DIC_kwDONkMkNs4CloJh data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#1-객체지향-프로그래밍>1. 객체지향 프로그래밍</a></li><li></li><li></li><li></li><li></li><li></li><li><a href=#2-병렬처리>2. 병렬처리</a></li><li></li><li></li><li></li></ul></li></ul></nav></div></aside></main></body></html>
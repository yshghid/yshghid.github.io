<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="CNN #1 유전체 서열 분석하기 # #2026-02-27
0. 개요 # #1 CNN으로 유전체 서열 분석하기
DNA는 A, T, G, C 4개의 문자로 이루어진 긴 문자열이다. 이 문자열 어딘가에는 단백질이 달라붙는 자리(결합 부위)가 있고, 어딘가에는 RNA 간섭(RNAi)을 잘 일으키는 서열이 있다.
눈으로는 도저히 찾을 수 없다. 딥러닝으로 학습시키면?
유전체 서열 분석하는 3가지 실험을 한다:
실험 목표 문제 유형 1 전사인자 JUND가 결합하는 DNA 서열 예측 이진 분류 2 결합 예측 &#43; 크로마틴 접근성 추가 이진 분류 (다중 입력) 3 siRNA 서열의 유전자 침묵 효율 예측 회귀 # #2 DNA 서열을 컴퓨터에 입력하는 방법: 원-핫 인코딩 (One-Hot Encoding)">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/docs/study/dl/dl1-copy-2/">
  <meta property="og:site_name" content=" ">
  <meta property="og:title" content="CNN #1 유전체 서열 분석하기">
  <meta property="og:description" content="CNN #1 유전체 서열 분석하기 # #2026-02-27
0. 개요 # #1 CNN으로 유전체 서열 분석하기
DNA는 A, T, G, C 4개의 문자로 이루어진 긴 문자열이다. 이 문자열 어딘가에는 단백질이 달라붙는 자리(결합 부위)가 있고, 어딘가에는 RNA 간섭(RNAi)을 잘 일으키는 서열이 있다.
눈으로는 도저히 찾을 수 없다. 딥러닝으로 학습시키면?
유전체 서열 분석하는 3가지 실험을 한다:
실험 목표 문제 유형 1 전사인자 JUND가 결합하는 DNA 서열 예측 이진 분류 2 결합 예측 &#43; 크로마틴 접근성 추가 이진 분류 (다중 입력) 3 siRNA 서열의 유전자 침묵 효율 예측 회귀 # #2 DNA 서열을 컴퓨터에 입력하는 방법: 원-핫 인코딩 (One-Hot Encoding)">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">
    <meta property="article:published_time" content="2026-02-27T00:00:00+00:00">
    <meta property="article:modified_time" content="2026-02-27T00:00:00+00:00">
    <meta property="article:tag" content="2026-02">
<title>CNN #1 유전체 서열 분석하기 |  </title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="http://localhost:1313/docs/study/dl/dl1-copy-2/">
<link rel="stylesheet" href="/book.min.30a7836b6a89342da3b88e7afd1036166aeced16c8de12df060ded2031837886.css" integrity="sha256-MKeDa2qJNC2juI56/RA2Fmrs7RbI3hLfBg3tIDGDeIY=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.da30bdfefbea81bec60374fa6410eff6b04f4188414c6b6eb57e63c300fc3488.js" integrity="sha256-2jC9/vvqgb7GA3T6ZBDv9rBPQYhBTGtutX5jwwD8NIg=" crossorigin="anonymous"></script>

  

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/logo.png" alt="Logo" class="book-icon" /><span> </span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>















  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>기록</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/hobby/book/" class="">글</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/hobby/daily/" class="">일상</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>공부</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/study/ai/" class="">AI/Data</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/dl/" class="">DL</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/bioinformatics/" class="">Bioinformatics</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/be/" class="">BE</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/fe/" class="">FE</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/career/" class="">취업</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>CNN #1 유전체 서열 분석하기</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#0-개요">0. 개요</a></li>
        <li><a href="#heading"></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#1-실험1---전사인자-결합-부위-예측-tfbindingpy">1. 실험1 - 전사인자 결합 부위 예측 (<code>tfbinding.py</code>)</a></li>
        <li><a href="#heading-2"></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#2-실험2---크로마틴-접근성-추가-tfbinding_chromatinpy">2. 실험2 - 크로마틴 접근성 추가 (<code>tfbinding_chromatin.py</code>)</a></li>
        <li><a href="#heading-4"></a></li>
        <li><a href="#heading-5"></a></li>
        <li><a href="#heading-6"></a></li>
        <li><a href="#3-실험-3-rnai-효율-예측-rnaipy">3. 실험 3: RNAi 효율 예측 (<code>rnai.py</code>)</a></li>
        <li><a href="#heading-7"></a></li>
        <li><a href="#4-세-실험의-핵심-패턴-비교">4. 세 실험의 핵심 패턴 비교</a></li>
        <li><a href="#heading-8"></a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="cnn-1-유전체-서열-분석하기">
  CNN #1 유전체 서열 분석하기
  <a class="anchor" href="#cnn-1-%ec%9c%a0%ec%a0%84%ec%b2%b4-%ec%84%9c%ec%97%b4-%eb%b6%84%ec%84%9d%ed%95%98%ea%b8%b0">#</a>
</h1>
<p>#2026-02-27</p>
<hr>
<h3 id="0-개요">
  0. 개요
  <a class="anchor" href="#0-%ea%b0%9c%ec%9a%94">#</a>
</h3>
<p>#1 CNN으로 유전체 서열 분석하기</p>
<p>DNA는 A, T, G, C 4개의 문자로 이루어진 긴 문자열이다.
이 문자열 어딘가에는 단백질이 달라붙는 자리(결합 부위)가 있고,
어딘가에는 RNA 간섭(RNAi)을 잘 일으키는 서열이 있다.</p>
<p>눈으로는 도저히 찾을 수 없다. 딥러닝으로 학습시키면?</p>
<p>유전체 서열 분석하는 3가지 실험을 한다:</p>
<table>
<thead>
<tr>
<th>실험</th>
<th>목표</th>
<th>문제 유형</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>전사인자 JUND가 결합하는 DNA 서열 예측</td>
<td>이진 분류</td>
</tr>
<tr>
<td>2</td>
<td>결합 예측 + 크로마틴 접근성 추가</td>
<td>이진 분류 (다중 입력)</td>
</tr>
<tr>
<td>3</td>
<td>siRNA 서열의 유전자 침묵 효율 예측</td>
<td>회귀</td>
</tr>
</tbody>
</table>
<h3 id="heading">
  
  <a class="anchor" href="#heading">#</a>
</h3>
<p>#2 DNA 서열을 컴퓨터에 입력하는 방법: 원-핫 인코딩 (One-Hot Encoding)</p>
<p>DNA는 4개의 염기 A, T, G, C로 이루어져 있다.
이를 숫자로 표현하기 위해 원-핫 인코딩을 사용한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>A → [1, 0, 0, 0]
</span></span><span style="display:flex;"><span>C → [0, 1, 0, 0]
</span></span><span style="display:flex;"><span>G → [0, 0, 1, 0]
</span></span><span style="display:flex;"><span>T → [0, 0, 0, 1]
</span></span></code></pre></div><p>길이 101짜리 DNA 서열이라면 → <code>(101, 4)</code> 형태의 2D 배열이 된다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>ACGT... (101개 염기)
</span></span><span style="display:flex;"><span> ↓
</span></span><span style="display:flex;"><span>[[1,0,0,0],   ← A
</span></span><span style="display:flex;"><span> [0,1,0,0],   ← C
</span></span><span style="display:flex;"><span> [0,0,1,0],   ← G
</span></span><span style="display:flex;"><span> [0,0,0,1],   ← T
</span></span><span style="display:flex;"><span> ...          (총 101행)
</span></span><span style="display:flex;"><span>]
</span></span><span style="display:flex;"><span>shape: (101, 4)
</span></span></code></pre></div><p>왜 이렇게 하냐면 숫자로 1,2,3,4 로 표현하면 모델이 A와 T가 &ldquo;가깝다&quot;고 착각하는데 원-핫은 모든 염기를 동등하게 취급한다.</p>
<h1 id="heading-1">
  
  <a class="anchor" href="#heading-1">#</a>
</h1>
<h3 id="1-실험1---전사인자-결합-부위-예측-tfbindingpy">
  1. 실험1 - 전사인자 결합 부위 예측 (<code>tfbinding.py</code>)
  <a class="anchor" href="#1-%ec%8b%a4%ed%97%981---%ec%a0%84%ec%82%ac%ec%9d%b8%ec%9e%90-%ea%b2%b0%ed%95%a9-%eb%b6%80%ec%9c%84-%ec%98%88%ec%b8%a1-tfbindingpy">#</a>
</h3>
<p>전사인자(Transcription Factor, TF) 는 특정 DNA 서열에 달라붙어서 근처 유전자의 발현을 켜고 끄는 단백질이다.
JUND는 사람의 전사인자 중 하나다. JUND는 특정 DNA 서열 패턴(motif)에만 결합한다.
목표는 길이 101짜리 DNA 조각을 보고 JUND가 결합하는지(1) 아닌지(0)를 예측한다.</p>
<p>#1 데이터 구조</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>train_dataset/
</span></span><span style="display:flex;"><span>├── metadata.csv.gzip       ← 어떤 shard들이 있는지 목록
</span></span><span style="display:flex;"><span>├── shard-0-X.joblib        ← 입력 서열 (원-핫 인코딩된 DNA)
</span></span><span style="display:flex;"><span>├── shard-0-y.joblib        ← 정답 (0 또는 1)
</span></span><span style="display:flex;"><span>├── shard-0-w.joblib        ← 샘플 가중치
</span></span><span style="display:flex;"><span>├── shard-0-ids.joblib      ← 샘플 ID (예: chr22:20208963-20209064)
</span></span><span style="display:flex;"><span>└── tasks.json              ← [0] (태스크 인덱스)
</span></span></code></pre></div><p>ID 형식 <code>chr22:20208963-20209064</code>의 의미:</p>
<ul>
<li><code>chr22</code> → 22번 염색체</li>
<li><code>20208963-20209064</code> → 시작~끝 위치 (101 bp 구간)</li>
</ul>
<h3 id="heading-2">
  
  <a class="anchor" href="#heading-2">#</a>
</h3>
<p>#2 모델 구조 설명</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>features <span style="color:#f92672">=</span> tf<span style="color:#f92672">.</span>keras<span style="color:#f92672">.</span>Input(shape<span style="color:#f92672">=</span>(<span style="color:#ae81ff">101</span>, <span style="color:#ae81ff">4</span>))
</span></span></code></pre></div><p>입력: 길이 101짜리 DNA 서열, 원-핫 인코딩 → shape <code>(101, 4)</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">3</span>):
</span></span><span style="display:flex;"><span>    prev <span style="color:#f92672">=</span> layers<span style="color:#f92672">.</span>Conv1D(filters<span style="color:#f92672">=</span><span style="color:#ae81ff">15</span>, kernel_size<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, activation<span style="color:#f92672">=</span>tf<span style="color:#f92672">.</span>nn<span style="color:#f92672">.</span>relu, padding<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;same&#39;</span>)(prev)
</span></span><span style="display:flex;"><span>    prev <span style="color:#f92672">=</span> layers<span style="color:#f92672">.</span>Dropout(rate<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>)(prev)
</span></span></code></pre></div><p>Conv1D (1차원 합성곱 레이어)가 핵심이다.</p>
<p>Conv1D를 직관적으로 이해하기: 이미지 처리에서 Conv2D는 <code>(높이, 너비)</code> 방향으로 필터를 움직인다.
DNA 서열은 1차원이므로 Conv1D는 서열을 따라 필터가 슬라이딩한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>DNA 서열 (길이 101):
</span></span><span style="display:flex;"><span>[A][C][G][T][A][G][C][T][G][A]...(101개)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>kernel_size=10 필터가 10칸씩 훑는다:
</span></span><span style="display:flex;"><span>┌──────────┐
</span></span><span style="display:flex;"><span>[A][C][G][T][A][G][C][T][G][A]  → 하나의 값 출력
</span></span><span style="display:flex;"><span>   ┌──────────┐
</span></span><span style="display:flex;"><span>   [C][G][T][A][G][C][T][G][A][C] → 하나의 값 출력
</span></span><span style="display:flex;"><span>      ┌──────────┐
</span></span><span style="display:flex;"><span>      ...
</span></span></code></pre></div><ul>
<li><code>filters=15</code>: 필터 15개 → 15가지 다른 서열 패턴을 동시에 탐지</li>
<li><code>kernel_size=10</code>: 한 번에 10개 염기를 보는 창(window)</li>
<li><code>padding='same'</code>: 출력 길이 = 입력 길이 유지</li>
</ul>
<p>각 필터는 특정 10bp 모티프(예: JUND 결합 모티프 <code>TGACTCA</code>)를 인식하는 탐지기가 된다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>layers<span style="color:#f92672">.</span>Dropout(rate<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>)
</span></span></code></pre></div><p>Dropout: 학습할 때 랜덤하게 50%의 뉴런을 끈다. 이렇게하는 이유는 특정 패턴에만 과도하게 의존하지 않도록 방지 (과적합 방지)를 위해서다.  3개 레이어 × 15 필터를 통해 점점 더 복잡한 패턴을 학습하게된다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>logits <span style="color:#f92672">=</span> layers<span style="color:#f92672">.</span>Dense(units<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)(layers<span style="color:#f92672">.</span>Flatten()(prev))
</span></span><span style="display:flex;"><span>output <span style="color:#f92672">=</span> layers<span style="color:#f92672">.</span>Activation(tf<span style="color:#f92672">.</span>math<span style="color:#f92672">.</span>sigmoid)(logits)
</span></span><span style="display:flex;"><span>keras_model <span style="color:#f92672">=</span> tf<span style="color:#f92672">.</span>keras<span style="color:#f92672">.</span>Model(inputs<span style="color:#f92672">=</span>features, outputs<span style="color:#f92672">=</span>[output, logits])
</span></span></code></pre></div><p>Flatten: <code>(101, 15)</code> 형태의 특징 맵을 <code>(1515,)</code> 벡터로 펼친다.</p>
<p>Dense(1): 1515개의 특징을 하나의 숫자(logit)로 압축.</p>
<p>Sigmoid: logit을 0~1 사이 확률로 변환.</p>
<pre tabindex="0"><code>sigmoid(x) = 1 / (1 + e^(-x))
</code></pre><p>왜 logit과 output 둘 다 출력하나?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>outputs<span style="color:#f92672">=</span>[output, logits]
</span></span><span style="display:flex;"><span>output_types<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#39;prediction&#39;</span>, <span style="color:#e6db74">&#39;loss&#39;</span>]
</span></span></code></pre></div><ul>
<li><code>prediction</code>: sigmoid 적용한 확률값 → 평가에 사용</li>
<li><code>loss</code>: sigmoid 적용 전 raw logit → 손실 계산에 사용</li>
</ul>
<p>이유: <code>SigmoidCrossEntropy()</code> 손실 함수는 수치 안정성을 위해 내부적으로 sigmoid를 적용하므로, logit을 직접 받아야 한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>model <span style="color:#f92672">=</span> dc<span style="color:#f92672">.</span>models<span style="color:#f92672">.</span>KerasModel(
</span></span><span style="display:flex;"><span>    keras_model,
</span></span><span style="display:flex;"><span>    loss<span style="color:#f92672">=</span>dc<span style="color:#f92672">.</span>models<span style="color:#f92672">.</span>losses<span style="color:#f92672">.</span>SigmoidCrossEntropy(),
</span></span><span style="display:flex;"><span>    output_types<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#39;prediction&#39;</span>, <span style="color:#e6db74">&#39;loss&#39;</span>],
</span></span><span style="display:flex;"><span>    batch_size<span style="color:#f92672">=</span><span style="color:#ae81ff">1000</span>,
</span></span><span style="display:flex;"><span>    model_dir<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;tf&#39;</span>)
</span></span></code></pre></div><p>DeepChem의 KerasModel 래퍼: Keras 모델을 DeepChem의 데이터 파이프라인과 연결해준다.</p>
<p>SigmoidCrossEntropy (이진 교차 엔트로피):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>Loss = -[y·log(p) + (1-y)·log(1-p)]
</span></span></code></pre></div><ul>
<li>y=1(결합): p가 클수록 손실 감소</li>
<li>y=0(비결합): p가 작을수록 손실 감소</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>metric <span style="color:#f92672">=</span> dc<span style="color:#f92672">.</span>metrics<span style="color:#f92672">.</span>Metric(dc<span style="color:#f92672">.</span>metrics<span style="color:#f92672">.</span>roc_auc_score)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">20</span>):
</span></span><span style="display:flex;"><span>    model<span style="color:#f92672">.</span>fit(train, nb_epoch<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>    print(model<span style="color:#f92672">.</span>evaluate(train, [metric]))
</span></span><span style="display:flex;"><span>    print(model<span style="color:#f92672">.</span>evaluate(valid, [metric]))
</span></span></code></pre></div><p>ROC-AUC로 평가한다.</p>
<p>ROC-AUC는</p>
<ul>
<li>랜덤 분류기 = 0.5</li>
<li>완벽한 분류기 = 1.0</li>
<li>&ldquo;임의로 고른 양성 샘플의 예측 확률이 임의로 고른 음성 샘플보다 높을 확률&rdquo;</li>
</ul>
<p>총 200 에포크(20 반복 × 10 에포크) 학습하면서 매 10 에포크마다 성능을 출력함.</p>
<h1 id="heading-3">
  
  <a class="anchor" href="#heading-3">#</a>
</h1>
<h3 id="2-실험2---크로마틴-접근성-추가-tfbinding_chromatinpy">
  2. 실험2 - 크로마틴 접근성 추가 (<code>tfbinding_chromatin.py</code>)
  <a class="anchor" href="#2-%ec%8b%a4%ed%97%982---%ed%81%ac%eb%a1%9c%eb%a7%88%ed%8b%b4-%ec%a0%91%ea%b7%bc%ec%84%b1-%ec%b6%94%ea%b0%80-tfbinding_chromatinpy">#</a>
</h3>
<p>왜 크로마틴 접근성이 중요한가?</p>
<p>DNA는 히스톤 단백질에 감겨 크로마틴이라는 구조를 이룬다.
꽉 감긴 DNA는 전사인자가 접근할 수 없다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>열린 크로마틴 (Open):   ====○====  ← TF 접근 가능, 결합 가능성 높음
</span></span><span style="display:flex;"><span>닫힌 크로마틴 (Closed): ████████  ← TF 접근 불가, 결합 가능성 낮음
</span></span></code></pre></div><p><code>accessibility.txt</code> 파일:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>chr22:20208963-20209064    0.003902
</span></span><span style="display:flex;"><span>chr22:29673572-29673673    0.004378
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>각 DNA 구간의 크로마틴 접근성 수치 (ATAC-seq 등으로 측정한 값).</p>
<h3 id="heading-4">
  
  <a class="anchor" href="#heading-4">#</a>
</h3>
<p>#1 모델 구조: 두 개의 입력</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>features <span style="color:#f92672">=</span> tf<span style="color:#f92672">.</span>keras<span style="color:#f92672">.</span>Input(shape<span style="color:#f92672">=</span>(<span style="color:#ae81ff">101</span>, <span style="color:#ae81ff">4</span>))       <span style="color:#75715e"># DNA 서열</span>
</span></span><span style="display:flex;"><span>accessibility <span style="color:#f92672">=</span> tf<span style="color:#f92672">.</span>keras<span style="color:#f92672">.</span>Input(shape<span style="color:#f92672">=</span>(<span style="color:#ae81ff">1</span>,))       <span style="color:#75715e"># 크로마틴 접근성 스칼라</span>
</span></span></code></pre></div><p>DNA 서열 부분은 동일:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">3</span>):
</span></span><span style="display:flex;"><span>    prev <span style="color:#f92672">=</span> layers<span style="color:#f92672">.</span>Conv1D(filters<span style="color:#f92672">=</span><span style="color:#ae81ff">15</span>, kernel_size<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, activation<span style="color:#f92672">=</span>tf<span style="color:#f92672">.</span>nn<span style="color:#f92672">.</span>relu, padding<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;same&#39;</span>)(prev)
</span></span><span style="display:flex;"><span>    prev <span style="color:#f92672">=</span> layers<span style="color:#f92672">.</span>Dropout(rate<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>)(prev)
</span></span></code></pre></div><p>핵심 변경: 두 입력을 합치기 (Concatenate):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>prev <span style="color:#f92672">=</span> layers<span style="color:#f92672">.</span>Concatenate()([layers<span style="color:#f92672">.</span>Flatten()(prev), accessibility])
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>Conv1D 출력 Flatten → (1515,)
</span></span><span style="display:flex;"><span>                              ┐
</span></span><span style="display:flex;"><span>                              ├── Concatenate → (1516,)
</span></span><span style="display:flex;"><span>크로마틴 접근성 스칼라 → (1,) ┘
</span></span></code></pre></div><p>이제 Dense 레이어가 서열 특징 1515개 + 접근성 1개를 함께 보고 결합 여부를 판단한다.</p>
<p>왜 이 방식이 효과적인가? 서열만 봐서는 결합 가능한 모티프지만, 크로마틴이 닫혀있으면 결합을 못한다. 크로마틴 정보를 마지막에 합치면 모델이 &ldquo;서열 좋고 + 열려있으면 결합&quot;을 학습할 수 있다.</p>
<h3 id="heading-5">
  
  <a class="anchor" href="#heading-5">#</a>
</h3>
<p>#2 커스텀 배치 생성기</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>span_accessibility <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> line <span style="color:#f92672">in</span> open(<span style="color:#e6db74">&#39;accessibility.txt&#39;</span>):
</span></span><span style="display:flex;"><span>    fields <span style="color:#f92672">=</span> line<span style="color:#f92672">.</span>split()
</span></span><span style="display:flex;"><span>    span_accessibility[fields[<span style="color:#ae81ff">0</span>]] <span style="color:#f92672">=</span> float(fields[<span style="color:#ae81ff">1</span>])
</span></span></code></pre></div><p>접근성 딕셔너리 만들기:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;chr22:20208963-20209064&#34;</span>: <span style="color:#ae81ff">0.003902</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;chr22:29673572-29673673&#34;</span>: <span style="color:#ae81ff">0.004378</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">generate_batches</span>(dataset, epochs):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> epoch <span style="color:#f92672">in</span> range(epochs):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> X, y, w, ids <span style="color:#f92672">in</span> dataset<span style="color:#f92672">.</span>iterbatches(batch_size<span style="color:#f92672">=</span><span style="color:#ae81ff">1000</span>, pad_batches<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">yield</span> ([X, np<span style="color:#f92672">.</span>array([span_accessibility[id] <span style="color:#66d9ef">for</span> id <span style="color:#f92672">in</span> ids])], [y], [w])
</span></span></code></pre></div><p>제너레이터 함수를 사용한다. 이유:</p>
<ol>
<li>표준 <code>model.fit()</code>은 입력이 하나라고 가정</li>
<li>DNA 서열(X)과 접근성을 함께 묶어서 <code>[X, accessibility_array]</code> 형태로 모델에 전달</li>
<li>배치마다 해당 구간 ID로 접근성 딕셔너리를 조회</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> X, y, w, ids <span style="color:#f92672">in</span> dataset<span style="color:#f92672">.</span>iterbatches(batch_size<span style="color:#f92672">=</span><span style="color:#ae81ff">1000</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ids = [&#34;chr22:20208963-20209064&#34;, &#34;chr22:29673572-29673673&#34;, ...]</span>
</span></span><span style="display:flex;"><span>    accessibility_batch <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([span_accessibility[id] <span style="color:#66d9ef">for</span> id <span style="color:#f92672">in</span> ids])
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># accessibility_batch = [0.003902, 0.004378, ...]  shape: (1000,)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">yield</span> ([X, accessibility_batch], [y], [w])
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#       ↑ 두 입력    ↑ 정답  ↑ 가중치</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">20</span>):
</span></span><span style="display:flex;"><span>    model<span style="color:#f92672">.</span>fit_generator(generate_batches(train, epochs<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>))
</span></span><span style="display:flex;"><span>    print(model<span style="color:#f92672">.</span>evaluate_generator(generate_batches(train, <span style="color:#ae81ff">1</span>), [metric]))
</span></span><span style="display:flex;"><span>    print(model<span style="color:#f92672">.</span>evaluate_generator(generate_batches(valid, <span style="color:#ae81ff">1</span>), [metric]))
</span></span></code></pre></div><p><code>fit_generator</code> / <code>evaluate_generator</code>: 제너레이터에서 배치를 받아 학습/평가.</p>
<h3 id="heading-6">
  
  <a class="anchor" href="#heading-6">#</a>
</h3>
<h3 id="3-실험-3-rnai-효율-예측-rnaipy">
  3. 실험 3: RNAi 효율 예측 (<code>rnai.py</code>)
  <a class="anchor" href="#3-%ec%8b%a4%ed%97%98-3-rnai-%ed%9a%a8%ec%9c%a8-%ec%98%88%ec%b8%a1-rnaipy">#</a>
</h3>
<p>#1 RNA 간섭(RNAi)이란?</p>
<p>세포 안에 짧은 RNA 서열(siRNA, 21개 염기)을 넣으면 특정 mRNA를 분해해서 단백질 생산을 막을 수 있다. → 유전자 침묵(gene silencing)</p>
<p>문제: 모든 siRNA 서열이 효과적이지 않다. 어떤 서열이 잘 작동하는지 예측할 수 있을까?</p>
<pre tabindex="0"><code>siRNA: 21개 염기 서열
목표: 유전자 침묵 효율 (0~1 사이 연속값, 높을수록 좋음)
→ 회귀 문제
</code></pre><p>#2 모델 구조</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>features <span style="color:#f92672">=</span> tf<span style="color:#f92672">.</span>keras<span style="color:#f92672">.</span>Input(shape<span style="color:#f92672">=</span>(<span style="color:#ae81ff">21</span>, <span style="color:#ae81ff">4</span>))
</span></span></code></pre></div><p>입력: 길이 21짜리 siRNA, 원-핫 인코딩 → shape <code>(21, 4)</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span>):
</span></span><span style="display:flex;"><span>    prev <span style="color:#f92672">=</span> layers<span style="color:#f92672">.</span>Conv1D(filters<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, kernel_size<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, activation<span style="color:#f92672">=</span>tf<span style="color:#f92672">.</span>nn<span style="color:#f92672">.</span>relu, padding<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;same&#39;</span>)(prev)
</span></span><span style="display:flex;"><span>    prev <span style="color:#f92672">=</span> layers<span style="color:#f92672">.</span>Dropout(rate<span style="color:#f92672">=</span><span style="color:#ae81ff">0.3</span>)(prev)
</span></span></code></pre></div><p>tfbinding 대비 차이점:</p>
<table>
<thead>
<tr>
<th></th>
<th>tfbinding</th>
<th>rnai</th>
</tr>
</thead>
<tbody>
<tr>
<td>입력 길이</td>
<td>101 bp</td>
<td>21 bp</td>
</tr>
<tr>
<td>Conv 레이어 수</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>필터 수</td>
<td>15</td>
<td>10</td>
</tr>
<tr>
<td>Dropout 비율</td>
<td>0.5</td>
<td>0.3</td>
</tr>
<tr>
<td>출력</td>
<td>이진 분류</td>
<td>회귀</td>
</tr>
</tbody>
</table>
<p>서열이 짧고(21bp) 문제가 단순하므로 더 작은 모델을 사용한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>output <span style="color:#f92672">=</span> layers<span style="color:#f92672">.</span>Dense(units<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, activation<span style="color:#f92672">=</span>tf<span style="color:#f92672">.</span>math<span style="color:#f92672">.</span>sigmoid)(layers<span style="color:#f92672">.</span>Flatten()(prev))
</span></span></code></pre></div><p>Sigmoid 활성화: 출력을 0<del>1 사이로 제한. 효율은 0</del>1 범위이므로 적절.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>model <span style="color:#f92672">=</span> dc<span style="color:#f92672">.</span>models<span style="color:#f92672">.</span>KerasModel(
</span></span><span style="display:flex;"><span>    keras_model,
</span></span><span style="display:flex;"><span>    loss<span style="color:#f92672">=</span>dc<span style="color:#f92672">.</span>models<span style="color:#f92672">.</span>losses<span style="color:#f92672">.</span>L2Loss(),   <span style="color:#75715e"># ← 회귀 손실!</span>
</span></span><span style="display:flex;"><span>    batch_size<span style="color:#f92672">=</span><span style="color:#ae81ff">1000</span>,
</span></span><span style="display:flex;"><span>    model_dir<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;rnai&#39;</span>)
</span></span></code></pre></div><p>L2Loss (MSE, 평균 제곱 오차):</p>
<pre tabindex="0"><code>Loss = (예측값 - 실제값)²
</code></pre><p>분류가 아니라 연속값 예측이므로 L2 손실 사용.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>metric <span style="color:#f92672">=</span> dc<span style="color:#f92672">.</span>metrics<span style="color:#f92672">.</span>Metric(dc<span style="color:#f92672">.</span>metrics<span style="color:#f92672">.</span>pearsonr, mode<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;regression&#39;</span>)
</span></span></code></pre></div><p>피어슨 상관계수(r)로 평가:</p>
<ul>
<li>예측값과 실제값 사이의 선형 상관관계</li>
<li>-1 ~ 1 범위, 1에 가까울수록 좋음</li>
<li>분류 문제의 ROC-AUC에 대응하는 회귀 평가지표</li>
</ul>
<h3 id="heading-7">
  
  <a class="anchor" href="#heading-7">#</a>
</h3>
<h3 id="4-세-실험의-핵심-패턴-비교">
  4. 세 실험의 핵심 패턴 비교
  <a class="anchor" href="#4-%ec%84%b8-%ec%8b%a4%ed%97%98%ec%9d%98-%ed%95%b5%ec%8b%ac-%ed%8c%a8%ed%84%b4-%eb%b9%84%ea%b5%90">#</a>
</h3>
<p>#1 공통 구조 (Conv1D 기반 DNA 분석기)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>DNA 서열 (원-핫 인코딩)
</span></span><span style="display:flex;"><span>      ↓
</span></span><span style="display:flex;"><span>Conv1D → ReLU → Dropout   ← 로컬 모티프 탐지
</span></span><span style="display:flex;"><span>      ↓
</span></span><span style="display:flex;"><span>Conv1D → ReLU → Dropout   ← 복합 패턴 학습
</span></span><span style="display:flex;"><span>      ↓
</span></span><span style="display:flex;"><span> [Conv1D → ReLU → Dropout] ← (선택적 추가 레이어)
</span></span><span style="display:flex;"><span>      ↓
</span></span><span style="display:flex;"><span>   Flatten
</span></span><span style="display:flex;"><span>      ↓
</span></span><span style="display:flex;"><span>[+ 크로마틴 접근성]         ← (실험 2만 해당)
</span></span><span style="display:flex;"><span>      ↓
</span></span><span style="display:flex;"><span>   Dense(1)
</span></span><span style="display:flex;"><span>      ↓
</span></span><span style="display:flex;"><span>  Sigmoid → 출력
</span></span></code></pre></div><p>#2 Conv1D가 DNA 분석에 적합한 이유</p>
<ol>
<li><strong>위치 불변성(Translation Invariance)</strong>: JUND 결합 모티프가 서열의 어느 위치에 있든 탐지 가능</li>
<li><strong>파라미터 공유</strong>: 같은 필터를 서열 전체에 적용 → 메모리 효율적</li>
<li><strong>지역성(Locality)</strong>: DNA 모티프는 보통 5~15 bp → kernel_size=10이 적절</li>
</ol>
<p>#3 손실 함수 선택 기준</p>
<table>
<thead>
<tr>
<th>문제 유형</th>
<th>손실 함수</th>
<th>평가 지표</th>
</tr>
</thead>
<tbody>
<tr>
<td>이진 분류 (TF 결합)</td>
<td>SigmoidCrossEntropy</td>
<td>ROC-AUC</td>
</tr>
<tr>
<td>회귀 (RNAi 효율)</td>
<td>L2Loss (MSE)</td>
<td>Pearson r</td>
</tr>
</tbody>
</table>
<h3 id="heading-8">
  
  <a class="anchor" href="#heading-8">#</a>
</h3>
<p>#cf</p>
<p>데이터 흐름 전체 그림</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>[DiskDataset 구조]
</span></span><span style="display:flex;"><span> shard-0-X.joblib    → DNA 서열 (원-핫, shape: N×101×4 또는 N×21×4)
</span></span><span style="display:flex;"><span> shard-0-y.joblib    → 정답 (결합 여부 0/1 또는 효율 0~1)
</span></span><span style="display:flex;"><span> shard-0-w.joblib    → 샘플 가중치
</span></span><span style="display:flex;"><span> shard-0-ids.joblib  → 게놈 좌표 (예: chr22:20208963-20209064)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>         ↓ 배치 단위로 로드 (batch_size=1000)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[모델 입력]
</span></span><span style="display:flex;"><span> 실험 1, 3: X만 입력
</span></span><span style="display:flex;"><span> 실험 2: [X, accessibility] 입력 (커스텀 제너레이터)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>         ↓ Conv1D × 2~3 → Flatten → Dense(1) → Sigmoid
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[출력]
</span></span><span style="display:flex;"><span> 실험 1, 2: 결합 확률 (0~1)
</span></span><span style="display:flex;"><span> 실험 3: RNAi 효율 (0~1)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>         ↓ 200 에포크 학습 (20반복 × 10에포크)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[평가]
</span></span><span style="display:flex;"><span> 실험 1, 2: ROC-AUC
</span></span><span style="display:flex;"><span> 실험 3: Pearson r
</span></span></code></pre></div><p>#cf2 모델링 핵심 요약</p>
<ol>
<li><strong>DNA 서열 → 원-핫 인코딩</strong> → Conv1D 모델에 입력 가능한 형태로 변환</li>
<li><strong>Conv1D</strong> 는 DNA 모티프(결합 패턴)를 탐지하는 슬라이딩 필터 역할</li>
<li><strong>다중 입력 모델</strong> (실험 2)은 Concatenate로 서열 특징과 외부 정보를 결합</li>
<li><strong>커스텀 제너레이터</strong> 는 표준 데이터셋에 없는 추가 정보를 배치마다 주입</li>
<li><strong>손실 함수와 평가지표</strong> 는 분류/회귀에 따라 다르게 선택</li>
</ol>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments"><script src="https://giscus.app/client.js"
        data-repo="yshghid/yshghid.github.io"
        data-repo-id="R_kgDONkMkNg"
        data-category-id="DIC_kwDONkMkNs4CloJh"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="ko"
        crossorigin="anonymous"
        async>
</script>
</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#0-개요">0. 개요</a></li>
        <li><a href="#heading"></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#1-실험1---전사인자-결합-부위-예측-tfbindingpy">1. 실험1 - 전사인자 결합 부위 예측 (<code>tfbinding.py</code>)</a></li>
        <li><a href="#heading-2"></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#2-실험2---크로마틴-접근성-추가-tfbinding_chromatinpy">2. 실험2 - 크로마틴 접근성 추가 (<code>tfbinding_chromatin.py</code>)</a></li>
        <li><a href="#heading-4"></a></li>
        <li><a href="#heading-5"></a></li>
        <li><a href="#heading-6"></a></li>
        <li><a href="#3-실험-3-rnai-효율-예측-rnaipy">3. 실험 3: RNAi 효율 예측 (<code>rnai.py</code>)</a></li>
        <li><a href="#heading-7"></a></li>
        <li><a href="#4-세-실험의-핵심-패턴-비교">4. 세 실험의 핵심 패턴 비교</a></li>
        <li><a href="#heading-8"></a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>













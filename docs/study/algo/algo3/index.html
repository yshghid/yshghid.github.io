<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  MutClust 코드 리팩토링 #3 utils.py
  #

#2025-07-31

MutClust 알고리즘의 코드 구성은 아래와 같은데
MutClust
└── sc/
     └── lib.py 
     └── arg_parser.py
     └── utils.py // 분석 함수
utils.py는 시각화, 필터링등 분석 보조 함수를 포함한다.
# === utils.py ===
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.transforms
import matplotlib.patches
from pandas import read_csv

HSCORE = 'H-score'
POS = 'Position'
FREQ = 'Frequency'
PER = 'Percentage'
ENT = 'Entropy'
NUCLEOTIDE_ANNOTATION_PATH = '/data3/projects/2020_MUTCLUST/paper/example_data/input/covid_annotation.tsv'

def mutation_filtering(df):
    return df[(df[POS] >= 266) & (df[POS] <= 29674)].reset_index(drop=True)

def get_GeneInfo_df():
    return read_csv(NUCLEOTIDE_ANNOTATION_PATH, sep='\t')
import os
from collections import Counter
from multiprocessing import Pool, Process, Manager
from os.path import join
from pathlib import Path

import numpy as np
import pandas as pd
from pandas import read_csv, DataFrame, concat, Series
from scipy.stats import entropy

from Bin.Utils.utils import *  # NOTE: 반드시 환경에 맞게 경로 수정 필요

# 전역 참조 염기서열 로드
ref_seq = getNucleotideRefSeq()

# =========================
# 1. Codon / Nucleotide Sequence 불러오기
# =========================

def get_codon_sequence_dict(path='./data/codon_data/codon_sequence'):
    seq_dict = {}
    for file in get_filenames_list(path):
        df = read_csv(join(path, file), index_col=0)
        name = file.split('.')[0]
        seq_dict[name] = dict(zip(df['gene'], df['sequence']))
    return seq_dict

def get_nucleotide_sequence_dict(seq_dir):
    seq_dict = {}
    for file in get_filenames_list(seq_dir):
        df = read_csv(join(seq_dir, file), index_col=0).reset_index(drop=True)
        name = file.split('.')[0]
        seq_dict[name] = df
    return seq_dict

# =========================
# 2. Reference 정보
# =========================

def getCodonRefSeqbyGene():
    return pd.read_csv('/data3/projects/2020_MUTCLUST/Data/Annotation/Codon/Reference/new_reference_codon.csv', index_col=0)

def getNucleotideRefSeqbyGene():
    return pd.read_csv('/data3/projects/2020_MUTCLUST/Data/Annotation/Nucleotide/covid_annotation.tsv', sep=' ')

def getStartDict():
    ref = getCodonRefSeqbyGene()
    return dict(zip(ref['gene'], ref['start']))

# =========================
# 3. Codon 입력 데이터 생성
# =========================

def getTotal_df(seq_dict, start=1, gene=None):
    total_list, name_list = [], []
    for name, seq_by_gene_dict in seq_dict.items():
        seq = seq_by_gene_dict[gene]
        total_list.append(list(seq))
        name_list.append(name)
    total_df = DataFrame(total_list, index=name_list)
    total_df.columns = [i + start for i in range(len(total_df.columns))]
    return total_df

def make_codon_input(gene, seq_dict, ref_seq, out_dir):
    start_dict = getStartDict()
    total_df = getTotal_df(seq_dict, start=start_dict[gene], gene=gene)

    records = []
    for i, pos in enumerate(total_df.columns):
        freq = total_df[pos].value_counts()
        p = freq / freq.sum()
        ref_amino = ref_seq[i]
        freq.drop(index=ref_amino, inplace=True, errors='ignore')
        p.drop(index=ref_amino, inplace=True, errors='ignore')
        if len(freq) > 0:
            entropy_val = -np.sum(p * np.log2(p))
            records.append((int(pos) + 1, freq.sum(), p.sum(), entropy_val))

    input_df = DataFrame(records, columns=['Position', 'Frequency', 'Percentages', 'Entropy'])
    Path(out_dir).mkdir(parents=True, exist_ok=True)
    input_df.to_csv(join(out_dir, f'{gene}.input.tsv'), sep='\t', index=False)
    return input_df

def make_input_by_gene(severity, seq_dict, ref_df):
    out_dir = f'./input/{severity}_{len(seq_dict)}/'
    Path(out_dir).mkdir(parents=True, exist_ok=True)
    input_dfs = []
    for gene in GENE_LIST:
        print(f'Gene: {gene}')
        ref_seq = ref_df[ref_df['gene'] == gene]['sequence'].iloc[0]
        input_df = make_codon_input(gene, seq_dict, ref_seq, out_dir)
        input_dfs.append(input_df)
    whole_df = concat(input_dfs).astype({&#34;Position&#34;: int, &#34;Frequency&#34;: int})
    whole_df.to_csv(join(out_dir, 'whole.input.tsv'), sep='\t', index=False)
    return whole_df

def make_codon_mutclust_input():
    seq_dict = get_codon_sequence_dict()
    ref = getCodonRefSeqbyGene()
    make_input_by_gene('whole', seq_dict, ref)

# =========================
# 4. 병렬 처리 유틸
# =========================

def multi_processing(func, parameter_list, core_n=100):
    proc, proc_exec, proc_end = [], [], []
    for param in parameter_list:
        proc.append(Process(target=func, args=param))

    while proc or proc_exec:
        for _ in range(min(core_n - len(proc_exec), len(proc))):
            p = proc.pop(0)
            p.start()
            proc_exec.append(p)

        for p in proc_exec[:]:
            if not p.is_alive():
                proc_exec.remove(p)
                proc_end.append(p)
                p.join()
                p.close()

# =========================
# 5. 보조 기능들 추가
# =========================

def add_HSCORE():
    path = join(MUTCLUST_INPUT_DIR, 'gisaid_mutclust_input.tsv')
    new_path = join(MUTCLUST_INPUT_DIR, 'gisaid_mutclust_input_with_score.tsv')
    df = pd.read_csv(path, sep='\t')
    df[HSCORE] = df[PER] * df[ENT]
    df.to_csv(new_path, sep='\t', index=False)

def make_codon_annotation(outdir):
    ref_df = getCodonRefSeqbyGene()
    ano_df = ref_df.drop(columns=['sequence'])
    ano_df.to_csv(join(outdir, 'codon_annotation.tsv'), sep='\t', index=False)

def make_clade_divide_mutation():
    clade_dir = './clade_divide_mutation'
    file_list = get_filenames_list(clade_dir)
    start_dict = getStartDict()
    for file in file_list:
        df = read_csv(join(clade_dir, file), sep='\t')
        print(df)

# =========================
# 6. Mutation Info 처리 및 Matrix 생성
# =========================

def read_thead(filepathlist, return_list, i):
    ref_seq_sr = getNucleotideRefSeq()
    sub_dict = {pos: Counter({k: 0 for k in IUPAC_CODES.keys()}) for pos in ref_seq_sr.index}

    for filepath in filepathlist:
        df = read_csv(filepath, index_col=0).fillna('').reset_index(drop=True)
        for index, mut in enumerate(df['mut']):
            symbol = mut if mut != '' else ref_seq_sr[index + 1]
            sub_dict[index + 1][symbol] += 1

    return_list.append(sub_dict)
    print(f'{i}th process complete!')

def merge_thread(poslist, sub_dict_list, return_dict):
    for pos in poslist:
        merged_dict = {k: 0 for k in IUPAC_CODES.keys()}
        count_dict = sum([a[pos] for a in sub_dict_list], Counter())
        for k, v in count_dict.items():
            merged_dict[k] = v
        return_dict[pos] = merged_dict

def load_mutationinfo(input_dir=COVID19_MUTATIONINFO_DIR, sample_list=None):
    core_n = 100
    split_n = 1000
    sub_dict_list = Manager().list()

    filelist = get_file_paths_recursive(input_dir)
    if sample_list is not None:
        filelist = [f for f in filelist if os.path.basename(f).split('.')[0] in sample_list]
    splited_filepaths = array_split(filelist, split_n)
    parameter_list = [(chunk, sub_dict_list, i) for i, chunk in enumerate(splited_filepaths)]

    print('read thread start!')
    multi_processing(read_thead, parameter_list, core_n)
    print('read thread end!')

    merged_dict = Manager().dict()
    poslist = ref_seq.index
    splited_positions = array_split(poslist, split_n)
    parameter_list = [(chunk, list(sub_dict_list), merged_dict) for chunk in splited_positions]

    print('merge thread start!')
    multi_processing(merge_thread, parameter_list, core_n)
    print('merge thread end!')

    return dict(merged_dict)

def make_matrix_thread(file_list):
    clusters_file_path = join(GISAID_MUTCLUST_OUTPUT_DIR, 'clusters_hscore.txt')
    clusters_df = pd.read_csv(clusters_file_path, sep='\t')
    column_list = [
        f&#34;c{i}({row['left_position']},{row['right_position']})&#34;
        for i, row in clusters_df.iterrows()
    ]
    cluster_df = pd.DataFrame(columns=column_list)

    for mutation_path in file_list:
        patient_df = pd.read_csv(mutation_path)
        patient_name = os.path.basename(mutation_path).split('.')[0]
        cluster_df.loc[patient_name] = 0
        for i in patient_df[patient_df['mut'].notnull()]['pos']:
            matched = clusters_df[(clusters_df['left_position'] <= i) & (i <= clusters_df['right_position'])].index
            cluster_df.loc[patient_name][matched] += 1

    return cluster_df

def make_matrix(mutationinfo_dir, out_dir, tag, cpu_n=60):
    print('starting make matrix!')
    pool = Pool(processes=cpu_n)
    file_list = get_file_paths_recursive(mutationinfo_dir)
    file_chunks = array_split(file_list, cpu_n)
    results = pool.map(make_matrix_thread, file_chunks)
    merged_df = pd.concat(results)
    merged_df.to_csv(join(out_dir, f'cluster_matrix_{tag}.csv'))
    pool.close()
    pool.join()
    print(merged_df)

# =========================
# 7. 실행 예시 (main)
# =========================

if __name__ == '__main__':
    make_codon_mutclust_input()


# =========================
# 8. FASTA → CSV 변환 및 Nucleotide 기반 MutClust 입력
# =========================

def fasta2csv(home_dir, nation_dir, filechunk, ref, outdir):
    for file in filechunk:
        path = join(home_dir, nation_dir, file)
        filename = os.path.splitext(file)[0]
        outpath = join(outdir, filename + '.csv')
        if not os.path.exists(outpath):
            df = DataFrame({'ref': ref.values, 'pos': ref.index})
            ref_list = ref.tolist()
            with open(path) as f:
                lines = [line.rstrip() for line in f.readlines()]
                seq = ''.join(lines[1:])
                mut = [nt if nt != ref_list[i] else '' for i, nt in enumerate(seq)]
                df['mut'] = Series(mut)
                df.to_csv(outpath, index=False)

def gisaid_fasta2csv(homedir=f&#34;{GISAID_DIR}/Sequence/Preprocessed/&#34;):
    inputdir = f&#34;{homedir}/MSA_fasta&#34;
    outdir = f&#34;{homedir}/MSA_mutationinfo&#34;
    Path(outdir).mkdir(parents=True, exist_ok=True)

    core_n = 100
    args_list = []
    for nation_dir in get_dirnames_list(inputdir):
        filelist = get_filenames_list(join(inputdir, nation_dir))
        chunks = array_split(filelist, core_n)
        for filechunk in chunks:
            args_list.append((inputdir, nation_dir, filechunk, ref_seq, outdir))

    with Pool(core_n) as pool:
        pool.starmap(fasta2csv, args_list)

def make_nucleotide_mutclust_input(outdir, name, seq_dict=None):
    if not os.path.exists(outdir):
        print(outdir + ' is not exist')
        return

    output_path = join(outdir, f'{name}_mutclust_input.tsv')
    freq_df_path = join(outdir, f'{name}_freq_ATGC.csv')

    if seq_dict is None:
        print('No sequence dictionary provided.')
        return

    freq_df = DataFrame.from_dict(seq_dict).T.fillna(0).astype(int)
    freq_df = freq_df[[nt for nt in ['A', 'T', 'G', 'C'] if nt in freq_df.columns]]
    freq_df.to_csv(freq_df_path)

    pos_list, freq_list, per_list, entropy_list = [], [], [], []
    for pos in freq_df.index:
        freq = freq_df.loc[pos]
        cnt_n = freq.sum()
        if cnt_n == 0:
            continue
        percentage = freq / cnt_n
        ent = entropy(percentage, base=2)
        ref_nt = ref_seq[int(pos)]
        freq.drop(ref_nt, inplace=True, errors='ignore')
        percentage.drop(ref_nt, inplace=True, errors='ignore')
        pos_list.append(int(pos))
        freq_list.append(freq.sum())
        per_list.append(percentage.sum())
        entropy_list.append(ent)

    mutclust_input_df = DataFrame({
        'Position': pos_list,
        'Frequency': freq_list,
        'Percentages': per_list,
        'Entropy': entropy_list
    })
    mutclust_input_df.to_csv(output_path, sep='\t', index=False)
    return mutclust_input_df

def annotation():
    import ast
    mapping_df = pd.read_csv(join(GISAID_METADATA_DIR, 'merged_info.tsv'), sep='\t', index_col=0)
    for idx, row in mapping_df.iterrows():
        for col in row.index:
            try:
                mapping_df.at[idx, col] = ast.literal_eval(row[col])
            except Exception:
                continue
    print(mapping_df)



def make_bedgraph(mut_df, cluster_df, output_file):
    color_list = [
        'maroon', 'r', 'coral', 'chocolate', 'orange', 'gold', 'olive', 'yellow', 'lawngreen', 'palegreen',
        'forestgreen', 'lime', 'mediumaquamarine', 'aquamarine', 'teal', 'aqua', 'steelblue', 'slategrey',
        'cornflowerblue', 'blue', 'slateblue', 'indigo', 'plum', 'magenta', 'deeppink', 'pink']

    gene_df = get_GeneInfo_df()

    fig, ax = plt.subplots(figsize=(13.5, 3))
    ax.bar(mut_df.index, mut_df[HSCORE], width=30)
    ax.set_ylabel(HSCORE)
    ax.set_xticks(np.arange(0, 29903, 1000))
    ax.tick_params(labelrotation=45, labelsize=5)

    for _, row in cluster_df.iterrows():
        ax.axvspan(row['left_position'], row['right_position'], facecolor='lightgrey', alpha=0.8)

    trans = matplotlib.transforms.blended_transform_factory(ax.transData, fig.transFigure)
    pre_y = 0
    for i, row in gene_df.iterrows():
        rect = matplotlib.patches.Rectangle(
            (row['start'], 0.02), row['end'] - row['start'] + 1, 0.02,
            facecolor=color_list[i % len(color_list)], transform=trans,
            edgecolor='black', lw=0.5)
        fig.add_artist(rect)
        text_y = 0.01 if ((row['start'] - row['end']) < 1000 and pre_y == 0.01) else 0.05
        pre_y = text_y
        fig.text((row['start'] + row['end']) / 2, text_y, row['gene'],
                 ha='center', va='center', fontsize=5, fontweight='bold', transform=trans)

    plt.tight_layout()
    plt.savefig(output_file, format='png')
)
"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://yshghid.github.io/docs/study/algo/algo3/"><meta property="og:site_name" content=" "><meta property="og:title" content="MutClust 코드 리팩토링 #3 utils.py"><meta property="og:description" content="MutClust 코드 리팩토링 #3 utils.py # #2025-07-31
MutClust 알고리즘의 코드 구성은 아래와 같은데
MutClust └── sc/ └── lib.py └── arg_parser.py └── utils.py // 분석 함수 utils.py는 시각화, 필터링등 분석 보조 함수를 포함한다.
# === utils.py === import numpy as np import pandas as pd import matplotlib.pyplot as plt import matplotlib.transforms import matplotlib.patches from pandas import read_csv HSCORE = 'H-score' POS = 'Position' FREQ = 'Frequency' PER = 'Percentage' ENT = 'Entropy' NUCLEOTIDE_ANNOTATION_PATH = '/data3/projects/2020_MUTCLUST/paper/example_data/input/covid_annotation.tsv' def mutation_filtering(df): return df[(df[POS] >= 266) & (df[POS] <= 29674)].reset_index(drop=True) def get_GeneInfo_df(): return read_csv(NUCLEOTIDE_ANNOTATION_PATH, sep='\t') import os from collections import Counter from multiprocessing import Pool, Process, Manager from os.path import join from pathlib import Path import numpy as np import pandas as pd from pandas import read_csv, DataFrame, concat, Series from scipy.stats import entropy from Bin.Utils.utils import * # NOTE: 반드시 환경에 맞게 경로 수정 필요 # 전역 참조 염기서열 로드 ref_seq = getNucleotideRefSeq() # ========================= # 1. Codon / Nucleotide Sequence 불러오기 # ========================= def get_codon_sequence_dict(path='./data/codon_data/codon_sequence'): seq_dict = {} for file in get_filenames_list(path): df = read_csv(join(path, file), index_col=0) name = file.split('.')[0] seq_dict[name] = dict(zip(df['gene'], df['sequence'])) return seq_dict def get_nucleotide_sequence_dict(seq_dir): seq_dict = {} for file in get_filenames_list(seq_dir): df = read_csv(join(seq_dir, file), index_col=0).reset_index(drop=True) name = file.split('.')[0] seq_dict[name] = df return seq_dict # ========================= # 2. Reference 정보 # ========================= def getCodonRefSeqbyGene(): return pd.read_csv('/data3/projects/2020_MUTCLUST/Data/Annotation/Codon/Reference/new_reference_codon.csv', index_col=0) def getNucleotideRefSeqbyGene(): return pd.read_csv('/data3/projects/2020_MUTCLUST/Data/Annotation/Nucleotide/covid_annotation.tsv', sep=' ') def getStartDict(): ref = getCodonRefSeqbyGene() return dict(zip(ref['gene'], ref['start'])) # ========================= # 3. Codon 입력 데이터 생성 # ========================= def getTotal_df(seq_dict, start=1, gene=None): total_list, name_list = [], [] for name, seq_by_gene_dict in seq_dict.items(): seq = seq_by_gene_dict[gene] total_list.append(list(seq)) name_list.append(name) total_df = DataFrame(total_list, index=name_list) total_df.columns = [i + start for i in range(len(total_df.columns))] return total_df def make_codon_input(gene, seq_dict, ref_seq, out_dir): start_dict = getStartDict() total_df = getTotal_df(seq_dict, start=start_dict[gene], gene=gene) records = [] for i, pos in enumerate(total_df.columns): freq = total_df[pos].value_counts() p = freq / freq.sum() ref_amino = ref_seq[i] freq.drop(index=ref_amino, inplace=True, errors='ignore') p.drop(index=ref_amino, inplace=True, errors='ignore') if len(freq) > 0: entropy_val = -np.sum(p * np.log2(p)) records.append((int(pos) + 1, freq.sum(), p.sum(), entropy_val)) input_df = DataFrame(records, columns=['Position', 'Frequency', 'Percentages', 'Entropy']) Path(out_dir).mkdir(parents=True, exist_ok=True) input_df.to_csv(join(out_dir, f'{gene}.input.tsv'), sep='\t', index=False) return input_df def make_input_by_gene(severity, seq_dict, ref_df): out_dir = f'./input/{severity}_{len(seq_dict)}/' Path(out_dir).mkdir(parents=True, exist_ok=True) input_dfs = [] for gene in GENE_LIST: print(f'Gene: {gene}') ref_seq = ref_df[ref_df['gene'] == gene]['sequence'].iloc[0] input_df = make_codon_input(gene, seq_dict, ref_seq, out_dir) input_dfs.append(input_df) whole_df = concat(input_dfs).astype({&#34;Position&#34;: int, &#34;Frequency&#34;: int}) whole_df.to_csv(join(out_dir, 'whole.input.tsv'), sep='\t', index=False) return whole_df def make_codon_mutclust_input(): seq_dict = get_codon_sequence_dict() ref = getCodonRefSeqbyGene() make_input_by_gene('whole', seq_dict, ref) # ========================= # 4. 병렬 처리 유틸 # ========================= def multi_processing(func, parameter_list, core_n=100): proc, proc_exec, proc_end = [], [], [] for param in parameter_list: proc.append(Process(target=func, args=param)) while proc or proc_exec: for _ in range(min(core_n - len(proc_exec), len(proc))): p = proc.pop(0) p.start() proc_exec.append(p) for p in proc_exec[:]: if not p.is_alive(): proc_exec.remove(p) proc_end.append(p) p.join() p.close() # ========================= # 5. 보조 기능들 추가 # ========================= def add_HSCORE(): path = join(MUTCLUST_INPUT_DIR, 'gisaid_mutclust_input.tsv') new_path = join(MUTCLUST_INPUT_DIR, 'gisaid_mutclust_input_with_score.tsv') df = pd.read_csv(path, sep='\t') df[HSCORE] = df[PER] * df[ENT] df.to_csv(new_path, sep='\t', index=False) def make_codon_annotation(outdir): ref_df = getCodonRefSeqbyGene() ano_df = ref_df.drop(columns=['sequence']) ano_df.to_csv(join(outdir, 'codon_annotation.tsv'), sep='\t', index=False) def make_clade_divide_mutation(): clade_dir = './clade_divide_mutation' file_list = get_filenames_list(clade_dir) start_dict = getStartDict() for file in file_list: df = read_csv(join(clade_dir, file), sep='\t') print(df) # ========================= # 6. Mutation Info 처리 및 Matrix 생성 # ========================= def read_thead(filepathlist, return_list, i): ref_seq_sr = getNucleotideRefSeq() sub_dict = {pos: Counter({k: 0 for k in IUPAC_CODES.keys()}) for pos in ref_seq_sr.index} for filepath in filepathlist: df = read_csv(filepath, index_col=0).fillna('').reset_index(drop=True) for index, mut in enumerate(df['mut']): symbol = mut if mut != '' else ref_seq_sr[index + 1] sub_dict[index + 1][symbol] += 1 return_list.append(sub_dict) print(f'{i}th process complete!') def merge_thread(poslist, sub_dict_list, return_dict): for pos in poslist: merged_dict = {k: 0 for k in IUPAC_CODES.keys()} count_dict = sum([a[pos] for a in sub_dict_list], Counter()) for k, v in count_dict.items(): merged_dict[k] = v return_dict[pos] = merged_dict def load_mutationinfo(input_dir=COVID19_MUTATIONINFO_DIR, sample_list=None): core_n = 100 split_n = 1000 sub_dict_list = Manager().list() filelist = get_file_paths_recursive(input_dir) if sample_list is not None: filelist = [f for f in filelist if os.path.basename(f).split('.')[0] in sample_list] splited_filepaths = array_split(filelist, split_n) parameter_list = [(chunk, sub_dict_list, i) for i, chunk in enumerate(splited_filepaths)] print('read thread start!') multi_processing(read_thead, parameter_list, core_n) print('read thread end!') merged_dict = Manager().dict() poslist = ref_seq.index splited_positions = array_split(poslist, split_n) parameter_list = [(chunk, list(sub_dict_list), merged_dict) for chunk in splited_positions] print('merge thread start!') multi_processing(merge_thread, parameter_list, core_n) print('merge thread end!') return dict(merged_dict) def make_matrix_thread(file_list): clusters_file_path = join(GISAID_MUTCLUST_OUTPUT_DIR, 'clusters_hscore.txt') clusters_df = pd.read_csv(clusters_file_path, sep='\t') column_list = [ f&#34;c{i}({row['left_position']},{row['right_position']})&#34; for i, row in clusters_df.iterrows() ] cluster_df = pd.DataFrame(columns=column_list) for mutation_path in file_list: patient_df = pd.read_csv(mutation_path) patient_name = os.path.basename(mutation_path).split('.')[0] cluster_df.loc[patient_name] = 0 for i in patient_df[patient_df['mut'].notnull()]['pos']: matched = clusters_df[(clusters_df['left_position'] <= i) & (i <= clusters_df['right_position'])].index cluster_df.loc[patient_name][matched] += 1 return cluster_df def make_matrix(mutationinfo_dir, out_dir, tag, cpu_n=60): print('starting make matrix!') pool = Pool(processes=cpu_n) file_list = get_file_paths_recursive(mutationinfo_dir) file_chunks = array_split(file_list, cpu_n) results = pool.map(make_matrix_thread, file_chunks) merged_df = pd.concat(results) merged_df.to_csv(join(out_dir, f'cluster_matrix_{tag}.csv')) pool.close() pool.join() print(merged_df) # ========================= # 7. 실행 예시 (main) # ========================= if __name__ == '__main__': make_codon_mutclust_input() # ========================= # 8. FASTA → CSV 변환 및 Nucleotide 기반 MutClust 입력 # ========================= def fasta2csv(home_dir, nation_dir, filechunk, ref, outdir): for file in filechunk: path = join(home_dir, nation_dir, file) filename = os.path.splitext(file)[0] outpath = join(outdir, filename + '.csv') if not os.path.exists(outpath): df = DataFrame({'ref': ref.values, 'pos': ref.index}) ref_list = ref.tolist() with open(path) as f: lines = [line.rstrip() for line in f.readlines()] seq = ''.join(lines[1:]) mut = [nt if nt != ref_list[i] else '' for i, nt in enumerate(seq)] df['mut'] = Series(mut) df.to_csv(outpath, index=False) def gisaid_fasta2csv(homedir=f&#34;{GISAID_DIR}/Sequence/Preprocessed/&#34;): inputdir = f&#34;{homedir}/MSA_fasta&#34; outdir = f&#34;{homedir}/MSA_mutationinfo&#34; Path(outdir).mkdir(parents=True, exist_ok=True) core_n = 100 args_list = [] for nation_dir in get_dirnames_list(inputdir): filelist = get_filenames_list(join(inputdir, nation_dir)) chunks = array_split(filelist, core_n) for filechunk in chunks: args_list.append((inputdir, nation_dir, filechunk, ref_seq, outdir)) with Pool(core_n) as pool: pool.starmap(fasta2csv, args_list) def make_nucleotide_mutclust_input(outdir, name, seq_dict=None): if not os.path.exists(outdir): print(outdir + ' is not exist') return output_path = join(outdir, f'{name}_mutclust_input.tsv') freq_df_path = join(outdir, f'{name}_freq_ATGC.csv') if seq_dict is None: print('No sequence dictionary provided.') return freq_df = DataFrame.from_dict(seq_dict).T.fillna(0).astype(int) freq_df = freq_df[[nt for nt in ['A', 'T', 'G', 'C'] if nt in freq_df.columns]] freq_df.to_csv(freq_df_path) pos_list, freq_list, per_list, entropy_list = [], [], [], [] for pos in freq_df.index: freq = freq_df.loc[pos] cnt_n = freq.sum() if cnt_n == 0: continue percentage = freq / cnt_n ent = entropy(percentage, base=2) ref_nt = ref_seq[int(pos)] freq.drop(ref_nt, inplace=True, errors='ignore') percentage.drop(ref_nt, inplace=True, errors='ignore') pos_list.append(int(pos)) freq_list.append(freq.sum()) per_list.append(percentage.sum()) entropy_list.append(ent) mutclust_input_df = DataFrame({ 'Position': pos_list, 'Frequency': freq_list, 'Percentages': per_list, 'Entropy': entropy_list }) mutclust_input_df.to_csv(output_path, sep='\t', index=False) return mutclust_input_df def annotation(): import ast mapping_df = pd.read_csv(join(GISAID_METADATA_DIR, 'merged_info.tsv'), sep='\t', index_col=0) for idx, row in mapping_df.iterrows(): for col in row.index: try: mapping_df.at[idx, col] = ast.literal_eval(row[col]) except Exception: continue print(mapping_df) def make_bedgraph(mut_df, cluster_df, output_file): color_list = [ 'maroon', 'r', 'coral', 'chocolate', 'orange', 'gold', 'olive', 'yellow', 'lawngreen', 'palegreen', 'forestgreen', 'lime', 'mediumaquamarine', 'aquamarine', 'teal', 'aqua', 'steelblue', 'slategrey', 'cornflowerblue', 'blue', 'slateblue', 'indigo', 'plum', 'magenta', 'deeppink', 'pink'] gene_df = get_GeneInfo_df() fig, ax = plt.subplots(figsize=(13.5, 3)) ax.bar(mut_df.index, mut_df[HSCORE], width=30) ax.set_ylabel(HSCORE) ax.set_xticks(np.arange(0, 29903, 1000)) ax.tick_params(labelrotation=45, labelsize=5) for _, row in cluster_df.iterrows(): ax.axvspan(row['left_position'], row['right_position'], facecolor='lightgrey', alpha=0.8) trans = matplotlib.transforms.blended_transform_factory(ax.transData, fig.transFigure) pre_y = 0 for i, row in gene_df.iterrows(): rect = matplotlib.patches.Rectangle( (row['start'], 0.02), row['end'] - row['start'] + 1, 0.02, facecolor=color_list[i % len(color_list)], transform=trans, edgecolor='black', lw=0.5) fig.add_artist(rect) text_y = 0.01 if ((row['start'] - row['end']) < 1000 and pre_y == 0.01) else 0.05 pre_y = text_y fig.text((row['start'] + row['end']) / 2, text_y, row['gene'], ha='center', va='center', fontsize=5, fontweight='bold', transform=trans) plt.tight_layout() plt.savefig(output_file, format='png') )"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2025-07-31T00:00:00+00:00"><meta property="article:modified_time" content="2025-07-31T00:00:00+00:00"><meta property="article:tag" content="2025-07"><title>MutClust 코드 리팩토링 #3 utils.py |</title><link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://yshghid.github.io/docs/study/algo/algo3/><link rel=stylesheet href=/book.min.6217d077edb4189fd0578345e84bca1a884dfdee121ff8dc9a0f55cfe0852bc9.css integrity="sha256-YhfQd+20GJ/QV4NF6EvKGohN/e4SH/jcmg9Vz+CFK8k=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.943ec5a9d6f3e8f722027be671aeca1a14640aeb52785cd0da558f18c6cb90a4.js integrity="sha256-lD7Fqdbz6PciAnvmca7KGhRkCutSeFzQ2lWPGMbLkKQ=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/logo.png alt=Logo class=book-icon><span></span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><span>기록</span><ul><li><a href=/docs/hobby/book/>글</a><ul></ul></li><li><a href=/docs/hobby/daily/>일상</a><ul></ul></li></ul></li><li class=book-section-flat><span>공부</span><ul><li><a href=/docs/study/ai/>AI</a><ul></ul></li><li><a href=/docs/study/sw/>SW</a><ul></ul></li><li><a href=/docs/study/bioinformatics/>Bioinformatics</a><ul></ul></li><li><a href=/docs/study/algo/>Algorithm</a><ul></ul></li><li><a href=/docs/study/devops/>DevOps</a><ul></ul></li><li><a href=/docs/study/algorithm/>코테</a><ul></ul></li><li><a href=/docs/study/career/>취업</a><ul></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>MutClust 코드 리팩토링 #3 utils.py</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents></nav></aside></header><article class="markdown book-article"><h1 id=mutclust-코드-리팩토링-3-utilspy>MutClust 코드 리팩토링 #3 utils.py
<a class=anchor href=#mutclust-%ec%bd%94%eb%93%9c-%eb%a6%ac%ed%8c%a9%ed%86%a0%eb%a7%81-3-utilspy>#</a></h1><p>#2025-07-31</p><hr><p>MutClust 알고리즘의 코드 구성은 아래와 같은데</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>MutClust
</span></span><span style=display:flex><span>└── sc/
</span></span><span style=display:flex><span>     └── lib.py 
</span></span><span style=display:flex><span>     └── arg_parser.py
</span></span><span style=display:flex><span>     └── utils.py // 분석 함수
</span></span></code></pre></div><p>utils.py는 시각화, 필터링등 분석 보조 함수를 포함한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># === utils.py ===</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> pandas <span style=color:#66d9ef>as</span> pd
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> matplotlib.pyplot <span style=color:#66d9ef>as</span> plt
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> matplotlib.transforms
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> matplotlib.patches
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pandas <span style=color:#f92672>import</span> read_csv
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>HSCORE <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;H-score&#39;</span>
</span></span><span style=display:flex><span>POS <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Position&#39;</span>
</span></span><span style=display:flex><span>FREQ <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Frequency&#39;</span>
</span></span><span style=display:flex><span>PER <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Percentage&#39;</span>
</span></span><span style=display:flex><span>ENT <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Entropy&#39;</span>
</span></span><span style=display:flex><span>NUCLEOTIDE_ANNOTATION_PATH <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;/data3/projects/2020_MUTCLUST/paper/example_data/input/covid_annotation.tsv&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>mutation_filtering</span>(df):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> df[(df[POS] <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>266</span>) <span style=color:#f92672>&amp;</span> (df[POS] <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>29674</span>)]<span style=color:#f92672>.</span>reset_index(drop<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_GeneInfo_df</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> read_csv(NUCLEOTIDE_ANNOTATION_PATH, sep<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> os
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> collections <span style=color:#f92672>import</span> Counter
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> multiprocessing <span style=color:#f92672>import</span> Pool, Process, Manager
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> os.path <span style=color:#f92672>import</span> join
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pathlib <span style=color:#f92672>import</span> Path
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> pandas <span style=color:#66d9ef>as</span> pd
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pandas <span style=color:#f92672>import</span> read_csv, DataFrame, concat, Series
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> scipy.stats <span style=color:#f92672>import</span> entropy
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> Bin.Utils.utils <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>  <span style=color:#75715e># NOTE: 반드시 환경에 맞게 경로 수정 필요</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 전역 참조 염기서열 로드</span>
</span></span><span style=display:flex><span>ref_seq <span style=color:#f92672>=</span> getNucleotideRefSeq()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># =========================</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 1. Codon / Nucleotide Sequence 불러오기</span>
</span></span><span style=display:flex><span><span style=color:#75715e># =========================</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_codon_sequence_dict</span>(path<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;./data/codon_data/codon_sequence&#39;</span>):
</span></span><span style=display:flex><span>    seq_dict <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> file <span style=color:#f92672>in</span> get_filenames_list(path):
</span></span><span style=display:flex><span>        df <span style=color:#f92672>=</span> read_csv(join(path, file), index_col<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        name <span style=color:#f92672>=</span> file<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39;.&#39;</span>)[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        seq_dict[name] <span style=color:#f92672>=</span> dict(zip(df[<span style=color:#e6db74>&#39;gene&#39;</span>], df[<span style=color:#e6db74>&#39;sequence&#39;</span>]))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> seq_dict
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_nucleotide_sequence_dict</span>(seq_dir):
</span></span><span style=display:flex><span>    seq_dict <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> file <span style=color:#f92672>in</span> get_filenames_list(seq_dir):
</span></span><span style=display:flex><span>        df <span style=color:#f92672>=</span> read_csv(join(seq_dir, file), index_col<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>)<span style=color:#f92672>.</span>reset_index(drop<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>        name <span style=color:#f92672>=</span> file<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39;.&#39;</span>)[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        seq_dict[name] <span style=color:#f92672>=</span> df
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> seq_dict
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># =========================</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2. Reference 정보</span>
</span></span><span style=display:flex><span><span style=color:#75715e># =========================</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>getCodonRefSeqbyGene</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> pd<span style=color:#f92672>.</span>read_csv(<span style=color:#e6db74>&#39;/data3/projects/2020_MUTCLUST/Data/Annotation/Codon/Reference/new_reference_codon.csv&#39;</span>, index_col<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>getNucleotideRefSeqbyGene</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> pd<span style=color:#f92672>.</span>read_csv(<span style=color:#e6db74>&#39;/data3/projects/2020_MUTCLUST/Data/Annotation/Nucleotide/covid_annotation.tsv&#39;</span>, sep<span style=color:#f92672>=</span><span style=color:#e6db74>&#39; &#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>getStartDict</span>():
</span></span><span style=display:flex><span>    ref <span style=color:#f92672>=</span> getCodonRefSeqbyGene()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dict(zip(ref[<span style=color:#e6db74>&#39;gene&#39;</span>], ref[<span style=color:#e6db74>&#39;start&#39;</span>]))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># =========================</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 3. Codon 입력 데이터 생성</span>
</span></span><span style=display:flex><span><span style=color:#75715e># =========================</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>getTotal_df</span>(seq_dict, start<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, gene<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>    total_list, name_list <span style=color:#f92672>=</span> [], []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> name, seq_by_gene_dict <span style=color:#f92672>in</span> seq_dict<span style=color:#f92672>.</span>items():
</span></span><span style=display:flex><span>        seq <span style=color:#f92672>=</span> seq_by_gene_dict[gene]
</span></span><span style=display:flex><span>        total_list<span style=color:#f92672>.</span>append(list(seq))
</span></span><span style=display:flex><span>        name_list<span style=color:#f92672>.</span>append(name)
</span></span><span style=display:flex><span>    total_df <span style=color:#f92672>=</span> DataFrame(total_list, index<span style=color:#f92672>=</span>name_list)
</span></span><span style=display:flex><span>    total_df<span style=color:#f92672>.</span>columns <span style=color:#f92672>=</span> [i <span style=color:#f92672>+</span> start <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(total_df<span style=color:#f92672>.</span>columns))]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> total_df
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_codon_input</span>(gene, seq_dict, ref_seq, out_dir):
</span></span><span style=display:flex><span>    start_dict <span style=color:#f92672>=</span> getStartDict()
</span></span><span style=display:flex><span>    total_df <span style=color:#f92672>=</span> getTotal_df(seq_dict, start<span style=color:#f92672>=</span>start_dict[gene], gene<span style=color:#f92672>=</span>gene)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    records <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i, pos <span style=color:#f92672>in</span> enumerate(total_df<span style=color:#f92672>.</span>columns):
</span></span><span style=display:flex><span>        freq <span style=color:#f92672>=</span> total_df[pos]<span style=color:#f92672>.</span>value_counts()
</span></span><span style=display:flex><span>        p <span style=color:#f92672>=</span> freq <span style=color:#f92672>/</span> freq<span style=color:#f92672>.</span>sum()
</span></span><span style=display:flex><span>        ref_amino <span style=color:#f92672>=</span> ref_seq[i]
</span></span><span style=display:flex><span>        freq<span style=color:#f92672>.</span>drop(index<span style=color:#f92672>=</span>ref_amino, inplace<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>, errors<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;ignore&#39;</span>)
</span></span><span style=display:flex><span>        p<span style=color:#f92672>.</span>drop(index<span style=color:#f92672>=</span>ref_amino, inplace<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>, errors<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;ignore&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> len(freq) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            entropy_val <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>np<span style=color:#f92672>.</span>sum(p <span style=color:#f92672>*</span> np<span style=color:#f92672>.</span>log2(p))
</span></span><span style=display:flex><span>            records<span style=color:#f92672>.</span>append((int(pos) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, freq<span style=color:#f92672>.</span>sum(), p<span style=color:#f92672>.</span>sum(), entropy_val))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    input_df <span style=color:#f92672>=</span> DataFrame(records, columns<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;Position&#39;</span>, <span style=color:#e6db74>&#39;Frequency&#39;</span>, <span style=color:#e6db74>&#39;Percentages&#39;</span>, <span style=color:#e6db74>&#39;Entropy&#39;</span>])
</span></span><span style=display:flex><span>    Path(out_dir)<span style=color:#f92672>.</span>mkdir(parents<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>, exist_ok<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>    input_df<span style=color:#f92672>.</span>to_csv(join(out_dir, <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>gene<span style=color:#e6db74>}</span><span style=color:#e6db74>.input.tsv&#39;</span>), sep<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>&#39;</span>, index<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> input_df
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_input_by_gene</span>(severity, seq_dict, ref_df):
</span></span><span style=display:flex><span>    out_dir <span style=color:#f92672>=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;./input/</span><span style=color:#e6db74>{</span>severity<span style=color:#e6db74>}</span><span style=color:#e6db74>_</span><span style=color:#e6db74>{</span>len(seq_dict)<span style=color:#e6db74>}</span><span style=color:#e6db74>/&#39;</span>
</span></span><span style=display:flex><span>    Path(out_dir)<span style=color:#f92672>.</span>mkdir(parents<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>, exist_ok<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>    input_dfs <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> gene <span style=color:#f92672>in</span> GENE_LIST:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;Gene: </span><span style=color:#e6db74>{</span>gene<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>        ref_seq <span style=color:#f92672>=</span> ref_df[ref_df[<span style=color:#e6db74>&#39;gene&#39;</span>] <span style=color:#f92672>==</span> gene][<span style=color:#e6db74>&#39;sequence&#39;</span>]<span style=color:#f92672>.</span>iloc[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        input_df <span style=color:#f92672>=</span> make_codon_input(gene, seq_dict, ref_seq, out_dir)
</span></span><span style=display:flex><span>        input_dfs<span style=color:#f92672>.</span>append(input_df)
</span></span><span style=display:flex><span>    whole_df <span style=color:#f92672>=</span> concat(input_dfs)<span style=color:#f92672>.</span>astype({<span style=color:#e6db74>&#34;Position&#34;</span>: int, <span style=color:#e6db74>&#34;Frequency&#34;</span>: int})
</span></span><span style=display:flex><span>    whole_df<span style=color:#f92672>.</span>to_csv(join(out_dir, <span style=color:#e6db74>&#39;whole.input.tsv&#39;</span>), sep<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>&#39;</span>, index<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> whole_df
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_codon_mutclust_input</span>():
</span></span><span style=display:flex><span>    seq_dict <span style=color:#f92672>=</span> get_codon_sequence_dict()
</span></span><span style=display:flex><span>    ref <span style=color:#f92672>=</span> getCodonRefSeqbyGene()
</span></span><span style=display:flex><span>    make_input_by_gene(<span style=color:#e6db74>&#39;whole&#39;</span>, seq_dict, ref)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># =========================</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 4. 병렬 처리 유틸</span>
</span></span><span style=display:flex><span><span style=color:#75715e># =========================</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>multi_processing</span>(func, parameter_list, core_n<span style=color:#f92672>=</span><span style=color:#ae81ff>100</span>):
</span></span><span style=display:flex><span>    proc, proc_exec, proc_end <span style=color:#f92672>=</span> [], [], []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> param <span style=color:#f92672>in</span> parameter_list:
</span></span><span style=display:flex><span>        proc<span style=color:#f92672>.</span>append(Process(target<span style=color:#f92672>=</span>func, args<span style=color:#f92672>=</span>param))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> proc <span style=color:#f92672>or</span> proc_exec:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(min(core_n <span style=color:#f92672>-</span> len(proc_exec), len(proc))):
</span></span><span style=display:flex><span>            p <span style=color:#f92672>=</span> proc<span style=color:#f92672>.</span>pop(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            p<span style=color:#f92672>.</span>start()
</span></span><span style=display:flex><span>            proc_exec<span style=color:#f92672>.</span>append(p)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> p <span style=color:#f92672>in</span> proc_exec[:]:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> p<span style=color:#f92672>.</span>is_alive():
</span></span><span style=display:flex><span>                proc_exec<span style=color:#f92672>.</span>remove(p)
</span></span><span style=display:flex><span>                proc_end<span style=color:#f92672>.</span>append(p)
</span></span><span style=display:flex><span>                p<span style=color:#f92672>.</span>join()
</span></span><span style=display:flex><span>                p<span style=color:#f92672>.</span>close()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># =========================</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 5. 보조 기능들 추가</span>
</span></span><span style=display:flex><span><span style=color:#75715e># =========================</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add_HSCORE</span>():
</span></span><span style=display:flex><span>    path <span style=color:#f92672>=</span> join(MUTCLUST_INPUT_DIR, <span style=color:#e6db74>&#39;gisaid_mutclust_input.tsv&#39;</span>)
</span></span><span style=display:flex><span>    new_path <span style=color:#f92672>=</span> join(MUTCLUST_INPUT_DIR, <span style=color:#e6db74>&#39;gisaid_mutclust_input_with_score.tsv&#39;</span>)
</span></span><span style=display:flex><span>    df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>read_csv(path, sep<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>    df[HSCORE] <span style=color:#f92672>=</span> df[PER] <span style=color:#f92672>*</span> df[ENT]
</span></span><span style=display:flex><span>    df<span style=color:#f92672>.</span>to_csv(new_path, sep<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>&#39;</span>, index<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_codon_annotation</span>(outdir):
</span></span><span style=display:flex><span>    ref_df <span style=color:#f92672>=</span> getCodonRefSeqbyGene()
</span></span><span style=display:flex><span>    ano_df <span style=color:#f92672>=</span> ref_df<span style=color:#f92672>.</span>drop(columns<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;sequence&#39;</span>])
</span></span><span style=display:flex><span>    ano_df<span style=color:#f92672>.</span>to_csv(join(outdir, <span style=color:#e6db74>&#39;codon_annotation.tsv&#39;</span>), sep<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>&#39;</span>, index<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_clade_divide_mutation</span>():
</span></span><span style=display:flex><span>    clade_dir <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;./clade_divide_mutation&#39;</span>
</span></span><span style=display:flex><span>    file_list <span style=color:#f92672>=</span> get_filenames_list(clade_dir)
</span></span><span style=display:flex><span>    start_dict <span style=color:#f92672>=</span> getStartDict()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> file <span style=color:#f92672>in</span> file_list:
</span></span><span style=display:flex><span>        df <span style=color:#f92672>=</span> read_csv(join(clade_dir, file), sep<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>        print(df)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># =========================</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 6. Mutation Info 처리 및 Matrix 생성</span>
</span></span><span style=display:flex><span><span style=color:#75715e># =========================</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>read_thead</span>(filepathlist, return_list, i):
</span></span><span style=display:flex><span>    ref_seq_sr <span style=color:#f92672>=</span> getNucleotideRefSeq()
</span></span><span style=display:flex><span>    sub_dict <span style=color:#f92672>=</span> {pos: Counter({k: <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>for</span> k <span style=color:#f92672>in</span> IUPAC_CODES<span style=color:#f92672>.</span>keys()}) <span style=color:#66d9ef>for</span> pos <span style=color:#f92672>in</span> ref_seq_sr<span style=color:#f92672>.</span>index}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> filepath <span style=color:#f92672>in</span> filepathlist:
</span></span><span style=display:flex><span>        df <span style=color:#f92672>=</span> read_csv(filepath, index_col<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>)<span style=color:#f92672>.</span>fillna(<span style=color:#e6db74>&#39;&#39;</span>)<span style=color:#f92672>.</span>reset_index(drop<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> index, mut <span style=color:#f92672>in</span> enumerate(df[<span style=color:#e6db74>&#39;mut&#39;</span>]):
</span></span><span style=display:flex><span>            symbol <span style=color:#f92672>=</span> mut <span style=color:#66d9ef>if</span> mut <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;&#39;</span> <span style=color:#66d9ef>else</span> ref_seq_sr[index <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            sub_dict[index <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][symbol] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return_list<span style=color:#f92672>.</span>append(sub_dict)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>th process complete!&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>merge_thread</span>(poslist, sub_dict_list, return_dict):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> pos <span style=color:#f92672>in</span> poslist:
</span></span><span style=display:flex><span>        merged_dict <span style=color:#f92672>=</span> {k: <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>for</span> k <span style=color:#f92672>in</span> IUPAC_CODES<span style=color:#f92672>.</span>keys()}
</span></span><span style=display:flex><span>        count_dict <span style=color:#f92672>=</span> sum([a[pos] <span style=color:#66d9ef>for</span> a <span style=color:#f92672>in</span> sub_dict_list], Counter())
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> k, v <span style=color:#f92672>in</span> count_dict<span style=color:#f92672>.</span>items():
</span></span><span style=display:flex><span>            merged_dict[k] <span style=color:#f92672>=</span> v
</span></span><span style=display:flex><span>        return_dict[pos] <span style=color:#f92672>=</span> merged_dict
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>load_mutationinfo</span>(input_dir<span style=color:#f92672>=</span>COVID19_MUTATIONINFO_DIR, sample_list<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>    core_n <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>    split_n <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000</span>
</span></span><span style=display:flex><span>    sub_dict_list <span style=color:#f92672>=</span> Manager()<span style=color:#f92672>.</span>list()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    filelist <span style=color:#f92672>=</span> get_file_paths_recursive(input_dir)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> sample_list <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        filelist <span style=color:#f92672>=</span> [f <span style=color:#66d9ef>for</span> f <span style=color:#f92672>in</span> filelist <span style=color:#66d9ef>if</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>basename(f)<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39;.&#39;</span>)[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>in</span> sample_list]
</span></span><span style=display:flex><span>    splited_filepaths <span style=color:#f92672>=</span> array_split(filelist, split_n)
</span></span><span style=display:flex><span>    parameter_list <span style=color:#f92672>=</span> [(chunk, sub_dict_list, i) <span style=color:#66d9ef>for</span> i, chunk <span style=color:#f92672>in</span> enumerate(splited_filepaths)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;read thread start!&#39;</span>)
</span></span><span style=display:flex><span>    multi_processing(read_thead, parameter_list, core_n)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;read thread end!&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    merged_dict <span style=color:#f92672>=</span> Manager()<span style=color:#f92672>.</span>dict()
</span></span><span style=display:flex><span>    poslist <span style=color:#f92672>=</span> ref_seq<span style=color:#f92672>.</span>index
</span></span><span style=display:flex><span>    splited_positions <span style=color:#f92672>=</span> array_split(poslist, split_n)
</span></span><span style=display:flex><span>    parameter_list <span style=color:#f92672>=</span> [(chunk, list(sub_dict_list), merged_dict) <span style=color:#66d9ef>for</span> chunk <span style=color:#f92672>in</span> splited_positions]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;merge thread start!&#39;</span>)
</span></span><span style=display:flex><span>    multi_processing(merge_thread, parameter_list, core_n)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;merge thread end!&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dict(merged_dict)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_matrix_thread</span>(file_list):
</span></span><span style=display:flex><span>    clusters_file_path <span style=color:#f92672>=</span> join(GISAID_MUTCLUST_OUTPUT_DIR, <span style=color:#e6db74>&#39;clusters_hscore.txt&#39;</span>)
</span></span><span style=display:flex><span>    clusters_df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>read_csv(clusters_file_path, sep<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>    column_list <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>        <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;c</span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>(</span><span style=color:#e6db74>{</span>row[<span style=color:#e6db74>&#39;left_position&#39;</span>]<span style=color:#e6db74>}</span><span style=color:#e6db74>,</span><span style=color:#e6db74>{</span>row[<span style=color:#e6db74>&#39;right_position&#39;</span>]<span style=color:#e6db74>}</span><span style=color:#e6db74>)&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i, row <span style=color:#f92672>in</span> clusters_df<span style=color:#f92672>.</span>iterrows()
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>    cluster_df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame(columns<span style=color:#f92672>=</span>column_list)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> mutation_path <span style=color:#f92672>in</span> file_list:
</span></span><span style=display:flex><span>        patient_df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>read_csv(mutation_path)
</span></span><span style=display:flex><span>        patient_name <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>basename(mutation_path)<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39;.&#39;</span>)[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        cluster_df<span style=color:#f92672>.</span>loc[patient_name] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> patient_df[patient_df[<span style=color:#e6db74>&#39;mut&#39;</span>]<span style=color:#f92672>.</span>notnull()][<span style=color:#e6db74>&#39;pos&#39;</span>]:
</span></span><span style=display:flex><span>            matched <span style=color:#f92672>=</span> clusters_df[(clusters_df[<span style=color:#e6db74>&#39;left_position&#39;</span>] <span style=color:#f92672>&lt;=</span> i) <span style=color:#f92672>&amp;</span> (i <span style=color:#f92672>&lt;=</span> clusters_df[<span style=color:#e6db74>&#39;right_position&#39;</span>])]<span style=color:#f92672>.</span>index
</span></span><span style=display:flex><span>            cluster_df<span style=color:#f92672>.</span>loc[patient_name][matched] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> cluster_df
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_matrix</span>(mutationinfo_dir, out_dir, tag, cpu_n<span style=color:#f92672>=</span><span style=color:#ae81ff>60</span>):
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;starting make matrix!&#39;</span>)
</span></span><span style=display:flex><span>    pool <span style=color:#f92672>=</span> Pool(processes<span style=color:#f92672>=</span>cpu_n)
</span></span><span style=display:flex><span>    file_list <span style=color:#f92672>=</span> get_file_paths_recursive(mutationinfo_dir)
</span></span><span style=display:flex><span>    file_chunks <span style=color:#f92672>=</span> array_split(file_list, cpu_n)
</span></span><span style=display:flex><span>    results <span style=color:#f92672>=</span> pool<span style=color:#f92672>.</span>map(make_matrix_thread, file_chunks)
</span></span><span style=display:flex><span>    merged_df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>concat(results)
</span></span><span style=display:flex><span>    merged_df<span style=color:#f92672>.</span>to_csv(join(out_dir, <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;cluster_matrix_</span><span style=color:#e6db74>{</span>tag<span style=color:#e6db74>}</span><span style=color:#e6db74>.csv&#39;</span>))
</span></span><span style=display:flex><span>    pool<span style=color:#f92672>.</span>close()
</span></span><span style=display:flex><span>    pool<span style=color:#f92672>.</span>join()
</span></span><span style=display:flex><span>    print(merged_df)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># =========================</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 7. 실행 예시 (main)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># =========================</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    make_codon_mutclust_input()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># =========================</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 8. FASTA → CSV 변환 및 Nucleotide 기반 MutClust 입력</span>
</span></span><span style=display:flex><span><span style=color:#75715e># =========================</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fasta2csv</span>(home_dir, nation_dir, filechunk, ref, outdir):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> file <span style=color:#f92672>in</span> filechunk:
</span></span><span style=display:flex><span>        path <span style=color:#f92672>=</span> join(home_dir, nation_dir, file)
</span></span><span style=display:flex><span>        filename <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>splitext(file)[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        outpath <span style=color:#f92672>=</span> join(outdir, filename <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;.csv&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>exists(outpath):
</span></span><span style=display:flex><span>            df <span style=color:#f92672>=</span> DataFrame({<span style=color:#e6db74>&#39;ref&#39;</span>: ref<span style=color:#f92672>.</span>values, <span style=color:#e6db74>&#39;pos&#39;</span>: ref<span style=color:#f92672>.</span>index})
</span></span><span style=display:flex><span>            ref_list <span style=color:#f92672>=</span> ref<span style=color:#f92672>.</span>tolist()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>with</span> open(path) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>                lines <span style=color:#f92672>=</span> [line<span style=color:#f92672>.</span>rstrip() <span style=color:#66d9ef>for</span> line <span style=color:#f92672>in</span> f<span style=color:#f92672>.</span>readlines()]
</span></span><span style=display:flex><span>                seq <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join(lines[<span style=color:#ae81ff>1</span>:])
</span></span><span style=display:flex><span>                mut <span style=color:#f92672>=</span> [nt <span style=color:#66d9ef>if</span> nt <span style=color:#f92672>!=</span> ref_list[i] <span style=color:#66d9ef>else</span> <span style=color:#e6db74>&#39;&#39;</span> <span style=color:#66d9ef>for</span> i, nt <span style=color:#f92672>in</span> enumerate(seq)]
</span></span><span style=display:flex><span>                df[<span style=color:#e6db74>&#39;mut&#39;</span>] <span style=color:#f92672>=</span> Series(mut)
</span></span><span style=display:flex><span>                df<span style=color:#f92672>.</span>to_csv(outpath, index<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>gisaid_fasta2csv</span>(homedir<span style=color:#f92672>=</span><span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>GISAID_DIR<span style=color:#e6db74>}</span><span style=color:#e6db74>/Sequence/Preprocessed/&#34;</span>):
</span></span><span style=display:flex><span>    inputdir <span style=color:#f92672>=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>homedir<span style=color:#e6db74>}</span><span style=color:#e6db74>/MSA_fasta&#34;</span>
</span></span><span style=display:flex><span>    outdir <span style=color:#f92672>=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>homedir<span style=color:#e6db74>}</span><span style=color:#e6db74>/MSA_mutationinfo&#34;</span>
</span></span><span style=display:flex><span>    Path(outdir)<span style=color:#f92672>.</span>mkdir(parents<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>, exist_ok<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    core_n <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>    args_list <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> nation_dir <span style=color:#f92672>in</span> get_dirnames_list(inputdir):
</span></span><span style=display:flex><span>        filelist <span style=color:#f92672>=</span> get_filenames_list(join(inputdir, nation_dir))
</span></span><span style=display:flex><span>        chunks <span style=color:#f92672>=</span> array_split(filelist, core_n)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> filechunk <span style=color:#f92672>in</span> chunks:
</span></span><span style=display:flex><span>            args_list<span style=color:#f92672>.</span>append((inputdir, nation_dir, filechunk, ref_seq, outdir))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> Pool(core_n) <span style=color:#66d9ef>as</span> pool:
</span></span><span style=display:flex><span>        pool<span style=color:#f92672>.</span>starmap(fasta2csv, args_list)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_nucleotide_mutclust_input</span>(outdir, name, seq_dict<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>exists(outdir):
</span></span><span style=display:flex><span>        print(outdir <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39; is not exist&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    output_path <span style=color:#f92672>=</span> join(outdir, <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>_mutclust_input.tsv&#39;</span>)
</span></span><span style=display:flex><span>    freq_df_path <span style=color:#f92672>=</span> join(outdir, <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>_freq_ATGC.csv&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> seq_dict <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;No sequence dictionary provided.&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    freq_df <span style=color:#f92672>=</span> DataFrame<span style=color:#f92672>.</span>from_dict(seq_dict)<span style=color:#f92672>.</span>T<span style=color:#f92672>.</span>fillna(<span style=color:#ae81ff>0</span>)<span style=color:#f92672>.</span>astype(int)
</span></span><span style=display:flex><span>    freq_df <span style=color:#f92672>=</span> freq_df[[nt <span style=color:#66d9ef>for</span> nt <span style=color:#f92672>in</span> [<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;T&#39;</span>, <span style=color:#e6db74>&#39;G&#39;</span>, <span style=color:#e6db74>&#39;C&#39;</span>] <span style=color:#66d9ef>if</span> nt <span style=color:#f92672>in</span> freq_df<span style=color:#f92672>.</span>columns]]
</span></span><span style=display:flex><span>    freq_df<span style=color:#f92672>.</span>to_csv(freq_df_path)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    pos_list, freq_list, per_list, entropy_list <span style=color:#f92672>=</span> [], [], [], []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> pos <span style=color:#f92672>in</span> freq_df<span style=color:#f92672>.</span>index:
</span></span><span style=display:flex><span>        freq <span style=color:#f92672>=</span> freq_df<span style=color:#f92672>.</span>loc[pos]
</span></span><span style=display:flex><span>        cnt_n <span style=color:#f92672>=</span> freq<span style=color:#f92672>.</span>sum()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> cnt_n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>        percentage <span style=color:#f92672>=</span> freq <span style=color:#f92672>/</span> cnt_n
</span></span><span style=display:flex><span>        ent <span style=color:#f92672>=</span> entropy(percentage, base<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>        ref_nt <span style=color:#f92672>=</span> ref_seq[int(pos)]
</span></span><span style=display:flex><span>        freq<span style=color:#f92672>.</span>drop(ref_nt, inplace<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>, errors<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;ignore&#39;</span>)
</span></span><span style=display:flex><span>        percentage<span style=color:#f92672>.</span>drop(ref_nt, inplace<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>, errors<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;ignore&#39;</span>)
</span></span><span style=display:flex><span>        pos_list<span style=color:#f92672>.</span>append(int(pos))
</span></span><span style=display:flex><span>        freq_list<span style=color:#f92672>.</span>append(freq<span style=color:#f92672>.</span>sum())
</span></span><span style=display:flex><span>        per_list<span style=color:#f92672>.</span>append(percentage<span style=color:#f92672>.</span>sum())
</span></span><span style=display:flex><span>        entropy_list<span style=color:#f92672>.</span>append(ent)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    mutclust_input_df <span style=color:#f92672>=</span> DataFrame({
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;Position&#39;</span>: pos_list,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;Frequency&#39;</span>: freq_list,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;Percentages&#39;</span>: per_list,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;Entropy&#39;</span>: entropy_list
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    mutclust_input_df<span style=color:#f92672>.</span>to_csv(output_path, sep<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>&#39;</span>, index<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> mutclust_input_df
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>annotation</span>():
</span></span><span style=display:flex><span>    <span style=color:#f92672>import</span> ast
</span></span><span style=display:flex><span>    mapping_df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>read_csv(join(GISAID_METADATA_DIR, <span style=color:#e6db74>&#39;merged_info.tsv&#39;</span>), sep<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>&#39;</span>, index_col<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> idx, row <span style=color:#f92672>in</span> mapping_df<span style=color:#f92672>.</span>iterrows():
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> col <span style=color:#f92672>in</span> row<span style=color:#f92672>.</span>index:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>                mapping_df<span style=color:#f92672>.</span>at[idx, col] <span style=color:#f92672>=</span> ast<span style=color:#f92672>.</span>literal_eval(row[col])
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>Exception</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>    print(mapping_df)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_bedgraph</span>(mut_df, cluster_df, output_file):
</span></span><span style=display:flex><span>    color_list <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;maroon&#39;</span>, <span style=color:#e6db74>&#39;r&#39;</span>, <span style=color:#e6db74>&#39;coral&#39;</span>, <span style=color:#e6db74>&#39;chocolate&#39;</span>, <span style=color:#e6db74>&#39;orange&#39;</span>, <span style=color:#e6db74>&#39;gold&#39;</span>, <span style=color:#e6db74>&#39;olive&#39;</span>, <span style=color:#e6db74>&#39;yellow&#39;</span>, <span style=color:#e6db74>&#39;lawngreen&#39;</span>, <span style=color:#e6db74>&#39;palegreen&#39;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;forestgreen&#39;</span>, <span style=color:#e6db74>&#39;lime&#39;</span>, <span style=color:#e6db74>&#39;mediumaquamarine&#39;</span>, <span style=color:#e6db74>&#39;aquamarine&#39;</span>, <span style=color:#e6db74>&#39;teal&#39;</span>, <span style=color:#e6db74>&#39;aqua&#39;</span>, <span style=color:#e6db74>&#39;steelblue&#39;</span>, <span style=color:#e6db74>&#39;slategrey&#39;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;cornflowerblue&#39;</span>, <span style=color:#e6db74>&#39;blue&#39;</span>, <span style=color:#e6db74>&#39;slateblue&#39;</span>, <span style=color:#e6db74>&#39;indigo&#39;</span>, <span style=color:#e6db74>&#39;plum&#39;</span>, <span style=color:#e6db74>&#39;magenta&#39;</span>, <span style=color:#e6db74>&#39;deeppink&#39;</span>, <span style=color:#e6db74>&#39;pink&#39;</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    gene_df <span style=color:#f92672>=</span> get_GeneInfo_df()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    fig, ax <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>subplots(figsize<span style=color:#f92672>=</span>(<span style=color:#ae81ff>13.5</span>, <span style=color:#ae81ff>3</span>))
</span></span><span style=display:flex><span>    ax<span style=color:#f92672>.</span>bar(mut_df<span style=color:#f92672>.</span>index, mut_df[HSCORE], width<span style=color:#f92672>=</span><span style=color:#ae81ff>30</span>)
</span></span><span style=display:flex><span>    ax<span style=color:#f92672>.</span>set_ylabel(HSCORE)
</span></span><span style=display:flex><span>    ax<span style=color:#f92672>.</span>set_xticks(np<span style=color:#f92672>.</span>arange(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>29903</span>, <span style=color:#ae81ff>1000</span>))
</span></span><span style=display:flex><span>    ax<span style=color:#f92672>.</span>tick_params(labelrotation<span style=color:#f92672>=</span><span style=color:#ae81ff>45</span>, labelsize<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> _, row <span style=color:#f92672>in</span> cluster_df<span style=color:#f92672>.</span>iterrows():
</span></span><span style=display:flex><span>        ax<span style=color:#f92672>.</span>axvspan(row[<span style=color:#e6db74>&#39;left_position&#39;</span>], row[<span style=color:#e6db74>&#39;right_position&#39;</span>], facecolor<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;lightgrey&#39;</span>, alpha<span style=color:#f92672>=</span><span style=color:#ae81ff>0.8</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    trans <span style=color:#f92672>=</span> matplotlib<span style=color:#f92672>.</span>transforms<span style=color:#f92672>.</span>blended_transform_factory(ax<span style=color:#f92672>.</span>transData, fig<span style=color:#f92672>.</span>transFigure)
</span></span><span style=display:flex><span>    pre_y <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i, row <span style=color:#f92672>in</span> gene_df<span style=color:#f92672>.</span>iterrows():
</span></span><span style=display:flex><span>        rect <span style=color:#f92672>=</span> matplotlib<span style=color:#f92672>.</span>patches<span style=color:#f92672>.</span>Rectangle(
</span></span><span style=display:flex><span>            (row[<span style=color:#e6db74>&#39;start&#39;</span>], <span style=color:#ae81ff>0.02</span>), row[<span style=color:#e6db74>&#39;end&#39;</span>] <span style=color:#f92672>-</span> row[<span style=color:#e6db74>&#39;start&#39;</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0.02</span>,
</span></span><span style=display:flex><span>            facecolor<span style=color:#f92672>=</span>color_list[i <span style=color:#f92672>%</span> len(color_list)], transform<span style=color:#f92672>=</span>trans,
</span></span><span style=display:flex><span>            edgecolor<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;black&#39;</span>, lw<span style=color:#f92672>=</span><span style=color:#ae81ff>0.5</span>)
</span></span><span style=display:flex><span>        fig<span style=color:#f92672>.</span>add_artist(rect)
</span></span><span style=display:flex><span>        text_y <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.01</span> <span style=color:#66d9ef>if</span> ((row[<span style=color:#e6db74>&#39;start&#39;</span>] <span style=color:#f92672>-</span> row[<span style=color:#e6db74>&#39;end&#39;</span>]) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>1000</span> <span style=color:#f92672>and</span> pre_y <span style=color:#f92672>==</span> <span style=color:#ae81ff>0.01</span>) <span style=color:#66d9ef>else</span> <span style=color:#ae81ff>0.05</span>
</span></span><span style=display:flex><span>        pre_y <span style=color:#f92672>=</span> text_y
</span></span><span style=display:flex><span>        fig<span style=color:#f92672>.</span>text((row[<span style=color:#e6db74>&#39;start&#39;</span>] <span style=color:#f92672>+</span> row[<span style=color:#e6db74>&#39;end&#39;</span>]) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, text_y, row[<span style=color:#e6db74>&#39;gene&#39;</span>],
</span></span><span style=display:flex><span>                 ha<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;center&#39;</span>, va<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;center&#39;</span>, fontsize<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>, fontweight<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;bold&#39;</span>, transform<span style=color:#f92672>=</span>trans)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    plt<span style=color:#f92672>.</span>tight_layout()
</span></span><span style=display:flex><span>    plt<span style=color:#f92672>.</span>savefig(output_file, format<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;png&#39;</span>)
</span></span><span style=display:flex><span>)
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://giscus.app/client.js data-repo=yshghid/yshghid.github.io data-repo-id=R_kgDONkMkNg data-category-id=DIC_kwDONkMkNs4CloJh data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents></nav></div></aside></main></body></html>
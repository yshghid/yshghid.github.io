<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://yshghid.github.io/categories/docker/"><meta property="og:site_name" content=" "><meta property="og:title" content="Docker"><meta property="og:locale" content="en_us"><meta property="og:type" content="website"><title>Docker |</title><link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://yshghid.github.io/categories/docker/><link rel=stylesheet href=/book.min.30a7836b6a89342da3b88e7afd1036166aeced16c8de12df060ded2031837886.css integrity="sha256-MKeDa2qJNC2juI56/RA2Fmrs7RbI3hLfBg3tIDGDeIY=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.dfb8db6f4d25f997bfa72215ba3307be706f543020a387bb8f0dcee6e38ba176.js integrity="sha256-37jbb00l+Ze/pyIVujMHvnBvVDAgo4e7jw3O5uOLoXY=" crossorigin=anonymous></script><link rel=alternate type=application/rss+xml href=https://yshghid.github.io/categories/docker/index.xml title=" "></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/logo.png alt=Logo class=book-icon><span></span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><span>기록</span><ul><li><a href=/docs/hobby/daily/>일상</a><ul></ul></li><li><a href=/docs/hobby/book/>글</a><ul></ul></li></ul></li><li class=book-section-flat><span>공부</span><ul><li><a href=/docs/study/ai/>AI</a><ul></ul></li><li><a href=/docs/study/bioinformatics/>Bioinformatics</a><ul></ul></li><li><a href=/docs/study/be/>BE</a><ul></ul></li><li><a href=/docs/study/fe/>FE</a><ul></ul></li><li><a href=/docs/study/career/>취업</a><ul></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Docker</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents></nav></aside></header><article class="markdown book-article"><p><em>2025-08-04</em> ⋯ Docker #5 kubernetes 환경에 나의 앱을 배포해보자</p><p style=height:4.5em;overflow:hidden><a href=/docs/study/be/be44/>구조 실습과의 차이? 1. cicd.sh를 쓴다. 2. deploy 디렉토리를 쓴다. 3. docker-build.sh와 docker-push.sh에서 amd였던걸 arm으로 바꿔줬는데 이걸다시 amd로 바꿔준다. ~1. cicd.sh 작성 **(불필요)**~ cicd.sh 사용하는 부분이 나오는데 ppt랑 workspace 디렉토리 안에 아무리찾아봐도 없어서... 일단 챗지피티에넣고 만들었는데 막상 뒤에서는 cicd.sh 쓰는대신 그냥 `kubectl apply -f deploy.yaml` `kubectl apply -f service.yaml` 만 해줬다. 2. deploy 디렉토리 deploy 디렉토리의 deploy.t와 service.t는 각각 .sh로 바꿔준다. - deploy.sh에서 amd를 유지해주고 - service.sh는 원래 8080 돼있었는데 8888 아닌가 싶어서 바꿔줬다. env.properties의 CPU_PLATFORM=amd64으로 설정했고 deploy.sh에서 amd64로 해주고 service.sh에서 port: 8888로 변경했다. 3. docker-build.sh와 docker-push.sh 재수정 arm을 amd로 다시바꿔줫다. 마찬가지 arm을 amd로 바꿔줌. 4. Docker 이미지 빌드, 푸시, kubernetes 환경에 배포 ~이렇게 하면 나와야되는데 계속 404 에러 나옴.~ *해결.. ㅠㅠ* 1. deploy.sh: 챗지피티에서 amd64 떼라고해서 마지막엔 `image: amdp-registry.skala-ai.com/skala25a/${USER_NAME}-posts-get:1.0`도 썼다 2. deploy.yaml: 마찬가지로 amd64 떼라고해서 `amdp-registry.skala-ai.com/skala25a/sk019-posts-get:1.0`도 썼다. 3. defalut.conf는 다음 3가지 버전을 시도했다. 4. cicd.sh -y 스크립트가 존재하지 않는 경우에 `kubectl apply -f deploy.yaml`와 `kubectl apply -f service.yaml`로 대체 가능하대서 그냥 패스했는데 그래도 되는게 맞는지 모르겟음 교수님께 질문사항 디엠 보냈는데 > 우선 deploy를 통해 자신이 만들어놓은 컨테이너 이미지를 클라우드 환경으로 잘 배포했습니다. > > 그리고 service를 통해 나의 컨테이너 내 80포트를 노출하고 있는 nginx를 외부에서 접속 가능하도록 잘 연결했습니다. 이것은 어디서든 접속가능하게 하기 위한 ingress 설정이 있는데 이것은 제가 미리 만들어놓아서 위의 URL로 접속됩니다. > > 단지 내가 외부 접속을 위한 ingress 설정에 등록했던 service 이름인 sk019-posts-get이였는데 sk019-posts-get-svc로 만들어 놓아서 이름만 변경해놓았습니다. 라고 오셔서 확인해보니까 말도안되게 service.yaml이 다음과같이 작성돼있었다 아니근데 위 작업 하면서 쓴 챗지피티 대화창에 'sk019-posts-get' 치면 어디서도 'sk019-posts-get-svc'라는 단어가 없는데....... 어디서 나온건지 모르겟음 아무튼 링크를 확인해보니까 잘들어가있다 ㅎㅎ</a></p><hr><p><em>2025-08-04</em> ⋯ Docker #4 자신의 Frontend 개발 코드를 컨테이너로 만들고 이것을 실행시켜 보자</p><p style=height:4.5em;overflow:hidden><a href=/docs/study/be/be43/>1. nginx:alpine 이미지를 사용 2. 노출 Port는80 3. nginx를실행하는방식은 -nginx -g daemon off; 4. nginx의 routing 설정은 default.conf에설정한다. 1. docker-build.sh와 docker-push.sh 복사 docker-build.sh에서 amd였던걸 arm으로 바꿔줫고 docker-push.sh에서 마찬가지 amd를 arm으로 바꿔줌. 2. Dockerfile과 default.conf 작성 원래 코드에 `COPY src/ /usr/share/nginx/html/`이 없었는데 필요한거아닌가 싶어서 넣어줬다. 3. 파일 구조 index.html이랑 이미지 디렉토리 media는 src 디렉토리에 넣었다. 4. 이미지 push build + docker run 마찬가지 run 주소도 arm으로 넣어줌. 잘 나온다 ㅎㅎㅎ 5. 헷갈리는점 1. docker-build.sh에서 - IMAGE_NAME을 healthcheck-server로 바꿔주라고 ppt에 나와있었는데 안바꾸고 webserver를 썼는데 마지막에 `sudo docker run -d --name posts-get --network bridge -p 8888:80 sk019-posts-get.arm64:1.0` 했을때 제대로 나왔다. - 근데 chatgpt 치니까 IMAGE_NAME="healthcheck-server" 해놓고 `sudo docker run -d --name posts-get` 해버리면 안된다고나옴 빌드한 이미지와 실행한 이미지 이름이 다르다고 근데 원래는 달랐는데 잘되던데... 확인 필요할듯. 2. default.conf는 사실 아래 코드로 바꿔넣어줬었다. index.html;을 추가한것임. 이부분도 확인 필요. *1에 추가: env.properties에서 SERVICE_NAME="posts-get"가 나오긴한데 docker-build.sh와 docker-push.sh 가 앞에 source ./env.properties가 붙는 식으로 진행되면 IMAGE_NAME="posts-get"이 적용되고 이미지 이름이 sk019-posts-get:1.0.0으로 만들어지고, run/push 시 모두 일관성이 유지되는게 맞는데? env.properties를 불러오지도 않고, IMAGE_NAME에 healthcheck-server이 하드코딩 대있어서 연관성을찾기 어려운상태.</a></p><hr><p><em>2025-08-04</em> ⋯ Docker #3 레지스트리 접속, 이미지 관리</p><p style=height:4.5em;overflow:hidden><a href=/docs/study/be/be42/>1. 레지스트리에 접속하고 이미지를 pull/push하기 2. Docker Hub에서 우분투 이미지 받아보기 3. Dockerfile : 명령어 CMD 실습 4. 의문점 정리 CMD? Dockerfile에서 CMD는 도커 컨테이너가 실행될 때 자동으로 수행할 기본 명령어를 지정하는 역할인데 예를 들어 `CMD echo "This is the default command"`는 사용자가 docker run 명령을 통해 별도의 명령을 전달하지 않았을 때 이 기본 명령이 실행된다. 그래서 `sudo docker build -t my-image .`로 이미지를 만들고, `sudo docker run my-image`라고 실행하면 `This is the default command`라는 메시지가 출력됨. Override? (`docker run` 명령에 인자를 추가로 넘기면?) docker run 뒤에 인자를 직접 주면 예를 들어 `sudo docker run my-image echo "Overridden command"` 이렇게 실행하면 `CMD ["echo", "This is the default command"]`를 쓰지 않고, `echo "Overridden command"`를 실행한다. 결론적으로 이렇다: 1. `sudo docker run my-image` -> CMD가 그대로 실행됨 (`echo "This is the default command"`) 2. `sudo docker run my-image echo "Hello"` -> CMD는 무시되고 사용자가 입력한 `echo "Hello"`만 실행됨 CMD 작성 형식? `sudo docker run my-image "Override CMD"`처럼 인자를 넘기면 원래 CMD의 `echo` 명령은 유지되고 `"Override CMD"`라는 문자열이 인자로 전달되어 `echo "Override CMD"`가 실행될 것 같지만 Docker가 전달한 문자열을 실행 가능한 명령어로 인식하지 못하기 때문에 오류가난다. 이문장은 `sudo docker run my-image sh -c "echo Override CMD"`처럼 `sh -c`를 통해 쉘 명령어로 감싸주면 `"Override CMD"`가 정상적으로 출력된다. 결론적으로 이렇다: 1. `CMD ["echo", "Hello"]` 이렇게 (명령어와 인자를 분리해서) 써주거나 2. `sudo docker run my-image sh -c "echo Hello"` /bin/sh -c로 감싸서 실행되거나.</a></p><hr><p><em>2025-08-01</em> ⋯ Docker #2 작년 작업 복기: netmhcpan image 불러와서 패키지 돌리기</p><p style=height:4.5em;overflow:hidden><a href=/docs/study/be/be41/>2024.11.24 MutClust 작업중에 netmhcpan을 돌려야되는 상황이 왓었는데 netmhcpan이 유료였나 그래서 패키지 다운은 안되고 담당 박사님은 그만두셧고.. 서버 뒤지다가 위 README 파일 발견해서 결과물 저장까진 했던 기억이있다. 이때먼가 의문이 들었던게 새로운 conda 환경에 접속한거같은 느낌이 아니라 완전 다른 제2의서버에 접속한 느낌이었는데 이상하게 연구실 디렉토리들은 그대로 접근이 가능해서 혼란스럽지만 그냥 절대경로 다 박고 수행했는데 결과들이 문제없이 저장됐었다. 그래서 그뒤로 걍잊어버리고있었는데 docker 배우고나니까 먼가 이해돼서 이해된김에 정리해보기! 2. 도커 이미지 pull 및 수행 1. 도커 이미지 다운로드 당시 chatgpt 응답 > `docker pull * (*: 링크 블라인드 처리)` 명령어는 Docker Hub에서 *의 1.0 버전을 다운로드합니다. 이미지 크기가 953.76 MB이므로, 다운로드에는 네트워크 속도에 따라 몇 분 정도 소요될 수 있습니다. > 2. 도커 이미지 수행 당시 chatgpt 응답 > 이미지 다운로드 후, 다음과 같은 명령어로 Docker 컨테이너를 생성하고 실행할 수 있습니다. 예를 들어, 로컬 시스템의 특정 디렉토리를 컨테이너에 마운트하고 싶다면: > > `docker run -it -v /path/to/local/datac:/data *` > > 이 명령은 다음과 같은 작업을 수행합니다: > > - `it`: 컨테이너를 대화식 모드로 실행하고 터미널 입력을 위한 인터페이스를 제공합니다. > - `v /path/to/local/data:/data`: 호스트 시스템의 `/path/to/local/data` 디렉토리를 컨테이너의 `/data` 디렉토리에 마운트합니다. 이렇게 하면 컨테이너 내부에서 호스트 시스템의 데이터에 접근할 수 있습니다. 당시 내 코드 몰랐는데 호스트 시스템(우리 서버)의 내 작업 디렉토리("/data/home/ysh980101/2411/data-mhc")를 컨테이너에 마운트 했었다. 3. netMHCpan 실행 1. netMHCpan 설치 경로 찾기 당시 chatgpt 응답 > > 컨테이너가 시작되면 기본적으로 `/home/RSEM-1.3.3` 디렉토리에서 시작되는 것 같습니다. 이 디렉토리는 RSEM 관련 작업을 위한 것으로 보이며, netMHCpan 작업을 수행하려면 적절한 디렉토리로 이동해야 할 수 있습니다. > > 컨테이너 내에서 netMHCpan 설치 디렉토리로 이동하려면, 해당 디렉토리의 경로를 알아야 합니다. netMHCpan의 설치 위치를 확인하고, cd 명령어로 그 위치로 이동합니다. > > `cd /path/to/netMHCpan` 당시 내 코드 netMHCpan의 설치 디렉토리 /netMHCpan-4.1 를 찾음. 2. netMHCpan 사용 당시 chatgpt 응답 > 디렉토리로 이동: 이제 확인된 설치 경로로 이동하여 작업을 시작합니다. > > `cd /netMHCpan-4.1` > > 작업 실행: netMHCpan을 실행하려면, 해당 디렉토리 내에서 실행 파일을 찾아 해당 명령을 사용합니다. 예를 들어, 다음과 같은 명령어를 사용할 수 있습니다: > > `./netMHCpan -a HLA-A02:01 -l 9 -f your_peptide_file.txt -o output.txt` > > 이 명령은 HLA-A02:01 앨리얼을 대상으로 하는 9-mer 펩타이드를 your_peptide_file.txt에서 읽어들여 output.txt에 결과를 출력합니다. 당시 내 코드 patient_id.txt에 있는 각 환자 ID에 대해 루프를 돌림 환자별 .csv 파일에서 첫 번째 컬럼(펩타이드 서열)만 추출하고, 헤더를 제거해서 .txt 파일로 만들고 Affinity prediction하려는 hla allele를 HLA_I_ALLELES_FILE에 저장해놧엇는데 HLA_I_ALLELES_FILE에 대해 루프를 돌림. 각 allele마다 NetMHCpan 실행 결과를 allele 이름으로 된 .txt 파일로 저장. 해당 환자의 모든 allele에 대한 결과 파일을 하나의 .csv로 병합. sc.py는? 대충 이런식인데 최종적으로는 Allele,Peptide,Affinity 컬럼 갖는 테이블을 반환. 전체 bash script는 이랬다 4. Docker 종료 그때 노션 보니까 챗지피티가 이런말도 해줫다. > 작업이 완료되면, exit 명령어를 입력하여 컨테이너에서 나올 수 있습니다. 컨테이너를 종료하지 않고 나온 경우, 다음과 같이 컨테이너를 다시 시작하거나 종료할 수 있습니다. > > 컨테이너 재시작: `docker start [container_id_or_name]` > > 컨테이너 내부로 들어가기: `docker attach [container_id_or_name]` 이때 이해를못한상태니깐 exit를 하면 그냥 완전 나가기가 된다고 생각했던거같다. 그래서 한 10번 넘게 들어가서 작업했는데 내가 컨테이너를 하나도 종료안해놔서 한 6개월뒤에 사람들이 ys910111 누구냐고 머라했던기억이 ㅋㅋ ㅠㅠ 그래도 이제 먼가 이해되니깐조은듯.</a></p><hr><p><em>2025-08-01</em> ⋯ Docker #1 Python 실행 컨테이너 만들기</p><p style=height:4.5em;overflow:hidden><a href=/docs/study/be/be40/>Background - RDE Local PC에서 RDE 환경 구성에서 Harbor registry로부터 RdE Container download를 수행했음 - 아이콘을 클릭해서 RDE 런처를 실행한다. 1. 웹 서비스 실행 컨테이너 만들기 1. /config/workspace/cloud/container/00.container-linux 경로로 이동 2. 디렉토리 구조는? 3. Dockerfile 내용 확인하기 내용은? - Alpine 리눅스를 기반으로 Python 3.11 환경 사용 - Python 빌드에 필요한 기본 패키지 설치 (bash, curl, gcc, musl-dev, linux-headers, jq) - Python 패키지 설치 (fastapi uvicorn psutil python-multipart) 그리고 "/mycode"를 볼륨으로 지정. - webserver.py를 컨테이너 내 디렉토리 /mycode 아래에 복사하기 (-> 컨테이너가 종료되더라도 그대로 남아있게) - 웹 서버를 무한 대기 상태로 유지 (컨테이너가 실행되었을 때 바로 종료되지 않고 계속 살아있도록) 2. Docker 이미지 빌드 3. mydata에 webserver.py 복사 후 실행 1. 현재 파일 구조 내부 확인해보면? 비어있음. 2. 다른 터미널 열어서 복사해주고 확인 3. 수행후 파일 구조 4. webserver.py 수행 하면 "http://localhost:8888/login"에서 welcome page가 뜬다. 4. 컨테이너를 실행 즉시 webserver가 되도록 해보자 1. Dockerfile 내용 수정 컨테이너가 실행되면 FastAPI 서버가 자동으로 실행되게함 2. 컨테이너 실행 하면 "http://localhost:8888/login"에서 welcome page가 뜬다. 3. 아까랑 다른점? 아까는 `python /mycode/webserver.py` 해야 떴는데 이제는 바로뜬다는 차이가있음. 5. 의문점 정리 1. RDE 아이콘 클릭하는것의 의미는? RDE 런처를 수행하면 사전에 정의된 Docker 컨테이너를 자동으로 구동한다. 이 컨테이너는 실습에 필요한 파일, 디렉토리, 개발 환경 설정, 코드 파일, 그리고 VS Code 서버를 포함한 완성된 개발 환경이 포함된 이미지로 구성되어있음. 2. /config/workspace/cloud/container/00.container-linux와 같은 경로에 접근 가능한 이유는? 컨테이너 이미지 안에 이미 내장되어 있어서 컨테이너가 실행됨과 동시에 해당 경로가 자동으로 구성된다. 즉 디렉토리를 다운로드했다는 개념보다는 컨테이너 실행과 동시에 그 안에 포함된 실습 디렉토리가 자동 마운트되었다고 이해하는 것이 더 정확하다. 3. 볼륨으로 지정? Docker 컨테이너는 기본적으로 임시 환경이기 때문에, 컨테이너 내부에서 생성한 파일이나 수정한 내용은 컨테이너가 삭제되면 모두 함께 사라진다. 하지만 VOLUME 명령을 통해 지정된 경로는 영속적인 볼륨으로 연결되며, 컨테이너가 삭제되어도 해당 경로에 저장된 데이터는 유지된다. "/mycode"를 볼륨으로 지정하고 컨테이너 내부에서 /mycode 경로에 파일을 생성하거나 수정하면 그 경로가 호스트 시스템의 익명 볼륨에 저장되기 때문에 컨테이너가 종료되더라도 그대로 남아 있게 된다.</a></p><hr></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents></nav></div></aside></main></body></html>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on</title><link>https://yshghid.github.io/categories/java/</link><description>Recent content in Java on</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 02 Sep 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://yshghid.github.io/categories/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Java #2 객체지향 설계 원칙 SOLID</title><link>https://yshghid.github.io/docs/study/fe/fe19/</link><pubDate>Tue, 02 Sep 2025 00:00:00 +0000</pubDate><guid>https://yshghid.github.io/docs/study/fe/fe19/</guid><description>&lt;h1 id="java-2-객체지향-설계-원칙-solid"&gt;
 Java #2 객체지향 설계 원칙 SOLID
 &lt;a class="anchor" href="#java-2-%ea%b0%9d%ec%b2%b4%ec%a7%80%ed%96%a5-%ec%84%a4%ea%b3%84-%ec%9b%90%ec%b9%99-solid"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;#2025-09-02&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="목차"&gt;
 목차
 &lt;a class="anchor" href="#%eb%aa%a9%ec%b0%a8"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;단일 책임 원칙 (Single Responsibility Principle, SRP)&lt;/li&gt;
&lt;li&gt;개방-폐쇄 원칙 (Open-Closed Principle, OCP)&lt;/li&gt;
&lt;li&gt;리스코프 치환 원칙 (Liskov Substitution Principle, LSP)&lt;/li&gt;
&lt;li&gt;인터페이스 분리 원칙 (Interface Segregation Principle, ISP)&lt;/li&gt;
&lt;li&gt;의존 역전 원칙 (Dependency Inversion Principle, DIP)&lt;/li&gt;
&lt;li&gt;공통 특성: 응집도를 높이거나 결합도를 낮추는 설계&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=""&gt;
 
 &lt;a class="anchor" href="#"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;h3 id="1-단일-책임-원칙-single-responsibility-principle-srp"&gt;
 1. 단일 책임 원칙 (Single Responsibility Principle, SRP)
 &lt;a class="anchor" href="#1-%eb%8b%a8%ec%9d%bc-%ec%b1%85%ec%9e%84-%ec%9b%90%ec%b9%99-single-responsibility-principle-srp"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;&lt;mark&gt;#1 정의&lt;/mark&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;한 클래스는 하나의 책임만 가져야 하고 클래스가 변경되어야 할 이유는 오직 하나여야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=""&gt;
 
 &lt;a class="anchor" href="#"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;&lt;mark&gt;#2 SRP 위반 예제&lt;/mark&gt;&lt;/p&gt;</description></item><item><title>Java #1 객체지향 프로그래밍: 캡슐화, 추상화, 다형성, 상속</title><link>https://yshghid.github.io/docs/study/fe/fe20/</link><pubDate>Mon, 01 Sep 2025 00:00:00 +0000</pubDate><guid>https://yshghid.github.io/docs/study/fe/fe20/</guid><description>&lt;h1 id="java-1-객체지향-프로그래밍-캡슐화-추상화-다형성-상속"&gt;
 Java #1 객체지향 프로그래밍: 캡슐화, 추상화, 다형성, 상속
 &lt;a class="anchor" href="#java-1-%ea%b0%9d%ec%b2%b4%ec%a7%80%ed%96%a5-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d-%ec%ba%a1%ec%8a%90%ed%99%94-%ec%b6%94%ec%83%81%ed%99%94-%eb%8b%a4%ed%98%95%ec%84%b1-%ec%83%81%ec%86%8d"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;#2025-09-01&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="목차"&gt;
 목차
 &lt;a class="anchor" href="#%eb%aa%a9%ec%b0%a8"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;캡슐화&lt;/li&gt;
&lt;li&gt;추상화&lt;/li&gt;
&lt;li&gt;다형성&lt;/li&gt;
&lt;li&gt;상속&lt;/li&gt;
&lt;li&gt;공통 특성: 인터페이스와 구현의 분리&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=""&gt;
 
 &lt;a class="anchor" href="#"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;h3 id="1-캡슐화"&gt;
 1. 캡슐화
 &lt;a class="anchor" href="#1-%ec%ba%a1%ec%8a%90%ed%99%94"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;&lt;mark&gt;#1 개념 및 목적&lt;/mark&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;개념
&lt;ul&gt;
&lt;li&gt;객체지향 프로그래밍에서 객체의 속성(필드)을 외부로부터 숨기고, 공개된 메서드(getter/setter)를 통해서만 접근하도록 만드는 원칙&lt;/li&gt;
&lt;li&gt;필드를 private으로 선언하고, 외부에서 직접 접근하지 못하게 제한하고, public 메서드인 getter와 setter를 제공해 값을 읽거나 수정할 수 있도록 한다. setter 내부에는 유효성 검사 로직을 넣어 잘못된 값이 들어오는 것을 막을 수도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;목적
&lt;ol&gt;
&lt;li&gt;데이터 보호: 잘못된 값이 직접 들어가는 것을 막고, setter 내부에서 규칙을 강제함으로써 객체의 상태를 안정적으로 유지&lt;/li&gt;
&lt;li&gt;정보 은닉: 내부 구현이 어떻게 되어 있는지는 숨겨 두고, 외부에는 단순한 사용 방법만 제공함으로써 객체 사용자가 불필요한 복잡성을 신경 쓰지 않도록 한다.&lt;/li&gt;
&lt;li&gt;유지보수와 확장성: 내부 로직이 바뀌더라도 외부 인터페이스(getter/setter)가 같으면 사용하는 코드는 수정할 필요가 없으므로 프로그램 전체의 안정성이 높아지고 유지보수가 쉬워진다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=""&gt;
 
 &lt;a class="anchor" href="#"&gt;#&lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;&lt;mark&gt;#2 샘플 코드&lt;/mark&gt;&lt;/p&gt;</description></item></channel></rss>
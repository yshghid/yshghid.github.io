<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>알고리즘 on</title><link>https://yshghid.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/</link><description>Recent content in 알고리즘 on</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Fri, 01 Aug 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://yshghid.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/index.xml" rel="self" type="application/rss+xml"/><item><title>MutClust 코드 리펙토링 #2 arg_parser</title><link>https://yshghid.github.io/docs/study/algorithm/algo2/</link><pubDate>Fri, 01 Aug 2025 00:00:00 +0000</pubDate><guid>https://yshghid.github.io/docs/study/algorithm/algo2/</guid><description>&lt;h1 id="mutclust-코드-리펙토링-2-arg_parser">
 MutClust 코드 리펙토링 #2 arg_parser
 &lt;a class="anchor" href="#mutclust-%ec%bd%94%eb%93%9c-%eb%a6%ac%ed%8e%99%ed%86%a0%eb%a7%81-2-arg_parser">#&lt;/a>
&lt;/h1>
&lt;p>#2025-08-01&lt;/p>
&lt;hr>
&lt;p>MutClust 알고리즘의 코드 구성은 아래와 같은데&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span>MutClust
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── sc/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── lib.py
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── arg_parser.py // 실행 설정
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── utils.py
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── Test
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>arg_parser.py는 실험 환경 파라미터 세팅 및 CLI 인자 파싱을 포함한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># === arg_parser.py ===&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">import&lt;/span> argparse
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">from&lt;/span> os.path &lt;span style="color:#fff;font-weight:bold">import&lt;/span> exists
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">from&lt;/span> src.mlib &lt;span style="color:#fff;font-weight:bold">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DIMINISHING_FACTOR, EPSILON, EPSILON_SCALING_FACTOR,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MAX_EPS, MIN_CLUSTER_LENGTH, CCM_MIN_PERCENTAGE_SUM
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">class&lt;/span> ArgsInfo:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">def&lt;/span> __init__(&lt;span style="color:#fff;font-weight:bold">self&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.args = {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.fin = &lt;span style="color:#0ff;font-weight:bold">&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.ref = &lt;span style="color:#0ff;font-weight:bold">&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.outdir = &lt;span style="color:#0ff;font-weight:bold">&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.eps = EPSILON
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.maxeps = MAX_EPS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.min_persum = CCM_MIN_PERCENTAGE_SUM
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.eps_scaler_const = EPSILON_SCALING_FACTOR
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.es_control_const = DIMINISHING_FACTOR
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">self&lt;/span>.min_cluster_length = MIN_CLUSTER_LENGTH
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> set_env(input_path=&lt;span style="color:#fff;font-weight:bold">None&lt;/span>, reference=&lt;span style="color:#fff;font-weight:bold">None&lt;/span>, output_path=&lt;span style="color:#fff;font-weight:bold">None&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> info = ArgsInfo()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parser = argparse.ArgumentParser(prog=&lt;span style="color:#0ff;font-weight:bold">&amp;#34;cluster.py&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parser.add_argument(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;-f&amp;#39;&lt;/span>, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;--input_file&amp;#39;&lt;/span>, &lt;span style="color:#fff;font-weight:bold">type&lt;/span>=&lt;span style="color:#fff;font-weight:bold">str&lt;/span>, default=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;/data3/projects/2020_MUTCLUST/Data/Rawdata/COVID19/nucleotide_data/mutclust_input_data.txt&amp;#39;&lt;/span>, help=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;mutation frequency data file&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parser.add_argument(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;-r&amp;#39;&lt;/span>, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;--ref&amp;#39;&lt;/span>, &lt;span style="color:#fff;font-weight:bold">type&lt;/span>=&lt;span style="color:#fff;font-weight:bold">str&lt;/span>, default=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;/data3/projects/2020_MUTCLUST/Data/Rawdata/COVID19/nucleotide_data/new_reference.fasta&amp;#39;&lt;/span>, help=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;the reference genome&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parser.add_argument(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;-e&amp;#39;&lt;/span>, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;--eps&amp;#39;&lt;/span>, &lt;span style="color:#fff;font-weight:bold">type&lt;/span>=&lt;span style="color:#fff;font-weight:bold">int&lt;/span>, default=EPSILON, help=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;width of window (epsilon)&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parser.add_argument(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;--maxeps&amp;#39;&lt;/span>, &lt;span style="color:#fff;font-weight:bold">type&lt;/span>=&lt;span style="color:#fff;font-weight:bold">int&lt;/span>, default=MAX_EPS, help=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;maximum eps&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parser.add_argument(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;--minps&amp;#39;&lt;/span>, &lt;span style="color:#fff;font-weight:bold">type&lt;/span>=&lt;span style="color:#fff;font-weight:bold">float&lt;/span>, default=CCM_MIN_PERCENTAGE_SUM, help=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;minimum per_sum&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parser.add_argument(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;--es&amp;#39;&lt;/span>, &lt;span style="color:#fff;font-weight:bold">type&lt;/span>=&lt;span style="color:#fff;font-weight:bold">float&lt;/span>, default=EPSILON_SCALING_FACTOR, help=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;eps scaling factor&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parser.add_argument(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;--exd&amp;#39;&lt;/span>, &lt;span style="color:#fff;font-weight:bold">type&lt;/span>=&lt;span style="color:#fff;font-weight:bold">float&lt;/span>, default=DIMINISHING_FACTOR, help=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;cluster expansion es diminishing factor&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parser.add_argument(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;--minl&amp;#39;&lt;/span>, &lt;span style="color:#fff;font-weight:bold">type&lt;/span>=&lt;span style="color:#fff;font-weight:bold">int&lt;/span>, default=MIN_CLUSTER_LENGTH, help=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;minimum cluster length&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> args = parser.parse_args()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> info.fin = input_path &lt;span style="color:#fff;font-weight:bold">if&lt;/span> input_path &lt;span style="color:#fff;font-weight:bold">else&lt;/span> args.input_file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> info.ref = reference &lt;span style="color:#fff;font-weight:bold">if&lt;/span> reference &lt;span style="color:#fff;font-weight:bold">else&lt;/span> args.ref
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> info.outdir = output_path &lt;span style="color:#fff;font-weight:bold">if&lt;/span> output_path &lt;span style="color:#fff;font-weight:bold">else&lt;/span> &lt;span style="color:#0ff;font-weight:bold">&amp;#39;./output&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> not exists(info.fin):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34;Input file does not exist: &lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>info.fin&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exit()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> info.eps = args.eps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> info.maxeps = args.maxeps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> info.min_persum = args.minps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> info.eps_scaler_const = args.es
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> info.es_control_const = args.exd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> info.min_cluster_length = args.minl
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> info
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>MutClust 코드 리펙토링 #3 utils</title><link>https://yshghid.github.io/docs/study/algorithm/algo9/</link><pubDate>Fri, 01 Aug 2025 00:00:00 +0000</pubDate><guid>https://yshghid.github.io/docs/study/algorithm/algo9/</guid><description>&lt;h1 id="mutclust-코드-리펙토링-3-utils">
 MutClust 코드 리펙토링 #3 utils
 &lt;a class="anchor" href="#mutclust-%ec%bd%94%eb%93%9c-%eb%a6%ac%ed%8e%99%ed%86%a0%eb%a7%81-3-utils">#&lt;/a>
&lt;/h1>
&lt;p>#2025-08-01&lt;/p>
&lt;hr>
&lt;p>MutClust 알고리즘의 코드 구성은 아래와 같은데&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span>MutClust
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── sc/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── lib.py
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── arg_parser.py
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ └── utils.py // 전처리 및 분석
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── Test
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>utils.py는 데이터 전처리 및 분석 함수를 포함한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># === Fasta 전처리 ===&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> fasta2csv(home_dir, nation_dir, filechunk, ref, outdir):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> file in filechunk:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path = os.path.join(home_dir, nation_dir, file)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filename = os.path.splitext(os.path.basename(file))[&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> outpath = os.path.join(outdir, &lt;span style="color:#0ff;font-weight:bold">f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>filename&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">.csv&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> not os.path.exists(outpath):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df = DataFrame({&lt;span style="color:#0ff;font-weight:bold">&amp;#39;ref&amp;#39;&lt;/span>: ref.values, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;pos&amp;#39;&lt;/span>: ref.index})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seq = &lt;span style="color:#0ff;font-weight:bold">&amp;#39;&amp;#39;&lt;/span>.join(&lt;span style="color:#fff;font-weight:bold">open&lt;/span>(path).readlines()[&lt;span style="color:#ff0;font-weight:bold">1&lt;/span>:]).strip()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df[&lt;span style="color:#0ff;font-weight:bold">&amp;#39;mut&amp;#39;&lt;/span>] = [a &lt;span style="color:#fff;font-weight:bold">if&lt;/span> a != ref[i] &lt;span style="color:#fff;font-weight:bold">else&lt;/span> &lt;span style="color:#0ff;font-weight:bold">&amp;#39;&amp;#39;&lt;/span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> i, a in &lt;span style="color:#fff;font-weight:bold">enumerate&lt;/span>(seq)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df.to_csv(outpath, index=&lt;span style="color:#fff;font-weight:bold">False&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> gisaid_fasta2csv(homedir=&lt;span style="color:#0ff;font-weight:bold">f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>GISAID_DIR&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">/Sequence/Preprocessed/&amp;#34;&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inputdir = os.path.join(homedir, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;MSA_fasta&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> outdir = os.path.join(homedir, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;MSA_mutationinfo&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Path(outdir).mkdir(exist_ok=&lt;span style="color:#fff;font-weight:bold">True&lt;/span>, parents=&lt;span style="color:#fff;font-weight:bold">True&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> core_n = &lt;span style="color:#ff0;font-weight:bold">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> args_list = []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> nation_dir in get_dirnames_list(inputdir):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filelist = get_filenames_list(os.path.join(inputdir, nation_dir))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> chunk in array_split(filelist, core_n):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> args_list.append((inputdir, nation_dir, chunk, ref_seq, outdir))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">with&lt;/span> Pool(core_n) &lt;span style="color:#fff;font-weight:bold">as&lt;/span> pool:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pool.map(fasta2csv, args_list)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># === Nucleotide 전처리 ===&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> get_nucleotide_sequence_dict(seq_dir):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seq_dict = &lt;span style="color:#fff;font-weight:bold">dict&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seq_list = get_filenames_list(seq_dir)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> file in seq_list:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filepath = os.path.join(seq_dir, file)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df = read_csv(filepath, index_col=&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df.name = file.split(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;.&amp;#39;&lt;/span>)[&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df = df.reset_index(drop=&lt;span style="color:#fff;font-weight:bold">True&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seq_dict[df.name] = df
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> seq_dict
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> getNucleotideRefSeqbyGene():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> read_csv(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;/data3/projects/2020_MUTCLUST/Data/Annotation/Nucleotide/covid_annotation.tsv&amp;#39;&lt;/span>, sep=&lt;span style="color:#0ff;font-weight:bold">&amp;#39; &amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> make_nucleotide_mutclust_input(outdir, name, seq_dict=&lt;span style="color:#fff;font-weight:bold">None&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> not os.path.exists(outdir):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(outdir + &lt;span style="color:#0ff;font-weight:bold">&amp;#39; is not exist&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> output_path = os.path.join(outdir, name + &lt;span style="color:#0ff;font-weight:bold">&amp;#39;_mutclust_input.tsv&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> freq_df_ATGC_path = os.path.join(outdir, name + &lt;span style="color:#0ff;font-weight:bold">&amp;#39;_freq_ATGC.csv&amp;#39;&lt;/span>) 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pos_list, freq_list, per_list, entropy_list = [], [], [], []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> not os.path.exists(freq_df_ATGC_path):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> seq_dict is &lt;span style="color:#fff;font-weight:bold">None&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;load seq_dict&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> freq_df = DataFrame.from_dict(seq_dict).transpose().fillna(&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>).astype(&lt;span style="color:#fff;font-weight:bold">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> freq_df = freq_df.sort_index()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> freq_df = freq_df[&lt;span style="color:#fff;font-weight:bold">list&lt;/span>(IUPAC_CODES.keys())][[&lt;span style="color:#0ff;font-weight:bold">&amp;#39;A&amp;#39;&lt;/span>,&lt;span style="color:#0ff;font-weight:bold">&amp;#39;T&amp;#39;&lt;/span>,&lt;span style="color:#0ff;font-weight:bold">&amp;#39;G&amp;#39;&lt;/span>,&lt;span style="color:#0ff;font-weight:bold">&amp;#39;C&amp;#39;&lt;/span>]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> freq_df.to_csv(freq_df_ATGC_path)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> freq_df = read_csv(freq_df_ATGC_path, index_col=&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> pos in freq_df.index:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> freq = freq_df.loc[pos]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cnt_n = freq.sum()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> percentage = freq / cnt_n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> entrpy = entropy(percentage, base=&lt;span style="color:#ff0;font-weight:bold">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> percentage.drop(ref_seq[pos], inplace=&lt;span style="color:#fff;font-weight:bold">True&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> freq.drop(ref_seq[pos], inplace=&lt;span style="color:#fff;font-weight:bold">True&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pos_list.append(&lt;span style="color:#fff;font-weight:bold">int&lt;/span>(pos))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> freq_list.append(freq.sum())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> per_list.append(percentage.sum())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> entropy_list.append(entrpy)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mutclust_input_df = DataFrame({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0ff;font-weight:bold">&amp;#39;Position&amp;#39;&lt;/span>: pos_list,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0ff;font-weight:bold">&amp;#39;Frequency&amp;#39;&lt;/span>: freq_list,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0ff;font-weight:bold">&amp;#39;Percentages&amp;#39;&lt;/span>: per_list,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0ff;font-weight:bold">&amp;#39;Entropy&amp;#39;&lt;/span>: entropy_list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mutclust_input_df.to_csv(output_path, sep=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\t&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>, index=&lt;span style="color:#fff;font-weight:bold">False&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> mutclust_input_df
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># === Mutation 데이터 병렬 처리 ===&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> read_thead(filepathlist, return_list, i):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ref_seq_sr = getNucleotideRefSeq()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sub_dict = {pos: Counter({k: &lt;span style="color:#ff0;font-weight:bold">0&lt;/span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> k in IUPAC_CODES.keys()}) &lt;span style="color:#fff;font-weight:bold">for&lt;/span> pos in ref_seq_sr.index}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> filepath in filepathlist:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df = read_csv(filepath, index_col=&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>).fillna(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&amp;#39;&lt;/span>).reset_index(drop=&lt;span style="color:#fff;font-weight:bold">True&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> index, mut in &lt;span style="color:#fff;font-weight:bold">enumerate&lt;/span>(df[&lt;span style="color:#0ff;font-weight:bold">&amp;#39;mut&amp;#39;&lt;/span>]):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> symbol = mut &lt;span style="color:#fff;font-weight:bold">if&lt;/span> mut &lt;span style="color:#fff;font-weight:bold">else&lt;/span> ref_seq_sr[index + &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> symbol in sub_dict[index + &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sub_dict[index + &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>][symbol] += &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sub_dict[index + &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>][symbol] = &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> return_list.append(sub_dict)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>i&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">th process complete!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> merge_thread(poslist, sub_dict_list, return_dict):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> pos in poslist:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count_dict = &lt;span style="color:#fff;font-weight:bold">sum&lt;/span>([d[pos] &lt;span style="color:#fff;font-weight:bold">for&lt;/span> d in sub_dict_list], Counter())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> merged_dict = {k: count_dict.get(k, &lt;span style="color:#ff0;font-weight:bold">0&lt;/span>) &lt;span style="color:#fff;font-weight:bold">for&lt;/span> k in IUPAC_CODES.keys()}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> return_dict[pos] = merged_dict
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> load_mutationinfo(input_dir=COVID19_MUTATIONINFO_DIR, sample_list=&lt;span style="color:#fff;font-weight:bold">None&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> core_n, split_n = &lt;span style="color:#ff0;font-weight:bold">100&lt;/span>, &lt;span style="color:#ff0;font-weight:bold">1000&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sub_dict_list = Manager().list()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filelist = get_file_paths_recursive(input_dir)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> sample_list:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filelist = [f &lt;span style="color:#fff;font-weight:bold">for&lt;/span> f in filelist &lt;span style="color:#fff;font-weight:bold">if&lt;/span> os.path.basename(f).split(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;.&amp;#39;&lt;/span>)[&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>] in sample_list]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;sample_n: &lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>&lt;span style="color:#fff;font-weight:bold">len&lt;/span>(sample_list)&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> splited_filepaths = array_split(filelist, split_n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parameter_list = [(chunk, sub_dict_list, i) &lt;span style="color:#fff;font-weight:bold">for&lt;/span> i, chunk in &lt;span style="color:#fff;font-weight:bold">enumerate&lt;/span>(splited_filepaths)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;read thread start!&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> multi_processing(read_thead, parameter_list, core_n=core_n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;read thread end!&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> merged_dict = Manager().dict()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> poslist = ref_seq.index
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> splited_poslist = array_split(poslist, split_n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sub_dict_list = &lt;span style="color:#fff;font-weight:bold">list&lt;/span>(sub_dict_list)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parameter_list = [(pos_chunk, sub_dict_list, merged_dict) &lt;span style="color:#fff;font-weight:bold">for&lt;/span> pos_chunk in splited_poslist]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;merge thread start!&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> multi_processing(merge_thread, parameter_list, core_n=core_n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;merge thread end!&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> &lt;span style="color:#fff;font-weight:bold">dict&lt;/span>(merged_dict)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># === Matrix 생성 병렬 처리 ===&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> make_matrix_thread(file_list):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clusters_df = pd.read_csv(os.path.join(GISAID_MUTCLUST_OUTPUT_DIR, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;clusters_hscore.txt&amp;#39;&lt;/span>), sep=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\t&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> column_list = [&lt;span style="color:#0ff;font-weight:bold">f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#34;c&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>i&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">(&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>row[&lt;span style="color:#0ff;font-weight:bold">&amp;#39;left_position&amp;#39;&lt;/span>]&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">,&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>row[&lt;span style="color:#0ff;font-weight:bold">&amp;#39;right_position&amp;#39;&lt;/span>]&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">)&amp;#34;&lt;/span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> i, row in clusters_df.iterrows()]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cluster_df = pd.DataFrame(columns=column_list)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> path in file_list:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df = pd.read_csv(path)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> patient_name = os.path.splitext(os.path.basename(path))[&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cluster_df.loc[patient_name] = &lt;span style="color:#ff0;font-weight:bold">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> pos in df[df[&lt;span style="color:#0ff;font-weight:bold">&amp;#39;mut&amp;#39;&lt;/span>].notnull()][&lt;span style="color:#0ff;font-weight:bold">&amp;#39;pos&amp;#39;&lt;/span>]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cluster_idx = clusters_df[(clusters_df[&lt;span style="color:#0ff;font-weight:bold">&amp;#39;left_position&amp;#39;&lt;/span>] &amp;lt;= pos) &amp;amp; (pos &amp;lt;= clusters_df[&lt;span style="color:#0ff;font-weight:bold">&amp;#39;right_position&amp;#39;&lt;/span>])].index
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cluster_df.loc[patient_name][cluster_idx] += &lt;span style="color:#ff0;font-weight:bold">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">return&lt;/span> cluster_df
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> make_matrix(mutationinfo_dir, out_dir, tag, cpu_n=&lt;span style="color:#ff0;font-weight:bold">60&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(&lt;span style="color:#0ff;font-weight:bold">&amp;#39;starting make matrix!&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pool = Pool(processes=cpu_n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> file_list = get_file_paths_recursive(mutationinfo_dir)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> results = pool.map(make_matrix_thread, array_split(file_list, cpu_n))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pd.concat(results).to_csv(os.path.join(out_dir, &lt;span style="color:#0ff;font-weight:bold">f&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;cluster_matrix_&lt;/span>&lt;span style="color:#0ff;font-weight:bold">{&lt;/span>tag&lt;span style="color:#0ff;font-weight:bold">}&lt;/span>&lt;span style="color:#0ff;font-weight:bold">.csv&amp;#39;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pool.close()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pool.join()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># === H-score 계산 ===&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> add_HSCORE():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df = pd.read_csv(os.path.join(MUTCLUST_INPUT_DIR, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;gisaid_mutclust_input.tsv&amp;#39;&lt;/span>), sep=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\t&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df[HSCORE] = df[PER] * df[ENT]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df.to_csv(os.path.join(MUTCLUST_INPUT_DIR, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;gisaid_mutclust_input_with_score.tsv&amp;#39;&lt;/span>), sep=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\t&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>, index=&lt;span style="color:#fff;font-weight:bold">False&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># === 주석(Annotation) ===&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> annotation():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">import&lt;/span> ast
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mapping_df = pd.read_csv(os.path.join(GISAID_METADATA_DIR, &lt;span style="color:#0ff;font-weight:bold">&amp;#39;merged_info.tsv&amp;#39;&lt;/span>), sep=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\t&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>, index_col=&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> i, row in mapping_df.iterrows():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mapping_df.loc[i] = [ast.literal_eval(val) &lt;span style="color:#fff;font-weight:bold">for&lt;/span> val in row]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(mapping_df)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> make_clade_divide_mutation():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clade_dir = &lt;span style="color:#0ff;font-weight:bold">&amp;#39;./clade_divide_mutation&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> start_dict = getStartDict()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> file in get_filenames_list(clade_dir):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> df = read_csv(os.path.join(clade_dir, file), sep=&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>&lt;span style="color:#0ff;font-weight:bold">\t&lt;/span>&lt;span style="color:#0ff;font-weight:bold">&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">print&lt;/span>(df)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># === 병렬 처리 유틸리티 ===&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">def&lt;/span> multi_processing(func, parameter_list, core_n=&lt;span style="color:#ff0;font-weight:bold">100&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> proc, proc_excution, proc_end = [], [], []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> param in parameter_list:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> proc.append(Process(target=func, args=param))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">while&lt;/span> proc or proc_excution:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> _ in &lt;span style="color:#fff;font-weight:bold">range&lt;/span>(&lt;span style="color:#fff;font-weight:bold">len&lt;/span>(proc)):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> &lt;span style="color:#fff;font-weight:bold">len&lt;/span>(proc_excution) &amp;lt; core_n:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p = proc.pop(&lt;span style="color:#ff0;font-weight:bold">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p.start()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> proc_excution.append(p)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">for&lt;/span> p in proc_excution[:]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fff;font-weight:bold">if&lt;/span> not p.is_alive():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> proc_excution.remove(p)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p.join()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p.close()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> proc_end.append(p)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007f7f"># === 메인 실행 ===&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fff;font-weight:bold">if&lt;/span> __name__ == &lt;span style="color:#0ff;font-weight:bold">&amp;#39;__main__&amp;#39;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> annotation()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>
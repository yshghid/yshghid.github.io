---
date : 2026-02-08
tags: ['2026-02']
categories: ['BE', 'AWS']
bookHidden: true
title: "AWS #5 SiLok 프로젝트 ECS 파이프라인 빌드"
---

# AWS #5 SiLok 프로젝트 ECS 파이프라인 빌드

#2026-02-08

---

#1 

StudyNote와 동일한 방식으로 ECS 파이프라인을 빌드했고 파일 구조는 아래와 같다

```plain text
VitalTime/
├── backend/Dockerfile              # Python 3.11 + ML libs, 포트 8001
├── frontend/
│   ├── Dockerfile                   # nginx:alpine, 정적 파일 서빙
│   ├── nginx.conf                   # SPA 라우팅 + 캐싱
│   └── docker-entrypoint.sh         # 런타임 config.js 생성 (API키 주입)
├── docker-compose.yml               # 로컬: backend + frontend + postgres
├── .github/workflows/deploy.yml     # CI/CD: test → ECR push → ECS 배포
├── .aws/
│   ├── task-definition-backend.json  # Fargate 1vCPU/4GB (ML용)
│   └── task-definition-frontend.json # Fargate 0.25vCPU/512MB
└── terraform/main.tf                # VPC, ECS, ALB, ECR, RDS PostgreSQL
```

차이점은 아래와같다고 함.

1. 백엔드: CPU 1024 / 메모리 4096 (tensorflow + torch 때문에 더 큰 리소스)
2. RDS PostgreSQL 추가 (db.t3.micro, 14버전)
3. SSM Parameter Store로 DATABASE_URL, OPENAI_API_KEY 관리
4. ALB 라우팅: /api/*, /health, /db-health, /schedule-status → 백엔드
5. 프론트엔드: 빌드 없이 정적 파일 복사 (CDN Vue이므로)
6. docker-entrypoint.sh로 런타임에 config.js 생성 (Google Maps API 키 등)

그리고 안내받은 배포 순서.

```bash
# 1. terraform 초기화 및 인프라 생성
cd VitalTime/terraform
terraform init
terraform plan -var="db_password=mypassword"
terraform apply -var="db_password=mypassword"

# 2. GitHub Secrets 추가
# AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY

# 3. SSM에 시크릿 저장
aws ssm put-parameter --name "/vitaltime/OPENAI_API_KEY" --type SecureString --value "sk-..."
aws ssm put-parameter --name "/vitaltime/DATABASE_URL" --type SecureString --value "postgresql+asyncpg://..."

# 4. RDS에 초기 데이터 로드
psql -h <RDS_ENDPOINT> -U myuser -d mydatabase -f data/dump.sql

# 5. main에 push하면 자동 배포
git push origin main
```

1. SSH 키 생성 (없다면):


ssh-keygen -t rsa -b 4096 -f ~/.ssh/vitaltime-bastion -N ""
2. Terraform apply (키 경로 지정):


cd /Users/yshmbid/Documents/home/github/VitalTime/terraform
terraform apply -var="db_password=mypassword" -var="bastion_public_key=$(cat ~/.ssh/vitaltime-bastion.pub)"
3. SSH 터널링 (apply 완료 후):


# RDS 엔드포인트와 Bastion IP 확인
terraform output rds_endpoint
terraform output bastion_public_ip

# SSH 터널 (로컬 5433 → RDS 5432)
ssh -i ~/.ssh/vitaltime-bastion -L 5433:<RDS_ENDPOINT> ec2-user@<BASTION_IP> -N
4. 다른 터미널에서 데이터 로드:


psql -h localhost -p 5433 -U myuser -d mydatabase -f /Users/yshmbid/Documents/home/github/VitalTime/data/dump.sql


```yaml
version: '3.8'

services:
  postgres_db:
    image: pgvector/pgvector:pg16
    container_name: my_postgres_db
    environment:
      POSTGRES_USER: myuser
      POSTGRES_PASSWORD: mypassword
      POSTGRES_DB: mydatabase
    ports:
      - "5433:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped

volumes:
  postgres_data:
```
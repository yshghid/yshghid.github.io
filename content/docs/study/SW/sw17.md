---
date : 2025-08-04
tags: ['2025-08']
categories: ['SW']
bookHidden: true
title: "Docker #4 3일차 실습: 자신의 Frontend (HTML, JS, CSS) 개발 코드를 컨테이너로 만들고 이것을 실행시켜 보자"
---

# Docker #4 3일차 실습: 자신의 Frontend (HTML, JS, CSS) 개발 코드를 컨테이너로 만들고 이것을 실행시켜 보자

#2025-08-04

---

> 조건
> 
> 1. nginx:alpine 이미지를 사용
> 2. 노출 Port는80
> 3. nginx를실행하는방식은 -nginx -g daemon off;
> 4. nginx의 routing 설정은 default.conf에설정한다.

### 0. 작업 위치

```shell
$ pwd
/Users/yshmbid/rde/config/workspace/exec-template

$ ls
Dockerfile      default.conf    deploy          deploy.yaml     docker-build.sh docker-push.sh  service.yaml    src
```

### 1. docker-build.sh와 docker-push.sh 복사

```shell
$ pwd
/Users/yshmbid/rde/config/workspace/container/05.webserver
$ ls
Dockerfile      default.conf    deploy          docker-build.sh docker-push.sh  src
```

05.webserver의 docker-build.sh와 docker-push.sh를 작업 디렉토리인 exec-template로 복사해준다.

```shell
# docker-build.sh

#!/bin/bash
NAME=sk019
IMAGE_NAME="healthcheck-server" #IMAGE_NAME="webserver"

VERSION="1.0.0"
CPU_PLATFORM=arm64 #amd64

# Docker 이미지 빌드
docker build \
  --tag ${NAME}-${IMAGE_NAME}:${VERSION} \
  --file Dockerfile \
  --platform linux/${CPU_PLATFORM} \
  ${IS_CACHE} .
```
```shell
# docker-push.sh

#!/bin/bash
NAME=sk019
IMAGE_NAME="healthcheck-server" #IMAGE_NAME="webserver"

VERSION="1.0.0"

DOCKER_REGISTRY="amdp-registry.skala-ai.com/skala25a"
DOCKER_REGISTRY_USER="robot\$skala25a"
DOCKER_REGISTRY_PASSWORD="1qB9cyusbNComZPHAdjNIFWinf52xaBJ"
DOCKER_CACHE="--no-cache"

# 1. Docker 레지스트리에 로그인 (옵션: 이 스크립트를 실행하기 전에 미리 로그인해두어도 됩니다)
echo ${DOCKER_REGISTRY_PASSWORD} | docker login ${DOCKER_REGISTRY} \
	-u ${DOCKER_REGISTRY_USER}  --password-stdin \
   	|| { echo "Docker 로그인 실패"; exit 1; }

# 2. harbor 로 push 하기 위해 tag 추가
docker tag  ${NAME}-${IMAGE_NAME}:${VERSION} ${DOCKER_REGISTRY}/${NAME}-${IMAGE_NAME}:${VERSION}

# Docker 이미지 푸시
docker push ${DOCKER_REGISTRY}/${NAME}-${IMAGE_NAME}:${VERSION}
```

### 2. Dockerfile과 default.conf 작성

```shell
# Dockerfile

# nginx 기반 이미지 사용
FROM nginx:alpine

# 커스텀 nginx 설정 파일 복사
COPY default.conf /etc/nginx/conf.d/

# nginx 포트 노출
EXPOSE 80

# nginx 실행 (기본 CMD가 이미 설정되어 있음)
CMD ["nginx", "-g", "daemon off;"]
```
```shell
# default.conf 

server {
    listen 80;
    
    # 정적 파일 서빙
    location /sk019 {
        alias /usr/share/nginx/html/;
        try_files $uri $uri/ /index.html;
        
    }
}
```

### 3. 파일 구조

```plain text
/workspace
└── exec-template
     ├── Dockerfile
     ├── default.conf
     ├── docker-build.sh
     ├── docker-push.sh
     ├── cicd.sh
     ├── deploy/
     │   ├── deploy.t       
     │   ├── service.t
     │   └── env.properties
     └── src/
         ├── index.html      
         └── media/ 
```

src 디렉토리에 index.html을 넣어줬다.

#5 이미지 push build + docker run

```shell
$ sudo ./docker-push.sh
$ sudo ./docker-build.sh
$ sudo docker run -d --name posts-get --network bridge -p 8888:80 sk019-posts-get.arm64:1.0
```




#



#2 cicd.sh 작성

```shell
#!/bin/bash

# 기본값 설정
ENV_FILE="env.properties"

# usage 출력 함수
usage() {
  echo "Usage: $0 [-b|--build] [-p|--push] [-y|--yaml] [-d|--deploy] [-r|--remove] [-a|--all] [-f|--file <env file>]"
  exit 1
}

# env.properties 로드 함수
load_env() {
  if [ -f "$ENV_FILE" ]; then
    source "$ENV_FILE"
  else
    echo "환경 파일 '$ENV_FILE'을 찾을 수 없습니다."
    exit 1
  fi
}

# Maven Build
build() {
  echo "🔨 Maven 빌드 시작..."
  mvn clean package
}

# Docker 이미지 build & push
push_image() {
  echo "🐳 Docker 이미지 생성 및 push 시작..."
  docker build -t $DOCKER_IMAGE_NAME .
  docker push $DOCKER_IMAGE_NAME
}

# YAML 생성
generate_yaml() {
  echo "📄 YAML 파일 생성 중..."
  for file in *.t; do
    [ -e "$file" ] || continue
    cp "$file" "${file%.t}.yaml"
  done
}

# K8s에 배포
deploy_k8s() {
  echo "🚀 Kubernetes에 배포 시작..."
  kubectl apply -f ./*.yaml
}

# K8s 리소스 삭제
remove_k8s() {
  echo "🗑️ Kubernetes 리소스 제거..."
  kubectl delete -f ./*.yaml
}

# 전체 실행
run_all() {
  load_env
  build
  push_image
  generate_yaml
  deploy_k8s
}

# 인자 파싱
while [[ "$#" -gt 0 ]]; do
  case "$1" in
    -b|--build) ACTION_BUILD=1 ;;
    -p|--push) ACTION_PUSH=1 ;;
    -y|--yaml) ACTION_YAML=1 ;;
    -d|--deploy) ACTION_DEPLOY=1 ;;
    -r|--remove) ACTION_REMOVE=1 ;;
    -a|--all) ACTION_ALL=1 ;;
    -f|--file)
      shift
      ENV_FILE="$1"
      ;;
    -h|--help)
      usage
      ;;
    *)
      echo "❌ 알 수 없는 옵션: $1"
      usage
      ;;
  esac
  shift
done

# 실행 조건
if [[ $ACTION_ALL ]]; then
  run_all
else
  load_env
  [[ $ACTION_BUILD ]] && build
  [[ $ACTION_PUSH ]] && push_image
  [[ $ACTION_YAML ]] && generate_yaml
  [[ $ACTION_DEPLOY ]] && deploy_k8s
  [[ $ACTION_REMOVE ]] && remove_k8s
fi
```

cicd.sh 사용하는 부분이 나오는데 ppt랑 workspace 디렉토리 안에 아무리찾아봐도 없어서... 그냥 챗지피티에넣고 만들었다.

참고로 deploy.t와 service.t는?

```shell
# deploy.t

apiVersion: apps/v1
kind: Deployment
metadata:
  name: sk019-posts-get
  namespace: skala-practice
spec:
  replicas: 1
  selector:
    matchLabels:
      app: sk019-posts-get
  template:
    metadata:
      labels:
        app: sk019-posts-get
    spec:
      containers:
        #- name: posts-get amdp-registry.skala-ai.com/skala25a/sk019-posts-get.amd64:1.0
        - name: posts-get amdp-registry.skala-ai.com/skala25a/sk019-posts-get.arm64:1.0
          ports:
            - containerPort: 80
```
```shell
# service.t

apiVersion: v1
kind: Service
metadata:
  name: ${USER_NAME}-${SERVICE_NAME}
  namespace: ${NAMESPACE}
spec:
  selector:
    app: ${USER_NAME}-${SERVICE_NAME}
  ports:
    - name: http
      protocol: TCP
      port: 8888 #8080
      targetPort: 80
  type: ClusterIP
```

- service.t는 원래 8080 돼있었는데 8888 같아서 바꿔줌.
- 맥이라서 arm으로 바꿔줌. 
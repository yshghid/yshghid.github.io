---
date : 2025-09-17
tags: ['2025-09']
categories: ['SW']
bookHidden: true
title: "FastAPI #1"
---

# FastAPI #1

#2025-09-17

---

<mark>#1 maria db container 띄우기</mark>

```bash
# 1. conda 가상환경 생성
$ conda create -n demo-app python=3.11
$ conda activate demo-app

# 2. 작업 위치
# mariadb_tmplt 디렉토리를 다운받고 압축 해제함
$ pwd
/Users/yshmbid/Documents/home/github/MLops/mariadb_tmplt
$ ls
conf.d          data            env             maria_db.yaml

# 3. Docker Compose로 MariaDB 실행
$ docker compose -p maria_db -f maria_db.yaml up -d

# 4. 컨테이너가 잘떴는지확인
$ docker ps | grep mariadb
ae333f330cc4   mariadb:10.5.18     "docker-entrypoint.s…"   4 minutes ago   Up 4 minutes   0.0.0.0:3379->3306/tcp           maria_db-sqldb-1
```

- docker desktop에서도 확인

<img width="1920" height="1080" alt="image" src="https://github.com/user-attachments/assets/e187b804-476e-4939-b271-966cc2035c40" />


###

<mark>#2 db connection</mark>

- vscode에서 database client extension 열고 create connection

<img width="3360" height="2100" alt="image" src="https://github.com/user-attachments/assets/df73acd3-1e4a-476b-b1a3-bc60a35dddaf" />

###

<mark>cf) 컨테이너 기반 실습 환경을 구성하는 이유와 장점</mark>

- 컨테이너 기반 실습 환경을 구성하는 이유
  - 목적1: 모두가 똑같은 환경에서 실습을 하기 위해
    - 내부에서 설치된 라이브러리 버전이나 운영체제 차이 때문에 동일한 python-app.py를 실행해도 실행이안대거나 오류가날수있다.
    - Docker 컨테이너라는 상자 안에 Python 실행 환경을 일정하게 담아두고 Mac이든 Windows든 그 상자를 똑같이 실행시키면 누구든 동일한 환경에서 같은 결과를 낼수있으니까 환경 차이로 인한 오류가 없어진다
  - 목적2: 작업 환경을 제한
    - 단순히 Python 코드만 실행하는 것이 아니라 데이터베이스(DBMS)까지 연결해야 할 때가 많은데 오픈소스 데이터베이스인 MySQL이나 MariaDB 같은 프로그램을 직접 로컬에 설치할 수도 있지만 얘네는 운영체제에 따라 설치 과정이 복잡하고 하드웨어 자원에 의존적이라 충돌이나 오류가 발생하기 쉬운프로그램들이다. 
    - Docker 컨테이너를 사용하면 데이터베이스를 별도의 격리된 공간에서 실행할 수 있다. FastAPI를 실행하는 컨테이너 하나, MySQL을 실행하는 컨테이너 하나를 띄워두고, 이 둘을 내부 네트워크로 연결해주는 식으로 작업하면 데이터베이스나 Python 실행 환경이 호스트 컴퓨터 전체를 더럽히지 않고, 필요 없을 때 컨테이너만 지우면 깨끗하게 정리된다.

###


<mark>#3</mark>

```bash
# 5. 필요 패키지 설치
pip install fastapi "uvicorn[standard]"
pip install -r pjt-requirements.txt

# 6. 실행 위치
$ pwd
/Users/yshmbid/Documents/home/github/MLops/skala-fastapi-rpt
$ ls
api                     container               pjt-main.py             pjt-requirements.txt    test-requirements.txt

# 7. uvicorn 실행
$ uvicorn api.main:app --host 127.0.0.1 --port 8001 --reload
INFO:     Will watch for changes in these directories: ['/Users/yshmbid/Documents/home/github/MLops/skala-fastapi-rpt']
INFO:     Uvicorn running on http://127.0.0.1:8001 (Press CTRL+C to quit)
INFO:     Started reloader process [84071] using WatchFiles
INFO:     Started server process [84076]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
```

- uvicorn
  - uvicorn을 실행해 fastapi 앱을 실행한다.
  - api 서버가 실행되면 브라우저에서 127.0.0.1:8001로 접속하면 서버가 응답을 돌려줄수있다.
- swagger ui
  - api를만들면 기능이 코드안에 가려져있어서 어떤 요청을 보내야 하고 어떤 응답이 돌아오는지 알기 어려운데
  - swagger ui가 있으면 내가만든 fast api 서버가 swagger ui를 통해 “이런 엔드포인트들이 있습니다, 이런 식으로 요청을 보내면 되고, 이런 응답이 옵니다”를 자동으로 보여준다.
  - ui 화면에서 실제 api 요청도 보낼수있다.

###

<mark>#4</mark>

- routers/task_a.py → done_crud 임포트 및 done 여부 확인 부분 수정
- routers/done_a.py → DoneResponse 반환 시 done 필드 제거
- cruds/task_a.py → get_tasks_with_done, update_task에서 Done 여부 올바르게 체크
- schemas/task_a.py → done 필드 반드시 포함
- schemas/done_a.py → DoneResponse 정의 필요 (예: class DoneResponse(BaseModel): id: int)

```bash
# 8. 실행위치
$ pwd
/Users/yshmbid/Documents/home/github/MLops/skala-fastapi-rpt

# 9. DB 마이그레이션 실행
$ python -m api.migrate_db_a
2025-09-17 12:08:44,735 INFO sqlalchemy.engine.Engine SELECT DATABASE()
2025-09-17 12:08:44,736 INFO sqlalchemy.engine.Engine [raw sql] ()
2025-09-17 12:08:44,740 INFO sqlalchemy.engine.Engine SELECT @@sql_mode
2025-09-17 12:08:44,740 INFO sqlalchemy.engine.Engine [raw sql] ()
2025-09-17 12:08:44,741 INFO sqlalchemy.engine.Engine SELECT @@lower_case_table_names
2025-09-17 12:08:44,741 INFO sqlalchemy.engine.Engine [raw sql] ()
2025-09-17 12:08:44,745 INFO sqlalchemy.engine.Engine BEGIN (implicit)
2025-09-17 12:08:44,745 INFO sqlalchemy.engine.Engine DESCRIBE `demo`.`tasks`
2025-09-17 12:08:44,745 INFO sqlalchemy.engine.Engine [raw sql] ()
2025-09-17 12:08:44,772 INFO sqlalchemy.engine.Engine DESCRIBE `demo`.`dones`
2025-09-17 12:08:44,772 INFO sqlalchemy.engine.Engine [raw sql] ()
2025-09-17 12:08:44,780 INFO sqlalchemy.engine.Engine DESCRIBE `demo`.`tasks`
2025-09-17 12:08:44,780 INFO sqlalchemy.engine.Engine [raw sql] ()
2025-09-17 12:08:44,785 INFO sqlalchemy.engine.Engine DESCRIBE `demo`.`dones`
2025-09-17 12:08:44,785 INFO sqlalchemy.engine.Engine [raw sql] ()
2025-09-17 12:08:44,792 INFO sqlalchemy.engine.Engine 
CREATE TABLE tasks (
        id INTEGER NOT NULL AUTO_INCREMENT, 
        title VARCHAR(1024), 
        PRIMARY KEY (id)
)


2025-09-17 12:08:44,792 INFO sqlalchemy.engine.Engine [no key 0.00017s] ()
2025-09-17 12:08:44,811 INFO sqlalchemy.engine.Engine 
CREATE TABLE dones (
        id INTEGER NOT NULL, 
        PRIMARY KEY (id), 
        FOREIGN KEY(id) REFERENCES tasks (id)
)


2025-09-17 12:08:44,811 INFO sqlalchemy.engine.Engine [no key 0.00013s] ()
2025-09-17 12:08:44,822 INFO sqlalchemy.engine.Engine COMMIT

# 10. fastapi 서버 실행해서 확인
$ uvicorn api.main:app --host 127.0.0.1 --port 8001 --reload
INFO:     Will watch for changes in these directories: ['/Users/yshmbid/Documents/home/github/MLops/skala-fastapi-rpt']
INFO:     Uvicorn running on http://127.0.0.1:8001 (Press CTRL+C to quit)
INFO:     Started reloader process [13839] using WatchFiles
INFO:     Started server process [13867]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
INFO:     127.0.0.1:60547 - "GET / HTTP/1.1" 200 OK
INFO:     127.0.0.1:60547 - "GET /favicon.ico HTTP/1.1" 200 OK
INFO:     127.0.0.1:60550 - "GET /docs HTTP/1.1" 200 OK
INFO:     127.0.0.1:60550 - "GET /openapi.json HTTP/1.1" 200 OK
INFO:     127.0.0.1:60551 - "GET /static/favicon.ico HTTP/1.1" 200 OK
2025-09-17 12:10:21,548 INFO sqlalchemy.engine.Engine SELECT DATABASE()
2025-09-17 12:10:21,551 INFO sqlalchemy.engine.Engine [raw sql] ()
2025-09-17 12:10:21,554 INFO sqlalchemy.engine.Engine SELECT @@sql_mode
2025-09-17 12:10:21,554 INFO sqlalchemy.engine.Engine [raw sql] ()
2025-09-17 12:10:21,554 INFO sqlalchemy.engine.Engine SELECT @@lower_case_table_names
2025-09-17 12:10:21,554 INFO sqlalchemy.engine.Engine [raw sql] ()
2025-09-17 12:10:21,556 INFO sqlalchemy.engine.Engine BEGIN (implicit)
2025-09-17 12:10:21,564 INFO sqlalchemy.engine.Engine SELECT tasks.id, tasks.title, dones.id IS NOT NULL AS done 
FROM tasks LEFT OUTER JOIN dones ON tasks.id = dones.id
2025-09-17 12:10:21,564 INFO sqlalchemy.engine.Engine [generated in 0.00024s] ()
2025-09-17 12:10:21,571 INFO sqlalchemy.engine.Engine COMMIT
[✅ COMMIT 완료]
INFO:     127.0.0.1:60554 - "GET /tasks HTTP/1.1" 200 OK
```

<mark>cf2</mark>

```sql
SELECT tasks.id, tasks.title, dones.id IS NOT NULL AS done 
FROM tasks LEFT OUTER JOIN dones ON tasks.id = dones.id
```

SQLAlchemy 로그 해석?
- tasks와 dones 테이블을 조인해서 각 할 일이 완료되었는지 여부(done)를 계산
- FastAPI가 JSON으로 가공해 클라이언트에 반환.

###

<mark>cf3</mark>

swagger ui에서 확인

<img width="1920" height="1080" alt="image" src="https://github.com/user-attachments/assets/b4249ec5-0d68-497f-a003-1946f622780b" />


###

<mark>#5 실습중간정리</mark>

가상환경 만들기?
- source ./demo-app/bin/activate
- 나는 어케하는지몰라서 그냥 conda환경만들엇는데 갠찮겠지..

필요 패키지 설치
- pip install fastapi “uvicorn[standard]”
- pip install sqlalchemy aiomysql pymysql greenlet

PathOperation 함수는 경로동작 함수
- 모듈 임포트하는 모든 경로에, `__init__.py` 만든다

###

<mark>#6 main.py</mark>

```
#main.py
# FastAPI 엔드포인트 정의 이해
# FastAPI는 아래 두 가지 방식 중 하나로 엔드포인트를 정의
# ① 직접 app에 정의
# ② 모듈화한 라우터 파일을 include
from fastapi import FastAPI
from api.routers import task_a
from api.routers import done_a
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
from fastapi.openapi.docs import get_swagger_ui_html
import os
```

- main.py
  - fastapi app 서버를 구성.
- fastapi 프레임워크
  - 웹 요청이 들어오면 특정 함수로 연결해준다.
  - 연결 지점 = 엔드포인트.
  - ex) 누군가 브라우저에서 http://127.0.0.1:8001/hello를 호출하면, FastAPI는 이 요청을 보고 “아 이건 /hello 경로의 GET 요청이구나” 하고, 미리 등록해둔 hello() 함수를 실행한 뒤 그 반환값을 JSON으로 돌려준다.
- fastapi 기본 구조
  - 먼저 app = FastAPI()로 애플리케이션 객체를 만들고
  - 그 뒤에 @app.get("/"), @app.get("/hello") 같은 데코레이터로 함수를 등록하기.


```python
# app = FastAPI()
# FastAPI 앱(서버)의 기본 뼈대 생성
app = FastAPI(docs_url=None)
# 기본 /docs 비활성화, 개별 favicon 적용
```

- 보통 FastAPI는 /docs 주소로 들어가면 자동으로 Swagger UI라는 API 설명서가 나오는데, 코드에서 app = FastAPI(docs_url=None)라고 작성해 기본 /docs 경로를 막아버렸다.
  - 나중에 직접 커스터마이징한 /docs 엔드포인트를 등록하려고.
  - 대신 / 경로에서는 단순히 "Welcome to the FastAPI server!"라는 메시지를 주고, /hello 경로에서는 "hello world!"라는 메시지를 줌.


```python
@app.get("/")
async def root():
    return {"message": "Welcome to the FastAPI server!"}

@app.get("/hello")
async def hello():
    return {"message": "hello world!"}
```

###

```python
# ① 경로 (/) 및 (/hello)에 대한 라우팅 추가 (라우터 파일 내에서 경로를 직접 정의)
# 별도의 라우팅이 없으면 GET /tasks, POST /tasks 등의 API가 동작하지 않음

# app.include_router(task.router)를 호출해야 task.py의 엔드포인트가 FastAPI 앱에 등록
# 여러 개의 라우트 모듈을 관리하기 쉽게 하기 위해 include_router()를 사용

# ② 라우터 등록 (FastAPI 앱에 실제로 등록, 모듈화한 라우터 파일을 include)
app.include_router(task_a.router) # main.py에서 api/routers/task.py의 라우트를 include_router()로 FastAPI 앱에 추가
app.include_router(done_a.router) # main.py에서 api/routers/done.py의 라우트를 include_router()로 FastAPI 앱에 추가
```

- 라우터?
  - 엔드포인트들을 별도 파일로 나누어 관리할 수 있는 기능.
  - 할 일(Task)을 관리하는 API, 완료(Done)를 관리하는 API처럼 종류별로 나누면 프로젝트가 훨씬 깔끔해진다.
- app.include_router(task_a.router), app.include_router(done_a.router)
  - task_a.py 안에 정의된 라우터들을 불러와서 fastapi 앱에 등록한다.
  - /tasks 같은 엔드포인트들이 main.py에 직접 쓰여 있지 않아도 라우터 파일이 include되면서 실제 서버에서 동작한다.

###

```python
# static 경로 mount (필수!)
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
STATIC_DIR = os.path.join(BASE_DIR, "static")  # 현재 main.py가 api/ 안에 있다고 가정
app.mount("/static", StaticFiles(directory=STATIC_DIR), name="static")

# favicon 직접 연결
@app.get("/favicon.ico")
async def favicon():
    return FileResponse(os.path.join(STATIC_DIR, "favicon.ico"))
```

- 정적 파일(static files)은 fastapi에 연결해서 /static으로 접근.
- favicon.ico
  - 웹 브라우저가 기본적으로 요청하는 아이콘 파일이기 때문에 @app.get("/favicon.ico") 엔드포인트를 만들어서 직접 반환한다.


```python
# Swagger UI 커스터마이징 - favicon 적용
from fastapi.openapi.docs import get_swagger_ui_html

@app.get("/docs", include_in_schema=False)
async def custom_swagger_ui_html():
    return get_swagger_ui_html(
        openapi_url=app.openapi_url,
        title="My API Docs",
        swagger_favicon_url="/static/favicon.ico"
    )
```

- swagger ui 커스터마이징
  - swagger_favicon_url="/static/favicon.ico"
  - 지정한 아이콘을 Swagger UI 화면에 반영.
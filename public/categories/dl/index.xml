<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DL on  </title>
    <link>http://localhost:1313/categories/dl/</link>
    <description>Recent content in DL on  </description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 28 Feb 2026 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/dl/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>VAE 기반 신약 분자 생성 #1 VAE와 KL 발산</title>
      <link>http://localhost:1313/docs/study/dl/dl11/</link>
      <pubDate>Sat, 28 Feb 2026 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/dl/dl11/</guid>
      <description>VAE 기반 신약 분자 생성 #1 VAE와 KL 발산 # #2026-02-28&#xA;#1&#xA;약을 만드는 과정의 첫 번째 관문은 &amp;ldquo;어떤 분자를 약으로 쓸 것인가&amp;quot;를 정하는 것이다. 자연에 존재하는 분자 중에서 고르는 것도 있지만, 완전히 새로운 분자를 설계하는 것이 현대 신약 개발의 핵심이다.&#xA;그런데 여기서 문제의 규모를 실감해야 한다. 약이 될 수 있는 분자의 종류가 대략 10의 60제곱 개 이상이라고 추정된다. 이게 얼마나 큰 수인지 감을 잡기 위해 비교하면, 우주에 존재하는 원자의 수가 약 10의 80제곱 개다.</description>
    </item>
    <item>
      <title>VAE 기반 신약 분자 생성 #2 데이터 로드 및 토큰화</title>
      <link>http://localhost:1313/docs/study/dl/dl12/</link>
      <pubDate>Sat, 28 Feb 2026 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/dl/dl12/</guid>
      <description>VAE 기반 신약 분자 생성 #2 데이터 로드 및 토큰화 # #2026-02-28&#xA;#1 MUV 데이터셋 가져오기&#xA;import deepchem as dc tasks, datasets, transformers = dc.molnet.load_muv() train_dataset, valid_dataset, test_dataset = datasets train_smiles = train_dataset.ids # → [&amp;#39;CCO&amp;#39;, &amp;#39;CC(=O)Oc1ccccc1C(=O)O&amp;#39;, &amp;#39;Cn1cnc2c1c(=O)n(c(=O)n2C)C&amp;#39;, ...] DeepChem 라이브러리로 MUV 데이터셋을 자동으로 다운로드해준다. MUV는 Maximum Unbiased Validation의 약자로, 신약 후보 물질을 가상으로 스크리닝하는 벤치마크 데이터셋이다. 수만 개의 분자가 SMILES 문자열 형태로 들어 있다.&#xA;DNA 데이터에서는 .ids는 샘플의 식별자였는데 chr22:20208963-20209064 같은 게놈 좌표가 ID였다.</description>
    </item>
    <item>
      <title>VAE 기반 신약 분자 생성 #3 AspuruGuzikAutoEncoder 모델 구성</title>
      <link>http://localhost:1313/docs/study/dl/dl13/</link>
      <pubDate>Sat, 28 Feb 2026 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/dl/dl13/</guid>
      <description>VAE 기반 신약 분자 생성 #3 AspuruGuzikAutoEncoder 모델 구성 # #2026-02-28&#xA;3단계: AspuruGuzikAutoEncoder 모델 구성 (vae.py 20~25행) # from deepchem.models.optimizers import ExponentialDecay from deepchem.models.seqtoseq import AspuruGuzikAutoEncoder batch_size = 100 batches_per_epoch = len(train_smiles) / batch_size learning_rate = ExponentialDecay(0.001, 0.95, batches_per_epoch) model = AspuruGuzikAutoEncoder( tokens, max_length, model_dir=&amp;#39;vae&amp;#39;, batch_size=batch_size, learning_rate=learning_rate) AspuruGuzikAutoEncoder 내부 구조 # 이 모델은 2018년 Aspuru-Guzik 연구실의 논문 &amp;ldquo;Automatic Chemical Design Using a Data-Driven Continuous Representation of Molecules&amp;rdquo; 에서 제안한 아키텍처다.</description>
    </item>
    <item>
      <title>Conv1D 기반 DNA 분석 #1 유전체 서열 분석하기</title>
      <link>http://localhost:1313/docs/study/dl/dl1/</link>
      <pubDate>Fri, 27 Feb 2026 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/dl/dl1/</guid>
      <description>Conv1D 기반 DNA 분석 #1 유전체 서열 분석하기 # #2026-02-27&#xA;#1 CNN으로 유전체 서열 분석하기&#xA;DNA는 A, T, G, C 4개의 문자로 이루어진 긴 문자열이다. 이 문자열 어딘가에는 단백질이 달라붙는 자리(결합 부위)가 있고, 어딘가에는 RNA 간섭(RNAi)을 잘 일으키는 서열이 있다.&#xA;눈으로는 도저히 찾을 수 없다. 딥러닝으로 학습시키면?&#xA;유전체 서열 분석하는 3가지 실험을 한다:&#xA;실험 목표 문제 유형 1 전사인자 JUND가 결합하는 DNA 서열 예측 이진 분류 2 결합 예측 + 크로마틴 접근성 추가 이진 분류 (다중 입력) 3 siRNA 서열의 유전자 침묵 효율 예측 회귀 # #2 DNA 서열을 컴퓨터에 입력하는 방법: 원-핫 인코딩 (One-Hot Encoding)</description>
    </item>
    <item>
      <title>Conv1D 기반 DNA 분석 #2 전사인자 결합 부위 예측</title>
      <link>http://localhost:1313/docs/study/dl/dl2/</link>
      <pubDate>Fri, 27 Feb 2026 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/dl/dl2/</guid>
      <description>Conv1D 기반 DNA 분석 #2 전사인자 결합 부위 예측 # #2026-02-27&#xA;#0 분석 목적&#xA;우리 몸의 세포 안에는 DNA라는 아주 긴 문자열이 있고 A, C, G, T 네 글자로 이루어져 있다. DNA는 유전자라는 &amp;ldquo;레시피&amp;quot;를 담고 있는데, 이 레시피가 항상 켜져 있는 건 아니며 특정 단백질이 DNA의 특정 위치에 물리적으로 달라붙어야 그 근처 유전자가 켜진다. 이렇게 달라붙어서 유전자를 켜고 끄는 단백질을 전사인자라고 부른다.&#xA;JUND가 전사인자 중 하나인데, 아무 데나 붙는 게 아니라 특정한 글자 패턴이 있는 곳에만 붙는다.</description>
    </item>
    <item>
      <title>Conv1D 기반 DNA 분석 #3 크로마틴 접근성 추가</title>
      <link>http://localhost:1313/docs/study/dl/dl3/</link>
      <pubDate>Fri, 27 Feb 2026 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/dl/dl3/</guid>
      <description>Conv1D 기반 DNA 분석 #3 크로마틴 접근성 추가 # #2026-02-27&#xA;이전 모델에서 우리는 DNA 서열 101글자만 보고 JUND가 붙을지 말지를 예측했고 꽤 잘 작동했다. 그런데 생물학의 현실은 좀 더 복잡한데 JUND가 좋아하는 서열 패턴(TGACTCA 같은 모티프)이 거기 있어도, 그 DNA 구간이 물리적으로 접근 불가능한 상태라면 JUND는 절대 결합할 수 없다.&#xA;열린 크로마틴 (Open): ====○==== ← TF 접근 가능, 결합 가능성 높음 닫힌 크로마틴 (Closed): ████████ ← TF 접근 불가, 결합 가능성 낮음 우리 세포 안의 DNA는 그냥 풀어져서 떠다니는 게 아니라 히스톤이라는 작은 단백질 뭉치에 실타래처럼 감겨 있고 이렇게 DNA가 히스톤에 감긴 구조를 크로마틴이라고 부른다.</description>
    </item>
    <item>
      <title>Conv1D 기반 DNA 분석 #4 RNAi 효율 예측</title>
      <link>http://localhost:1313/docs/study/dl/dl4/</link>
      <pubDate>Fri, 27 Feb 2026 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/dl/dl4/</guid>
      <description>Conv1D 기반 DNA 분석 #4 RNAi 효율 예측 # #2026-02-27&#xA;#1 RNA 간섭(RNAi)이란?&#xA;세포 안에서 유전자가 단백질을 만드는 과정은 DNA에서 mRNA라는 복사본이 만들어지고, 이 mRNA를 리보솜이라는 기계가 읽어서 단백질을 찍어낸다. 유전자 → mRNA → 단백질, 이 흐름이 생명의 기본 공정이다.&#xA;그런데 세포 안에 짧은 RNA 조각을 집어넣으면, 그 RNA가 특정 mRNA를 찾아가서 분해한다. mRNA가 사라지면 리보솜이 읽을 게 없으니 단백질도 안 만들어진다 즉 특정 유전자를 &amp;ldquo;조용히 시키는&amp;rdquo; 것이다. 이걸 RNA 간섭, RNAi라고 한다.</description>
    </item>
    <item>
      <title>Conv1D 기반 DNA 분석 #5 분석 정리</title>
      <link>http://localhost:1313/docs/study/dl/dl5/</link>
      <pubDate>Fri, 27 Feb 2026 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/dl/dl5/</guid>
      <description>Conv1D 기반 DNA 분석 #5 분석 정리 # #2026-02-27&#xA;Conv1D 기반 DNA 분석에서 세 가지 실험을 했는데 전사인자 결합 예측, 크로마틴 접근성을 추가한 결합 예측, 그리고 RNAi 효율 예측을 수행했다. 세부 사항은 다 달랐지만 DNA(또는 RNA) 서열을 숫자로 바꾸고, 1차원 합성곱 필터로 패턴을 찾고, 그 패턴들을 종합해서 하나의 답을 내놓는 공통 로직으로 작동한다.&#xA;# #1 모델 구조&#xA;DNA 서열 (원-핫 인코딩) ↓ Conv1D → ReLU → Dropout ← 로컬 모티프 탐지 ↓ Conv1D → ReLU → Dropout ← 복합 패턴 학습 ↓ [Conv1D → ReLU → Dropout] ← (선택적 추가 레이어) ↓ Flatten ↓ [+ 크로마틴 접근성] ← (실험 2만 해당) ↓ Dense(1) ↓ Sigmoid → 출력 Conv1D 레이어</description>
    </item>
    <item>
      <title>ResNet 기반 망막증 분류 #1 Conv2D 기반 이미지 분류</title>
      <link>http://localhost:1313/docs/study/dl/dl6/</link>
      <pubDate>Fri, 27 Feb 2026 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/dl/dl6/</guid>
      <description>ResNet 기반 망막증 분류 #1 Conv2D 기반 이미지 분류 # #2026-02-27&#xA;#1&#xA;당뇨병 환자의 몸에서는 혈당이 오랜 기간 높은 상태로 유지된다. 이 높은 혈당이 온몸의 작은 혈관들을 서서히 망가뜨리는데, 눈의 망막에 있는 미세 혈관도 예외가 아니다. 혈관이 손상되면 피가 새고, 비정상적인 새 혈관이 자라나고, 결국 망막이 제 기능을 못 하게 되면서 시력을 잃을 수 있다. 이것이 당뇨병성 망막증이다. 안과 의사는 이 병을 진단하기 위해 안저 사진을 찍는다. 안저란 눈 뒤쪽의 망막 바닥 면을 말하는데, 특수 카메라로 동공을 통해 들여다보면 망막의 혈관 구조가 고스란히 보인다.</description>
    </item>
    <item>
      <title>ResNet 기반 망막증 분류 #2 이미지 전처리</title>
      <link>http://localhost:1313/docs/study/dl/dl7/</link>
      <pubDate>Fri, 27 Feb 2026 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/dl/dl7/</guid>
      <description>ResNet 기반 망막증 분류 #2 이미지 전처리 # #2026-02-27&#xA;#1 망막 이미지 데이터&#xA;Kaggle에서 받은 안저 사진들은 전 세계 다양한 병원에서 서로 다른 장비로 찍힌 것이다. 어떤 사진은 2000픽셀짜리이고, 어떤 사진은 5000픽셀이 넘는다. 어떤 사진은 거의 정사각형이고, 어떤 사진은 직사각형이다. 공통적인 건 하나인데, 망막은 원형이라 사진 한가운데에 둥근 밝은 영역으로 찍히고, 그 주변은 까만 여백으로 채워져 있다는 것이다. 신경망에 이미지를 넣으려면 모든 이미지의 크기가 같아야 한다. 행렬 연산이 고정된 차원을 요구하기 때문이다.</description>
    </item>
    <item>
      <title>ResNet 기반 망막증 분류 #3 데이터 증강</title>
      <link>http://localhost:1313/docs/study/dl/dl8/</link>
      <pubDate>Fri, 27 Feb 2026 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/dl/dl8/</guid>
      <description>ResNet 기반 망막증 분류 #3 데이터 증강 # #2026-02-27&#xA;#1&#xA;딥러닝 모델은 데이터를 많이 볼수록 잘 배운다. 그런데 의료 이미지는 구하기 어렵다. 수만 장이 있다고 해도 수백만 개의 파라미터를 가진 신경망을 학습시키기에는 부족할 수 있다. 데이터가 부족하면 모델은 훈련 이미지의 세부 사항까지 통째로 외워버리고, 처음 보는 이미지에서는 엉뚱한 판단을 내린다. 과적합이다.&#xA;데이터 증강의 핵심 아이디어는 하나의 이미지를 살짝씩 변형해서 여러 버전을 만들면, 모델 입장에서는 마치 더 많은 데이터를 본 것과 같은 효과가 난다.</description>
    </item>
    <item>
      <title>ResNet 기반 망막증 분류 #4 분류모델 학습</title>
      <link>http://localhost:1313/docs/study/dl/dl9/</link>
      <pubDate>Fri, 27 Feb 2026 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/dl/dl9/</guid>
      <description>ResNet 기반 망막증 분류 #4 분류모델 학습 # #2026-02-27&#xA;#1 아키텍처 개요&#xA;self.inputs = tf.keras.Input(shape=(512, 512, 3), dtype=tf.float32) in_layer = DRAugment(self.augment, batch_size, size=(512, 512))(self.inputs) 이전 단계에서 512×512 크기의 깔끔한 망막 이미지와 등급 레이블, 그리고 클래스 가중치가 준비되었다. 이제 이 이미지를 받아서 &amp;ldquo;이 망막은 등급 몇이다&amp;quot;라고 판정하는 모델을 만들 차례다.&#xA;이전 챕터에서 DNA 서열을 분석할 때는 Conv1D를 썼다. DNA는 1차원이니까. 이미지는 2차원(가로×세로)이므로 Conv2D를 쓴다. 하지만 단순히 Conv2D를 몇 겹 쌓는 것만으로는 부족하다.</description>
    </item>
    <item>
      <title>ResNet 기반 망막증 분류 #5 평가 지표와 전체 파이프라인</title>
      <link>http://localhost:1313/docs/study/dl/dl10/</link>
      <pubDate>Fri, 27 Feb 2026 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/dl/dl10/</guid>
      <description>ResNet 기반 망막증 분류 #5 평가 지표와 전체 파이프라인 # #2026-02-27&#xA;모델이 학습을 마쳤다. 512×512 망막 사진을 넣으면 5개 등급에 대한 확률을 내놓는다. 이제 가장 중요한 질문이 남았다. 이 모델이 실제로 쓸 만한가? 이걸 판단하려면 적절한 평가 지표가 필요하다.&#xA;이 프로젝트에서는 세 가지 평가 도구를 쓴다. 단순 정확도, 이차 가중 카파, 그리고 혼동행렬이다. 각각이 모델의 다른 측면을 보여주는데, 특히 두 번째 지표가 이 문제의 핵심을 찌른다.&#xA;# #1 단순 정확도(DRAccuracy)</description>
    </item>
  </channel>
</rss>

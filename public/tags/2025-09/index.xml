<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2025-09 on  </title>
    <link>http://localhost:1313/tags/2025-09/</link>
    <description>Recent content in 2025-09 on  </description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 17 Sep 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/2025-09/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>FastAPI #1</title>
      <link>http://localhost:1313/docs/study/sw/sw33/</link>
      <pubDate>Wed, 17 Sep 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/sw/sw33/</guid>
      <description>FastAPI #1 # #2025-09-17&#xA;#1 maria db container 띄우기&#xA;# 1. conda 가상환경 생성 $ conda create -n demo-app python=3.11 $ conda activate demo-app # 2. 작업 위치 # mariadb_tmplt 디렉토리를 다운받고 압축 해제함 $ pwd /Users/yshmbid/Documents/home/github/MLops/mariadb_tmplt $ ls conf.d data env maria_db.yaml # 3. Docker Compose로 MariaDB 실행 $ docker compose -p maria_db -f maria_db.yaml up -d # 4. 컨테이너가 잘떴는지확인 $ docker ps | grep mariadb ae333f330cc4 mariadb:10.</description>
    </item>
    <item>
      <title>ML #1 Hyperparameter Optimization</title>
      <link>http://localhost:1313/docs/study/ai/ai35/</link>
      <pubDate>Tue, 16 Sep 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/ai/ai35/</guid>
      <description>ML #1 Hyperparameter Optimization # #2025-09-16&#xA;1. 개요 # HPO: Hyper-parameter Optimization&#xA;[HPO Method]&#xA;Grid Search Random Search Bayesian Search Bayesian Search(TPE:Tree-structured Parzen Estimator) using Optuna [Data]&#xA;Bank Marketing Data set&#xA;https://archive.ics.uci.edu/dataset/222/bank+marketing&#xA;[Note]&#xA;HPO Example로 오류방지를 위한 최소한의 전처리만 수행&#xA;# 2. 코드 # #1 Data Load&#xA;from ucimlrepo import fetch_ucirepo def load_data(): # fetch dataset bank_marketing = fetch_ucirepo(id=222) # data (as pandas dataframes) X = bank_marketing.data.features y = bank_marketing.</description>
    </item>
    <item>
      <title>Langchain #1 (스터디) 노션 데이터로 나만의 RAG 시스템 구축하기</title>
      <link>http://localhost:1313/docs/study/ai/ai32/</link>
      <pubDate>Mon, 15 Sep 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/ai/ai32/</guid>
      <description>Langchain #1 (스터디) 노션 데이터로 나만의 RAG 시스템 구축하기 # #2025-09-15</description>
    </item>
    <item>
      <title>Ray #1 (스터디) Batch Prediction with Ray Core</title>
      <link>http://localhost:1313/docs/study/ai/ai34/</link>
      <pubDate>Mon, 15 Sep 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/ai/ai34/</guid>
      <description>Ray #1 (스터디) Batch Prediction with Ray Core # #2025-09-15&#xA;스터디때 준비해갔던 Ray Core를 사용해서 batch prediction 수행하는 예제!!&#xA;batch prediction이 batch를 예측하는건줄알았는데(..) batch로 prediction하는것이었다. 순서는 Task 기반, actor 기반 batch prediction, 그리고 GPU 기반 수행 코드이다. 출처는 Ray Document의 Batch Prediction with Ray Core이다. # 0. 개요 # 목적 Parquet 형식의 대규모 데이터셋을 Ray를 이용해 분산 처리하며, 더미 모델을 로딩하여 배치 예측(batch prediction) 을 수행한다. Task와 Actor 두 가지 실행 방식을 비교하고, CPU/GPU 자원 활용 차이를 이해한다.</description>
    </item>
    <item>
      <title>ML #1</title>
      <link>http://localhost:1313/docs/study/ai/ai33/</link>
      <pubDate>Sat, 13 Sep 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/ai/ai33/</guid>
      <description>ML #1 # #2025-09-13&#xA;#1 ML type (p.31-33)&#xA;ML의 학습방법 3가지 지도학습(Supervised) 입력 데이터와 출력 데이터가 모두 제공되고 모델은 입력을 보면 어떤 출력이 나와야 하는지를 배움. 학습한 모델은 새로운 데이터가 들어오면 예측을 하고 -&amp;gt; 결과를 실제 정답과 비교해 정확도 계산. 비지도학습(Unsupervised) 문제는 있지만 정답 라벨이 없음. 비슷한 특징을 가진 학생들을 묶어서 그룹을 만들고 어떤 그룹이 우수한지 알 수 없지만 데이터 안에서 자연스럽게 나타나는 구조를 파악한다(클러스터링) 준지도학습(Semi-Supervised) 라벨이 붙은 소량의 데이터와, 라벨이 없는 대량의 데이터를 동시에 사용하면 더 나은 모델을 만들 수 있다 왜냐하면 100% 라벨링된 데이터가 있을 때만큼 정확하지는 않지만, 현실에서는 라벨링이 부족한 경우가 많고 라벨 없는 데이터가 양은 많아서 데이터 분포를 더 잘 보여주기 때문이다.</description>
    </item>
    <item>
      <title>ATMOSPHERE</title>
      <link>http://localhost:1313/docs/hobby/daily/daily20/</link>
      <pubDate>Fri, 12 Sep 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/hobby/daily/daily20/</guid>
      <description> ATMOSPHERE # #2025-09-12&#xA;# </description>
    </item>
    <item>
      <title>Langchain #1 (스터디) 노션 데이터로 나만의 RAG 시스템 구축하기</title>
      <link>http://localhost:1313/docs/study/ai/ai30/</link>
      <pubDate>Wed, 10 Sep 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/ai/ai30/</guid>
      <description>Langchain #1 (스터디) 노션 데이터로 나만의 RAG 시스템 구축하기 # #2025-09-10&#xA;스터디하는친구가 만들어준코드인데 내 노션으로 돌려봤다!&#xA;실습 목적&#xA;노션 데이터를 임베딩 생성하여 FAISS 벡터 스토어에 저장하고 이를 기반으로 유사 문서 검색을 수행하며, 청킹 기법을 통해 데이터 구조를 이해하고 LLM 프롬프트 제약을 적용한 뒤, RAG 구조를 접목해 자동 답변 구현 실습 설계&#xA;임베딩 생성: SentenceTransformer(&amp;ldquo;BAAI/bge-m3&amp;rdquo;) 유사 문서 검색: 코사인 유사도 + FAISS 벡터 스토어 기반 최근접 탐색 청킹 기법: Markdown 단위 분리 + 길이 기반 추가 분할 LLM 프롬프트 제약: 근거 기반 답변(추측 금지 규칙 포함) 자동 답변 구현: RAG 구조 + &amp;ldquo;meta-llama/llama-3.</description>
    </item>
    <item>
      <title>ML #1</title>
      <link>http://localhost:1313/docs/study/ai/ai31/</link>
      <pubDate>Wed, 10 Sep 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/ai/ai31/</guid>
      <description>ML #1 # #2025-09-10&#xA;1 # # !pip install numpy # !pip install pandas # !pip install seaborn # !pip install matplotlib # !pip install -U scikit-learn # !pip install xgboost # !pip install lightgbm import warnings import numpy as np import pandas as pd import seaborn as sns import matplotlib.pyplot as plt from sklearn.datasets import load_diabetes from sklearn.model_selection import train_test_split from sklearn.metrics import ( r2_score, mean_squared_error, root_mean_squared_error, mean_absolute_percentage_error, ) warnings.</description>
    </item>
    <item>
      <title>Kubernetes #2 ConfigMap, PVC, Liveness/Readiness, Blue/Green</title>
      <link>http://localhost:1313/docs/study/sw/sw32/</link>
      <pubDate>Tue, 09 Sep 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/sw/sw32/</guid>
      <description>Kubernetes #2 ConfigMap, PVC, Liveness/Readiness, Blue/Green # #2025-09-09&#xA;1. kubectl 명령어 실습 # #1 배포된 컨테이너를 쿠버네티스에서 확인하기&#xA;# 배포 상태 확인 $ kubectl get pod -n skala-practice | grep sk019 sk019-myfirst-api-server-57fddcd6c8-l4jms 1/1 Running 0 108m # 서비스 확인 $ kubectl get svc -n skala-practice | grep sk019 sk019-myfirst-api-server ClusterIP 10.100.83.86 &amp;lt;none&amp;gt; 8080/TCP,8081/TCP 18h # #2 로컬 &amp;lt;-&amp;gt; Pod 간 파일/디렉토리 복사&#xA;# 수행 위치 $ pwd /Users/yshmbid/Documents/home/github/Cloud/workspace/kubernetes/02.deploy # Pod 이름 확인 $ kubectl get pod -n skala-practice | grep sk019 sk019-myfirst-api-server-57fddcd6c8-l4jms 1/1 Running 0 120m # 로컬의 data 디렉토리를 Pod 내부 /app/data 로 복사 $ kubectl cp $(pwd)/data skala-practice/sk019-myfirst-api-server-57fddcd6c8-l4jms:/app/data # Pod /app/data → 로컬 .</description>
    </item>
    <item>
      <title>Kubernetes #1 Pod, Port-forward</title>
      <link>http://localhost:1313/docs/study/sw/sw31/</link>
      <pubDate>Mon, 08 Sep 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/sw/sw31/</guid>
      <description>Kubernetes #1 Pod, Port-forward # #2025-09-08&#xA;1. 실습환경설정 # 필요 패키지 kubectl, jq, curl, maven, Java brew install kubectl jq curl maven kubectl&#xA;Kubernetes 클러스터와 통신하는 CLI 도구 쿠버네티스는 여러 개의 프로그램이 동시에 돌아가는 큰 시스템이고 여기에 지시를 내리는 도구. Java 17&#xA;여러 프로그램을 실행하는 공통 실행 환경(JVM)을 제공 공통 실행 환경? 여러 프로그램을 공통 언어로 사용하게해준다. 프로그램들이 Java가 어디 있는지 알아야 하니까 JAVA_HOME이라는 환경 변수를 설정해준다. export JAVA_HOME=/opt/homebrew/opt/openjdk@17 # 클라우드 인증 정보, 커맨드 스크립트 다운로드 # 클라우드 인증 정보 wsl-install.</description>
    </item>
    <item>
      <title>Java #2 객체지향 설계 원칙 SOLID</title>
      <link>http://localhost:1313/docs/study/sw/sw29/</link>
      <pubDate>Tue, 02 Sep 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/sw/sw29/</guid>
      <description>Java #2 객체지향 설계 원칙 SOLID # #2025-09-02&#xA;목차 # 단일 책임 원칙 (Single Responsibility Principle, SRP) 개방-폐쇄 원칙 (Open-Closed Principle, OCP) 리스코프 치환 원칙 (Liskov Substitution Principle, LSP) 인터페이스 분리 원칙 (Interface Segregation Principle, ISP) 의존 역전 원칙 (Dependency Inversion Principle, DIP) 공통 특성: 응집도를 높이거나 결합도를 낮추는 설계 # 1. 단일 책임 원칙 (Single Responsibility Principle, SRP) # #1 정의&#xA;한 클래스는 하나의 책임만 가져야 하고 클래스가 변경되어야 할 이유는 오직 하나여야 한다.</description>
    </item>
    <item>
      <title>Vector DB 스키마 설계</title>
      <link>http://localhost:1313/docs/study/sw/sw30/</link>
      <pubDate>Tue, 02 Sep 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/sw/sw30/</guid>
      <description>Vector DB 스키마 설계 # #2025-09-02&#xA;1. 개념 # #1 KNN vs ANN&#xA;KNN과 ANN의 공통 목적&#xA;질문을 하고 그 질문과 비슷한 질문이나 답변을 데이터베이스에서 찾기 구현 차이&#xA;모든 데이터를 하나하나 다 비교해서 가장 가까운 것을 찾는다(KNN) 데이터 전체를 다 비교하지 않고 인덱스를 이용해서 후보군을좁혀서 그 안에서만 비교(ANN) 친구가 수십만 명 있으면 모든 친구에게 질문을 던져서 과거 답변을 확인하는 대신 비슷한 취향을 가진 대표 그룹 몇 개를 빠르게 찾고 그 안에서만 가장 가까운 답을 고르는 방식.</description>
    </item>
    <item>
      <title>혼돈후의 고요</title>
      <link>http://localhost:1313/docs/hobby/book/book54/</link>
      <pubDate>Tue, 02 Sep 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/hobby/book/book54/</guid>
      <description>혼돈후의 고요 # #2025-09-02&#xA;#1&#xA;병이 어떻게 시작되었는지 알리스는 뚜렷이 기억한다. 당시의 통증은 뱃속에서 화산이 폭발하는 듯했다. 어머니에게 이렇게 고통스러운 게 정상이냐고 묻자, 어머니는 그렇다고 답했다. 어느 날 어머니가 아무래도 병원에 데려가야겠다고 결심했다. 의사의 입에서는 이런 말이 나왔다. &amp;ldquo;자궁 내막증입니다.&amp;rdquo; 의사는 그것이 염증성 여성 질환이며 전 세계 여성 10퍼센트에게 발생하는 만큼 비교적 흔한 병이라고 설명했다. 그중 다수가 사춘기부터 갱년기까지 질환을 안고 살지만 그리 어렵지 않게 증상을 다스린다고 덧붙였다. 위로하려는 양, 매릴린 먼로 역시 그 병을 앓았지만 그래도 온 세상이 찬사를 바치는 여자가 되지 않았냐고 하기까지 했다.</description>
    </item>
    <item>
      <title>Java #1 객체지향 프로그래밍: 캡슐화, 추상화, 다형성, 상속</title>
      <link>http://localhost:1313/docs/study/sw/sw28/</link>
      <pubDate>Mon, 01 Sep 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/sw/sw28/</guid>
      <description>Java #1 객체지향 프로그래밍: 캡슐화, 추상화, 다형성, 상속 # #2025-09-01&#xA;목차 # 캡슐화 추상화 다형성 상속 공통 특성: 인터페이스와 구현의 분리 # 1. 캡슐화 # #1 개념 및 목적&#xA;개념 객체지향 프로그래밍에서 객체의 속성(필드)을 외부로부터 숨기고, 공개된 메서드(getter/setter)를 통해서만 접근하도록 만드는 원칙 필드를 private으로 선언하고, 외부에서 직접 접근하지 못하게 제한하고, public 메서드인 getter와 setter를 제공해 값을 읽거나 수정할 수 있도록 한다. setter 내부에는 유효성 검사 로직을 넣어 잘못된 값이 들어오는 것을 막을 수도 있다.</description>
    </item>
  </channel>
</rss>

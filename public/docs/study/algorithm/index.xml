<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>알고리즘 on  </title>
    <link>http://localhost:1313/docs/study/algorithm/</link>
    <description>Recent content in 알고리즘 on  </description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 14 Aug 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/docs/study/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>학위논문작업 #5 클러스터링 로그 뽑기 (4)</title>
      <link>http://localhost:1313/docs/study/algorithm/algo17/</link>
      <pubDate>Thu, 14 Aug 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/algorithm/algo17/</guid>
      <description>학위논문작업 #5 클러스터링 로그 뽑기 (4) # #2025-08-14&#xA;1. CCM selection # 비교하기 좋은 샘플 CCM 두개를 뽑았다!&#xA;# CCM1 [ccm_idx 28615] Start expand_cluster: left_cur_dist=0, right_cur_dist=0, es_l=65, left_max_dist=325, right_max_dist=325 #CCM2 [ccm_idx 28624] Start expand_cluster: left_cur_dist=0, right_cur_dist=0, es_l=1, left_max_dist=5, right_max_dist=5 CCM1 position: 28881 position index: 28615 H-score: 0.05290 Eps scaler: 1 Deps: 5 CCM2 position: 28890 position index: 28624 H-score: 6.4062 Eps scaler: 65 Deps: 325 # 핵심로직&#xA;최대허용거리: Deps CCM2의 H-중요도는 6.</description>
    </item>
    <item>
      <title>학위논문작업 #6 Intro 구성</title>
      <link>http://localhost:1313/docs/study/algorithm/algo18/</link>
      <pubDate>Tue, 12 Aug 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/algorithm/algo18/</guid>
      <description>학위논문작업 #6 Intro 구성 # #2025-08-16&#xA;1. 고민인점 # 저널 제출용은 Background로 다음 내용을 사용함.&#xA;바이러스의 전파력, 중증 질환 유발 능력, 항체 회피 능력과 같은 특성을 변화시키는 많은 돌연변이가 발생&#xA;돌연변이와 바이러스 특성, 특히 환자의 질병 중증도 간의 연관성을 설명하는 연구들이 있고 주로 아미노산 또는 뉴클레오타이드 수준에서의 돌연변이 빈도를 활용하며 빈도 높은 돌연변이가 기능적으로 더 중요할 가능성이 높다는 가정에 기반하는데 이 접근법은 계통에 따른 편향에 취약하고 빈도가 다소 낮지만 다양한 돌연변이들이 신호하는 바이러스 적응이나 면역 회피를 간과하는 경우가 많다.</description>
    </item>
    <item>
      <title>학위논문작업 #3 클러스터링 로그 뽑기 (2)</title>
      <link>http://localhost:1313/docs/study/algorithm/algo16/</link>
      <pubDate>Mon, 11 Aug 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/algorithm/algo16/</guid>
      <description>학위논문작업 #3 클러스터링 로그 뽑기 (2) # #2025-08-11&#xA;1. Init # [ccm_idx 28624] Start expand_cluster: left_cur_dist=0, right_cur_dist=0, es_l=1, left_max_dist=5, right_max_dist=5 es_l=1, left_max_dist=5, es_r=1, right_max_dist=5 초기 반경 mut_deps: 5*1 = 5 bp # 2. Left expansion # [ccm_idx 28624] Left expansion: left_index=28623, ld=1, updated es_l=1.0, mut_deps=5.0, left_max_dist=5 ld = 1 확장 가능?&#xA;ld = POS(center) - POS(28623) = 1 현재 한도 left_max_dist(0)=5 이므로 ld(=1) ≤ 5 여서 확장 가능 scaler update?</description>
    </item>
    <item>
      <title>학위논문작업 #4 클러스터링 로그 뽑기 (3)</title>
      <link>http://localhost:1313/docs/study/algorithm/algo15/</link>
      <pubDate>Mon, 11 Aug 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/algorithm/algo15/</guid>
      <description>학위논문작업 #4 클러스터링 로그 뽑기 (3) # #2025-08-11&#xA;1. Previous # [ccm_idx 28624] Start expand_cluster: left_cur_dist=0, right_cur_dist=0, es_l=1, left_max_dist=5, right_max_dist=5 [ccm_idx 28624] Left expansion: left_index=28623, ld=1, updated es_l=1.0, mut_deps=5.0, left_max_dist=5 [ccm_idx 28624] Left expansion: left_index=28622, ld=2, updated es_l=1.0, mut_deps=5.0, left_max_dist=5.0 [ccm_idx 28624] Left expansion: left_index=28621, ld=3, updated es_l=1.6666666666666665, mut_deps=8.333333333333332, left_max_dist=5.0 [ccm_idx 28624] Left expansion: left_index=28620, ld=4, updated es_l=1.4444444444444444, mut_deps=7.222222222222222, left_max_dist=8.333333333333332 [ccm_idx 28624] Left expansion: left_index=28619, ld=5, updated es_l=1.2962962962962963, mut_deps=6.481481481481481, left_max_dist=7.</description>
    </item>
    <item>
      <title>학위논문작업 #2 클러스터링 로그 뽑기</title>
      <link>http://localhost:1313/docs/study/algorithm/algo14/</link>
      <pubDate>Sun, 10 Aug 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/algorithm/algo14/</guid>
      <description>학위논문작업 #2 클러스터링 로그 뽑기 # #2025-08-10&#xA;Objective # MutClust의 기존 코드에서는 클러스터링 수행후 클러스터 정보만 출력할뿐 neighbor eps scaler에 따른 ccm eps scaler의 업데이트와 그에 따른 eps 업데이트 내역을 따로 빼진 않았었다. 근데 클러스터링 과정을 설명하기에 좋은 예시를 만들기가 어려워서 (기존 예시는 맘에 안들고..) 그냥 로그를 다 뽑고 괜찮아 보이는걸 건져보기로 했다. # 1. 로깅 코드 추가하기 # 일단 로그는 총 4번뽑을건데&#xA;시작 (left_cur_dist &amp;amp; right_cur_dist=0일때) Left expansion 과정 Right expansion 과정 최종 결과 이렇게뽑을려고한다.</description>
    </item>
    <item>
      <title>Python #1 가상환경 구성 및 패키지 관리</title>
      <link>http://localhost:1313/docs/study/algorithm/algo11/</link>
      <pubDate>Tue, 05 Aug 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/algorithm/algo11/</guid>
      <description>Python #1 가상환경 구성 및 패키지 관리 # #2025-08-05&#xA;1. 개념 # #1 가상환경의 필요성?&#xA;우리가 파이썬을 사용할 때, 가장 먼저 겪게 되는 문제 중 하나는 바로 패키지 버전 충돌이다. 예를 들어 어떤 프로젝트에서는 numpy==1.18.5 버전을 사용하고 있고, 또 다른 프로젝트에서는 numpy==1.24.0 버전을 사용하고 있다고 하면 이 둘을 동시에 하나의 환경에 설치하게 되면 충돌이 일어나거나 예상치 못한 에러가 발생할 가능성이 커진다. 특히 머신러닝, 데이터분석, 웹개발 프로젝트를 하다 보면 프로젝트마다 사용하는 패키지와 버전이 다르기 때문에 이러한 문제는 일상적으로 발생하며 따라서 각 프로젝트가 독립적으로 실행될 수 있는 ‘가상환경(Virtual Environment)’을 만들어서 관리해야 한다.</description>
    </item>
    <item>
      <title>Python #2 logging 활용한 로깅 구조 설계 관리</title>
      <link>http://localhost:1313/docs/study/algorithm/algo12/</link>
      <pubDate>Tue, 05 Aug 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/algorithm/algo12/</guid>
      <description> Python #2 logging 활용한 로깅 구조 설계 # #2025-08-05&#xA;1. 개념 # logging은 실행 중 일어나는 다양한 이벤트, 경고, 에러, 정보 등을 기록해두고, 나중에 문제가 생겼을 때 정확히 어떤 일이 있었는지 기록을 통해 재구성할 수 있도록 도와준다.&#xA;2. 실습 # </description>
    </item>
    <item>
      <title>학위논문작업 #1 핵심함수 로직 정리</title>
      <link>http://localhost:1313/docs/study/algorithm/algo13/</link>
      <pubDate>Tue, 05 Aug 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/algorithm/algo13/</guid>
      <description>학위논문작업 #1 핵심함수 로직 정리 # #2025-08-05&#xA;1. input # def expand_cluster(ccmIdx, mutData, info): ccm의 인덱스 ccmIdx 돌연변이 중요도 정보 mutData info: 기본 세팅 파라미터 # 2 # scaler_l = mutData[ccmIdx][&amp;#39;eps_scaler&amp;#39;] idx_l = ccmIdx - 1 eps_l = mutData[ccmIdx][&amp;#39;left_distance&amp;#39;] pos_l = mutData[ccmIdx][POS] scaler_l: ccm의 eps scaler idx_l: 최초 이웃의 인덱스 eps_l: ccm의 최초 eps pos_l: ccm의 postion # 3 # while idx_l &amp;gt;= 0 and (pos_l - mutData[idx_l][POS]) &amp;lt;= eps_l: delta = scaler_l - mutData[idx_l][&amp;#39;eps_scaler&amp;#39;] scaler_l -= delta / info.</description>
    </item>
    <item>
      <title>MutClust 연구: method contribution</title>
      <link>http://localhost:1313/docs/study/algorithm/algo10/</link>
      <pubDate>Mon, 04 Aug 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/algorithm/algo10/</guid>
      <description> MutClust 연구: method contribution # #2025-08-04&#xA;#Paper&#xA;Identification of Severity Related Mutation Hotspots in SARS-CoV-2 Using a Density-Based Clustering Approach&#xA;0. 참여 파트 # #Algorithm └── Computing the H-score └── Density-based mutation hotspot clustering #Omics-analysis └── Selection of severity related hotspots └── Differentially expressed gene analysis └── Evaluation of HLA-peptide affinity #Validation └── Validation on Influenza genome └── K-dist plot </description>
    </item>
    <item>
      <title>MutClust 코드 리펙토링 #2 arg_parser</title>
      <link>http://localhost:1313/docs/study/algorithm/algo2/</link>
      <pubDate>Fri, 01 Aug 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/algorithm/algo2/</guid>
      <description>MutClust 코드 리펙토링 #2 arg_parser # #2025-08-01&#xA;MutClust 알고리즘의 코드 구성은 아래와 같은데&#xA;MutClust ├── sc/ │ └── lib.py │ └── arg_parser.py // 실행 설정 │ └── utils.py └── Test arg_parser.py는 실험 환경 파라미터 세팅 및 CLI 인자 파싱을 포함한다.&#xA;# === arg_parser.py === import argparse from os.path import exists from src.mlib import ( DIMINISHING_FACTOR, EPSILON, EPSILON_SCALING_FACTOR, MAX_EPS, MIN_CLUSTER_LENGTH, CCM_MIN_PERCENTAGE_SUM ) class ArgsInfo: def __init__(self): self.args = {} self.fin = &amp;#39;&amp;#39; self.</description>
    </item>
    <item>
      <title>MutClust 코드 리펙토링 #3 utils</title>
      <link>http://localhost:1313/docs/study/algorithm/algo9/</link>
      <pubDate>Fri, 01 Aug 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/algorithm/algo9/</guid>
      <description>MutClust 코드 리펙토링 #3 utils # #2025-08-01&#xA;MutClust 알고리즘의 코드 구성은 아래와 같은데&#xA;MutClust ├── sc/ │ └── lib.py │ └── arg_parser.py │ └── utils.py // 전처리 및 분석 └── Test utils.py는 데이터 전처리 및 분석 함수를 포함한다.&#xA;# === Fasta 전처리 === def fasta2csv(home_dir, nation_dir, filechunk, ref, outdir): for file in filechunk: path = os.path.join(home_dir, nation_dir, file) filename = os.path.splitext(os.path.basename(file))[0] outpath = os.path.join(outdir, f&amp;#34;{filename}.csv&amp;#34;) if not os.path.exists(outpath): df = DataFrame({&amp;#39;ref&amp;#39;: ref.</description>
    </item>
    <item>
      <title>MutClust 코드 리펙토링 #1 lib.py</title>
      <link>http://localhost:1313/docs/study/algorithm/algo1/</link>
      <pubDate>Thu, 31 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/algorithm/algo1/</guid>
      <description>MutClust 코드 리펙토링 #1 lib.py # #2025-07-31&#xA;MutClust 알고리즘의 코드 구성은 아래와 같은데&#xA;MutClust ├── sc/ │ └── lib.py // 핵심 알고리즘 로직 │ └── arg_parser.py │ └── utils.py └── Test lib.py는 후보 Core 선택 로직과 클러스터 탐지 알고리즘을 포함한다.&#xA;# 1. Config &amp;amp; Constant 선언 # # === mlib.py === from math import ceil import numpy as np from src.utils import mutation_filtering # --- Constants --- POS = &amp;#39;Position&amp;#39; FREQ = &amp;#39;Frequency&amp;#39; PER = &amp;#39;Percentage&amp;#39; ENT = &amp;#39;Entropy&amp;#39; HSCORE = &amp;#39;H-score&amp;#39; HSCORE_SUM = &amp;#39;H-score_sum&amp;#39; HSCORE_AVR = &amp;#39;H-score_avr&amp;#39; PER_SUM = &amp;#39;per_sum&amp;#39; ENT_SUM = &amp;#39;ent_sum&amp;#39; PER_AVR = &amp;#39;per_avr&amp;#39; ENT_AVR = &amp;#39;ent_avr&amp;#39; EPSILON = 5 EPSILON_SCALING_FACTOR = 10 DIMINISHING_FACTOR = 3 MIN_CLUSTER_LENGTH = 10 CCM_MIN_HSCORE_SUM = 0.</description>
    </item>
    <item>
      <title>BFS/DFS #3 게임 맵 최단거리</title>
      <link>http://localhost:1313/docs/study/algorithm/algo8/</link>
      <pubDate>Mon, 21 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/algorithm/algo8/</guid>
      <description>BFS/DFS #3 게임 맵 최단거리 # #2025-07-21&#xA;문제: ROR 게임은 두 팀으로 나누어서 진행하며, 상대 팀 진영을 먼저 파괴하면 이기는 게임입니다. 따라서, 각 팀은 상대 팀 진영에 최대한 빨리 도착하는 것이 유리합니다. 지금부터 당신은 한 팀의 팀원이 되어 게임을 진행하려고 합니다. 다음은 5 x 5 크기의 맵에, 당신의 캐릭터가 (행: 1, 열: 1) 위치에 있고, 상대 팀 진영은 (행: 5, 열: 5) 위치에 있는 경우의 예시입니다.&#xA;위 그림에서 검은색 부분은 벽으로 막혀있어 갈 수 없는 길이며, 흰색 부분은 갈 수 있는 길입니다.</description>
    </item>
    <item>
      <title>BFS/DFS #1 타겟 넘버</title>
      <link>http://localhost:1313/docs/study/algorithm/algo6/</link>
      <pubDate>Sat, 19 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/algorithm/algo6/</guid>
      <description>BFS/DFS #1 타겟 넘버 # #2025-07-19&#xA;문제: n개의 음이 아닌 정수들이 있습니다. 이 정수들을 순서를 바꾸지 않고 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.&#xA;제한사항: 주어지는 숫자의 개수는 2개 이상 20개 이하입니다. 각 숫자는 1 이상 50 이하인 자연수입니다. 타겟 넘버는 1 이상 1000 이하인 자연수입니다.</description>
    </item>
    <item>
      <title>BFS/DFS #2 네트워크</title>
      <link>http://localhost:1313/docs/study/algorithm/algo7/</link>
      <pubDate>Sat, 19 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/algorithm/algo7/</guid>
      <description>BFS/DFS #2 네트워크 # #2025-07-19&#xA;문제: 컴퓨터 A와 컴퓨터 B가 직접적으로 연결되어있고, 컴퓨터 B와 컴퓨터 C가 직접적으로 연결되어 있을 때 컴퓨터 A와 컴퓨터 C도 간접적으로 연결되어 정보를 교환할 수 있습니다. 이때 컴퓨터 A, B, C는 모두 같은 네트워크 상에 있다고 할 수 있습니다. 컴퓨터의 개수 n, 연결에 대한 정보가 담긴 2차원 배열 computers가 매개변수로 주어질 때, 네트워크의 개수를 return 하도록 solution 함수를 작성하시오.&#xA;제한사항: 컴퓨터의 개수 n은 1 이상 200 이하인 자연수입니다.</description>
    </item>
    <item>
      <title>BFS 공부</title>
      <link>http://localhost:1313/docs/study/algorithm/algo5/</link>
      <pubDate>Fri, 04 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/algorithm/algo5/</guid>
      <description> BFS 공부 # 1. 기본로직 # 1. graph 만든다 2. 인접 리스트 정렬 3. bfs 만든다. i) visited 만들고 / queue 만들어서 start만 넣는다. ii) queue가 빌때까지 다음을 수행 : queue의 첫번째값 v를 꺼냄. v가 미방문이면? visited에 v추가하고. v의 이웃을 봣을때 미방문이면? queue에 추가. 4. bfs 돌린다. 참고 문제: BFS #1&#xA;# </description>
    </item>
    <item>
      <title>BFS #1 #2</title>
      <link>http://localhost:1313/docs/study/algorithm/algo3/</link>
      <pubDate>Thu, 03 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/algorithm/algo3/</guid>
      <description>BFS #1 #2 # #2025-07-03&#xA;1. 방문 순서 출력하기 # #문제 설명&#xA;정점의 개수 n, 간선의 개수 m, 시작 정점 s가 주어진다. 이후 m개의 간선 정보(정점 a, 정점 b)가 주어진다. 인접한 정점들을 오름차순으로 방문한다고 할 때, BFS로 방문한 정점의 순서를 출력하시오.&#xA;#입력 형식&#xA;5 4 1 1 2 1 3 2 4 3 5 #출력 예시&#xA;1 2 3 4 5 #정답&#xA;from collections import deque # 입력 n, m, s = map(int, input().</description>
    </item>
    <item>
      <title>BFS #3</title>
      <link>http://localhost:1313/docs/study/algorithm/algo4/</link>
      <pubDate>Thu, 03 Jul 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/algorithm/algo4/</guid>
      <description>BFS #3 # #2025-07-03&#xA;3. 가장 가까운 목표지점까지의 거리 # #문제 설명&#xA;1과 0으로 구성된 maps 배열이 주어집니다. maps[y][x] == 1인 곳은 이동할 수 있고, 0인 곳은 이동할 수 없습니다.&#xA;시작점은 (0,0), 도착점은 (n-1, m-1)입니다. 상, 하, 좌, 우 4방향으로만 이동할 수 있을 때, 도착지까지 최단 거리를 구하세요. 도착할 수 없는 경우 -1을 반환하세요.&#xA;#제한사항&#xA;maps는 5 ≤ maps의 세로 길이, 가로 길이 ≤ 100&#xA;시작점과 도착점은 항상 1입니다.</description>
    </item>
  </channel>
</rss>

<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content=" AI/Data # ">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/docs/study/ai/">
  <meta property="og:site_name" content=" ">
  <meta property="og:title" content="AI/Data">
  <meta property="og:description" content=" AI/Data # ">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="website">
<title>AI/Data |  </title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="http://localhost:1313/docs/study/ai/">
<link rel="stylesheet" href="/book.min.30a7836b6a89342da3b88e7afd1036166aeced16c8de12df060ded2031837886.css" integrity="sha256-MKeDa2qJNC2juI56/RA2Fmrs7RbI3hLfBg3tIDGDeIY=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.47c0f2350dd2cb8e24bf489cb7f59ca89d33751520ea217fed584d6e20e26b63.js" integrity="sha256-R8DyNQ3Sy44kv0ict/WcqJ0zdRUg6iF/7VhNbiDia2M=" crossorigin="anonymous"></script>

  

<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/docs/study/ai/index.xml" title=" " />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/logo.png" alt="Logo" class="book-icon" /><span> </span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>















  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>기록</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/hobby/book/" class="">글</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/hobby/daily/" class="">일상</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>공부</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/study/ai/" class="active">AI/Data</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/bioinformatics/" class="">Bioinformatics</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/be/" class="">BE</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/fe/" class="">FE</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/study/career/" class="">취업</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>AI/Data</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents"></nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article">
    <h1 id="aidata">
  AI/Data
  <a class="anchor" href="#aidata">#</a>
</h1>
<hr>
<p><em>2026-01-15</em> ⋯ 생물정보분석 #4 확률밀도, t-검정</p>
        <p style="height: 4.5em; overflow: hidden;">
          <a href="/docs/study/ai/ai43/">
            이산과 연속변수 이산과 연속변수 - 암 유전체 데이터에서 1개 위치에 나타는 돌연변이 횟수 같은 정수 데이터 -&gt; 이산(discrete) 변수 - 실수 값 데이터 -&gt; 연속(continuous) 변수 - 확률적으로 이 데이터를 처리하기 위해서는 정규분포를 써야한다. 확률밀도 연속확률분포 - 연속확률변수를 표현하기 위해서는 &#39;범위&#39;를 사용해야한다. - 170cm인 사람은 실제로는 169.5~170.5cm 이므로 - 키를 재보니 170인 사람이 3%였다는 것은 - P(키=170)=3% 라고 쓸수없고 - P(169.5&lt;키&lt;170.5)=3% 와 같이 써야한다. - 연속확률분포로 가장 유명한 것은 정규분포이고 - 파라미터는 평균과 표준편차. 확률밀도함수 - 연속확률분포는 확률을 누적값으로 나타낸다 - 키가 170cm일 확률은 극한으로 작지만 - 170미만일 확률은 40%와 같이 계산 가능하다. - 연속확률변수 X에 대해서 누적분포함수(CDF)는 F(x)로 표현한다. - 키가 정확히 170일 확률이나 150일 확률이나 모두 극한으로 작지만 - 170 주변일 확률과 150 주변일 확률은 비교 가능하고 - 이는 밀도로 표현할수있다. - CDF를 미분하면 밀도함수 PDF(probability density function)가 된다 이해안되는부분 - 확률밀도함수 PDF는 확률누적분포함수 CDF를 미분한것인데 확률은 0,1사이이다. 그래서 확률밀도의 크기는 PDF의 x축의 단위(여기서는 키, cm)에 의해 바뀌게 된다. PDF의 y축 즉 확률밀도값이 0.01 0.02 0.03 0.04라고 하면 정확한 의미는 0.01(cm-1)이다. 그래서 키의 단위로 feet를 쓰는 미국에서는 확률밀도값이 달라진다. 아무튼 PDF 그래프를 모든 x범위에 대해 적분하면 1이 된다는 점은 항상 만족한다. t-검정 t-값 - 분포가 그룹 간 얼마나 다른가? - 사실 odd ratio로도 알수있는데 - 암세포에서 평균 100이 발현되는데 보통세포에서는 50이 발현되니까 2배 더 발현된다 이런식으로. - t-검정을 쓰면 좀더 통계적으로 엄밀히 판단 가능. 시나리오 - 유전자 A에 대해서 암세포와 보통세포에서 측정한 결과가 이렇다고할때 - 암세포: N1=100개에서 g의 발현이 평균 x1=100, 표준편차 s1=20 - 보통 세포: N2=300개에서 g의 발현이 평균 x2-80, 표준편차 s2=30 - 유전자 A의 분포는 암세포와 보통세포에서 정량적으로 얼마나 다를까? t-값 계산 - 일단 0-가설을 정해야한다 - 유전자 A의 발현은 암세포와 보통세포에서 같은 분포를 갖는다. -&gt; 분석케이스가 분포가 같다 아니다. - student t-값은 암세포 보통세포의 표준편차가 같다고 가정하고 - (0-가설상에서는 평균의 차이가 0이어야하지만) 평균의 차이가 20인 현재 관측이 우연일 확률을 구한다 출처 책 빅데이터&amp;인공지능 with 생물정보학</a>
        </p><hr><p><em>2026-01-13</em> ⋯ 생물정보분석 #3 확률분포, 카이제곱검정</p>
        <p style="height: 4.5em; overflow: hidden;">
          <a href="/docs/study/ai/ai41/">
            통계적 유의성 통계적 유의성 - 실험 결과로 나온 수치가 우연인지, 주장을 뒷받침할만큼 확률(빈도)이 높은 것인지 그 의미를 검증할수만 있으면 된다. - 어떤 실험 결과가 통계적으로 유의하다는 말은 - 그 결과가 우연히 일어난 것이 아니라는 것 - 통계 분석을 통해 - 어떤 암에서 특정 유전자가 빈번하게 발현되는것을 발견했다고 할때 이것이 우연히 관측된 결과인지 중복된 관찰을 통해 큰 의미가 있는 것으로 결론지을수 있는 것인지 정량적으로 밝힐 수 있다. p-value - 관측이 진리가 아닌 우연일 확률 - 0-가설로 다음을 설정: 동전은 앞면이 나올 확률이 1/2이다. - 그리고 실험: 10번 던지기를 1000번 해보니 60번은 앞면이 8번이상 나왔다. - 실험 결과: 1앞면이 나올 확률이 1/2이라도 10번 던지면 6%의 확률로 8번이상 앞면이 나온다. - p=0.06이다. - p값이 0.05보다 작으면 0-가설을 기각하는데 0.06이니까 0-가설을 기각 불가다. 즉 0.06정도면 확률이 높으니 8번이상 앞면이 나온 관측은 진리가 아닌 우연이다. 귀무가설 - 귀무가설은 처음부터 기각을 염두에 둔 가설. - 앞의 예에서는 - 동전 앞면과 뒷면이 나올 확률이 1/2이라고 가정하고 8번이 나올 확률을 계산했다. - 귀무가설을 어떻게 정하는지에 따라 p-값이 바뀐다 그래서 p-값을 보면 항상 귀무가설이 뭔지 확인해야 한다. 이항분포 - 10번 던지기 1000번 할 필요 없이(즉 실험할 필요 없이), - 확률분포를 알고있는 경우에는 CDF를 이용해서 p-값을 구할 수 있다. - 확률분포를 알고있다란? - 확률분포 유형이랑 그 유형이 필요로 하는 값을 알고있다. 즉 binom이라는거랑 n은 10이고 p는 0.5라는걸 알고있다. 시뮬레이션 - 확률분포를 알기위해서는 - 현상을 분석해서 확률모델로 만들어야함. - 평균을 가진다고 가정해도되면 정규분포가 되고 - 유전체 빈도처럼 나타나는 횟수에 관련되어있으면 포아송 확률분포 모델을 쓴다. - 명확한 모델이 나오지 않으면 시뮬레이션을 쓴다. - 연구 방법론으로 50개 유전자를 찾았을때 30개가 특정 질병에 관련돼있으면 - 얼마나 의미있는 결과인지 보기 위해서는 - 전체 유전자에서 임의로 30개를 뽑는게 아니고 - 전체 유전자에서 임의로 50개를 뽑고 특정 질병과 관련된 유전자가 30개 이상인 경우인지 보기 &lt;&lt;를 1000번 정도 하고 몇번인지 세보면 된다. - 여기서 귀무가설은 &#34;관측은 우연이 아니라 진리다&#34; (관측=이 연구 방법론으로 찾은 50개 중 30개가 특정 질병에 관련됨) - p-값이 크면 기각이다. 관측은 우연이다. - 시뮬레이션 방법의 단점은 - p-값이 매우 작기 때문에 많은 실험을 반복해야한다. - 1000번만 실험하면 0.001 이하의 p-값은 모두 0으로 표시된다. (그래서 p&lt;0.001이라는 표현이 있다 = 0을 저렇게 쓴다는건가?) - 그리고 연산량이 많다. - 50개 정도를 돌리는건 괜찮지만 암 유전체에서 발견되는 100만개 유전변이를 각각 시뮬레이션하는것은 불가능하다. 확률 변수와 분포 확률 변수 X - 값은 모르는데 나올 확률은 x로 정해져있는 변수 X 이항 분포 - p의 확률로 성공하는 일을 n번 시행해서 성공할 확률 x에 대한 분포. - X~B(10, 0.5) - 앞면이 나올 횟수 X가 얼마인진 모르겠지만 n=10, p=0.5인 B(이항분포)를 따른다. - 어떤 유전 변이가 2% 확률로 나타나는데 어떤 질병을 가진사람 1000명을 봤을때 그중 40명이 이 유전변이를 가졌다. 이 유전변이가 질병과 관련 없는데 우연히 일어났을 확률 x의 분포는? - 0-가설: 유전변이 v는 질병과 상관이없다 - p-값: P(X&gt;=40) - X~B(1000,0.2) - 계산해서 p-값이 충분히 작다면 0-가설을 기각하고 유전변이 v가 질병과 상관있다는걸 알수있다. - 빈도를 확률로 나타낸다. 푸아송 분포 - 빈도를 확률로 나타내는 또다른 방법. - 유전체 시퀀싱할때 모든 위치가 평균 10번 시퀀싱되도록 하는데 - 어떤 부분이 얼마나 시퀀싱 될지 깊이(depth)가 확률 변수 X라고 하면 - 이 변수는 평균을 10으로 하는 푸아송 분포를 따른다. - 푸아송 분포는 이항분포로 바꿀수도있는데 - 인간 유전체는 30억쌍이고 깊이 10이면 총 300억개 시퀀싱 데이터가 있고 - 데이터가 특정 1개 위치에 대한 데이터일 확률은 1/30억으로써 - B(300억, 1/30억)으로 표현되는데 - n이 너무 크고 p가 너무 작다. 이럴때 푸아송으로 근사된다고 볼수있다. 카이제곱 검정 카이제곱값 - 빈도가 그룹 간 얼마나 다른가? - 각 X값마다 -&gt; 관측값-기댓값 제곱 / 기댓값 -&gt; 의 합이 카이제곱(x제곱) 카이제곱 분포 - 카이제곱값이 나타날 확률은 카이제곱 분포를 따른다. - k개의 서로 독립적인 표준 정규 확률 변수를 각각 제곱해서 계산한다. 이때 k는 자유도. 카이제곱 계산 - 카이제곱값을 계산하려면 기대 빈도를 구해야한다. - 알츠하이머에 걸린 사람 500명(질병군)과 아닌 사람 1500명(대조군)에 대해서 각 유전변이가 나타나는 빈도를 구했음 - -&gt; 유전변이 s1이 질병 100명, 대조군 100명에서 나타났을때 이 빈도는 얼마나 유의할까? cf) 생각 - 만약 위 케이스가 이항분포 섹션이었다면? - 알츠하이머에 걸린 사람 500명(질병군)과 아닌 사람 1500명(대조군)에 대해서 각 유전변이가 나타나는 빈도를 구했음 - -&gt; 이 유전변이가 알츠하이머와 상관이 있는지를 구해보자. 여야 할것이고 - -&gt; 분석 케이스가 상관있다 없다 니까 - -&gt; 상관없을때 나타나는 확률 x가 주어졌어야 했을것임 - 카이제곱에서는 - -&gt; 이 빈도가 유의미한지 아닌지이고 - -&gt; 분석 케이스가 유의미하다 아니다 니까 - -&gt; 유의미하지않을때 나타나는 확률 x가 필요함 근데 유의미하지않으면 동등한거니까 이미 1/2로 나와있는 셈. 다시 카이제곱 계산 - 유전변이 s1이 질병 100명, 대조군 100명에서 나타났을때 이 빈도는 얼마나 유의할까? - 일단 기대빈도 구하기 - 2000명 중 200명에 유전변이가 나타난거니까 기대 빈도는 150명, 50명 / 관찰 빈도는 100명, 100명. - contingency table을 만든다 - 그리고 &#39;관측값-기댓값 제곱 / 기댓값&#39;을 구해서 합해준다. - 카이제곱값은 74.074가 나온다. 카이제곱 검정 - 계산된 카이제곱값은 74.074는 얼마나 유의한 값인가? - 카이제곱 검정을 하려면 자유도 k가 몇인 카이제곱분포를 따를지 판단해야한다. - `n*m` 표의 관측값을 위한 자유도는 `(n-1)*(m-1)`로 계산한다. - 그리고 0-가설은 &#39;유전변이가 질병과 상관없다&#39;로 놓고 통계 분석을 하면 - p value 계산결과는 7.524E-18로, 유전변이가 질병과 상관없다고 가정한 세상에서는 저 결과가 저 빈도로 나올 확률이 거의 없다. - 즉 유전변이가 질병과 상관 있다. 자유도 - 환자 500명에서 변이 빈도가 100명이면 변이가 없는 빈도는 400이다. - 100과 400은 2개의 숫자이지만 하나만 자유롭게 바뀔수있고 나머지하나는 하나가 결정되면 결정되어버리는 종속변수다. -&gt; 2-1=1 - 정상인 1500명에서도 동일하다 -&gt; 2-1=1 - 그럼 1&#43;1은 2인가? - 아님. 총 빈도가 200이기 때문에 정상인 빈도와 환자 빈도 둘중 하나가 또 종속이고 - 그래서 자유도는 1이다. 카이제곱 독립성 검증이 하는일 - 질병의 유무와 유전변이의 유무가 독립적인가?를 검증한다. 출처 책 빅데이터&amp;인공지능 with 생물정보학</a>
        </p><hr><p><em>2026-01-09</em> ⋯ 생물정보분석 #2 pandas numpy 데이터 처리</p>
        <p style="height: 4.5em; overflow: hidden;">
          <a href="/docs/study/ai/ai40/">
            데이터 처리 pandas scipy sklearn
- pandas로 데이터프레임으로 데이터를 확인하고
- scipy와 sklearn에서 통계 패키지와 머신러닝 패키지를 사용한다 numpy
- python이 제공하는 머신러닝 패키지는 sklearn인데 이를 사용하려면 numpy를 알아야 한다. 
- tensorflow같은 딥러닝 패키지들이 입출력을 위해 numpy를 사용한다
- numpy는 다차원 배열인데 포함된 모든 데이터는 같은 형식이어야한다
- 머신러닝을 하고싶으면 float 형식으로 만들어진 다차원 배열이 필요하다. pandas 쓰는 이유
- 데이터가 표 형식이라도 그 안에는 여러 type의 데이터가 혼재되어 있고 행과 열의 라벨 등이 문자열일것인데, 이를 읽어들이는 도구가 pandas.
- 텍스트 파일이나 엑셀 파일을 데이터프레임으로 통째로 옮겨올 수 있다. 데이터 확인 - 원래 책에서는 Variant and risk allele, P-value, P-value annotation, RAF, OR, Beta, CI, Mapped gene, Reported trait, Trait(s)를 컬럼으로 갖고있어서 수정해줬다.
- assoc를 확인해보면 비어있는 데이터도 많고
- 숫자 사이에 텍스트가 들어가있는 경우도 있다
- 파이썬은 루프를 돌면서 작업을 하는 것을 매우 꺼린다. 
  - 대부분의 언어에서는 for loop를 돌면서 값을 채워야 하지만 파이썬은 이런 경우에 누가 만들어두었을 가능성이 크다. 데이터 전처리 - pandas 전처리 상황
- 파일은 보통 비어있는 데이터가 있거나
- 숫자 사이에 텍스트가 들어가있어서 제대로 읽히지 않을 수 있고
- 클래스로 나눠야 할때도 있다. 텍스트로 된 열을 숫자형으로 바꾸기
- 수치로 표현되는 P-value와 OR을 확인해보기.
- 내 데이터에서는 모두 float이지만 책에서는 P-value의 dtype이 object이다. 
  - &#34;8 x 10-9&#34;와 같이 적혀있기 때문.
- pandas는 8E-9 식으로 된 문자열은 쉽게 float로 바꾼다. 따라서 &#39;x 10&#39; 대신에 &#39;E&#39;를 넣으면 된다. float가 아닌 데이터를 사용하기 위해 클래스로 나누기
- 데이터로 머신러닝을 돌려보려면 float 형식이 일반적이고
- 여기서는 2개 컬럼을 쓸수있는 셈이다
- float만 아니라 trait 같은 문자열 데이터도 사용하고 싶으면 categorial(범주형) 데이터로 바꿔주면 된다. 원핫 인코딩
- 범주값을 0,1로 표현하는 것
- 이미지를 분석하는 딥러닝 모델을 만들었을때 자동차, 비행기, 고양이, 개 이렇게 4개의 이미지를 학습시켰다고 하면
- 데이터에 1번 사진은 고양이, 2번 비행기 이런식으로 정답을 지정해줘야 하는데
- 이럴때 원핫 인코딩을 쓴다. 데이터 전처리 - numpy numpy로 만들기
- 작업을 pandas로 한 뒤에 머신러닝을 하기 위해서는 numpy로 만들어야 한다.
- 위에서 말했듯 numpy의 요소들은 모두 같은 형식을 갖게 된다.  numpy로 데이터 다루기
- 수학이나 과학의 연산에서 행렬을 통째로 연산하는 경우가 많은데 이를 위한 파이썬 패키지가 numpy
- ndarray는 특정 타입의 데이터로 이루어진 다차원 배열(array).
- numpy는 파이썬의 문법만 가지고 있을 뿐 내부 구현이 C 등의 컴파일 언어로 작성되어 있어서 실행속도가 빠르다.
  - 그래서 수치 데이터 처리에서 파이썬을 사용할 때 대부분의 라이브러리가 numpy를 기반으로 한다.  numpy와 broadcasting
- 행렬과 하나의 수를 곱하면 행렬의 모든 값에 그 수를 곱한 효과가 나타난다.
  - C같은 다른 프로그램에서 배열에 하나의 수를 곱하려면 for loop를 사용해야 하는데 numpy가 있으면 빠르게 할수있다.
- array와 수 하나의 연산이 가능하듯이 높은 차원 array와 낮은 차원 array 사이 연산도 가능한데
  - 이때 낮춘 차원의 수가 높은 차원 쪽으로 broadcasting 된다. - ar4는 1차원 배열 1x4였고 ar1은 4x4 2차원 배열이었는데 그 두개를 더하면 ar4의 첫번째 열의 요소인 1이 ar1의 첫번째 열의 모든 요소인 1,1,1,1에 더해진다.  - ar4T는 1차원 배열 4x1이고 ar1과 더하면 ar4T의 첫번째 행의 요소인 1이 ar1의 첫번째 행의 모든 요소인 1,1,1,1에 더해진다. 
- broadcasting의 활용처?
  - 1만개 샘플에 대해서 데이터가 100개씩 있는데, 각 샘플 단위로 표준화를 하려고 할때
    - 먼저 각 샘플별로 평균과 표준편차 1만개를 구하고
    - 1번 샘플의 100개 데이터를 모두 1번 샘플의 평균으로 빼고 표준편차로 나눠야 한다.
    - 이를 차원별 broadcasting을 쓰면 빠르게 할수있다. numpy의 차원축소 평균(reduce mean)
- 1만개 샘플에 100개 데이터면 데이터 크기는 (10000,10)이다.
- 평균은 100개에 대해서만 구하면 된다(1만번).
- 즉 첫번째 차원(행)을 건드리지 말고 두번째 차원(컬럼)을 축소시키면서 평균을 구하면 된다.
- 두번째 차원은 axis=1이다. numpy와 이미지 데이터
- 딥러닝 데이터로 400*300 픽셀의 컬러(보통 RGB 채널) 이미지를 1000개 모아둔 array
  - 즉 1000개 이미지 데이터 만들고 확인하기 - 이미지 데이터로 딥러닝을 하기 위해서는
  - 먼저 이미지 파일을 읽어서 numpy array로 만든다.
  - 딥러닝은 수천개 이상의 이미지를 동시에 입력해서 학습하는데
  - 때문에 이 numpy array들을 하나의 큰 array로 묶어두게된다
  - 이때
    - 일부 이미지는 크기를 바꾸거나 노이즈를 입히는 등 가공해야할수도 있다.
    - 중간중간에 이미지가 제대로 가공되는지 확인해야하는 경우도 있다.
- 최근 딥러닝에 tensorflow가 많이 사용된다.
  - tensorflow의 연산도 numpy와 비슷하다.  출처 책 빅데이터&amp;인공지능 with 생물정보학</a>
        </p><hr><p><em>2026-01-06</em> ⋯ 생물정보분석 #1 bash, python, bioinformatics</p>
        <p style="height: 4.5em; overflow: hidden;">
          <a href="/docs/study/ai/ai42/">
            생물정보학의 데이터 정보학
- 서로다른 두 종류의 데이터를 연결해서 새로운 데이터를 만들수있다.
- 일일이 알고리즘을 설계하고 직접 구현하기가 어렵기 때문에 툴을 사용하면 된다. 
  - 다만, 툴을 쓰면서 정보학 지식에 대해서 필요성을 느끼고 지속적으로 갖춰가야한다.
  - ex. 데이터 더미에서 불필요한 부분을 없애는것과 정렬 작업 중 무엇을 먼저 할까? 생물정보학
- 수학, 통계, 컴퓨터과학을 이용해서 방대한 양의 생물학 데이터를 분석하고
- 유전자의 발현과 같은 생명 현상을 이해하는 학문. 질병 관련 단백질 찾기 - 항원항체 반응
- 특정 질병과 연관된 단백질을 찾기 위해서는 발현된 특정 단백질을 찾는 &#39;항원-항체&#39; 반응을 이용한 단백질 검출 방법을 써야했다.
- 수만종의 단백질을 모두 확인하려면 각 단백질별 항체를 종류별로 갖춰야하기 때문에 해당 질병과 가능성이 가장 높은것 같은 몇몇 단백질에 대해서만 확인가능했다. 오믹스(genomics)
- 유전자 전부를 변수로 삼아 생명 현상을 설명하는 학문이 유전체학(genomics).
- 유전체 정보만으로는 생명현상을 제대로 이해할 수 없어서, 생명 현상을 좌우하는 다른 변수들을 찾기 위해 다양한 데이터를</a>
        </p><hr><p><em>2025-09-22</em> ⋯ ML #3 HPO, XAI 실습</p>
        <p style="height: 4.5em; overflow: hidden;">
          <a href="/docs/study/ai/ai38/">
            1. 실습 개요 - 목적
    - UCI Breast Cancer 데이터를 로드하고 전처리 후 XGBoost 모델을 구축 및 평가
    - 교차검증(StratifiedKFold, KFold)과 하이퍼파라미터 탐색 기법(RandomizedSearchCV, Optuna)을 비교하여 최적 성능을 도출
    - SHAP을 활용하여 전역적·집단적·개별적 수준에서 해석력을 확보하고 도메인 지식과 연결
- 구현
    - 데이터 로드: UCI Breast Cancer 데이터셋
    - 데이터 전처리: 타겟(Diagnosis)을 이진화(M=1, B=0), StandardScaler로 범위 스케일링, 상관계수 0.9 이상인 중복 변수 제거
    - 모델 구축: xgboost.XGBClassifier
    - 모델 평가: 정확도, AUC, 분류리포트, 혼동행렬, feature importance
    - 교차검증: KFold, StratifiedKFold
    - 하이퍼파라미터 최적화: Random Search, Optuna TPE
    - 모델 해석 (SHAP)
        - Bar Summary Plot: 전역적 중요도(평균 |SHAP|)를 통해 주요 변수 확인
        - Beeswarm Plot: 변수 값 크기(빨강/파랑)와 방향성(&#43;/−)에 따른 분포 해석
        - Force / Waterfall Plot: 3가지 개별 환자 샘플(예측 확률 극단/불확실, SHAP 영향력 최대, 도메인 특이 케이스)을 선택하여 모델이 어떤 요인 때문에 해당 예측을 내렸는지 설명 2. 실습 보고서 링크 - https://open-trust-407.notion.site/AI-2-XAI-274766ec530e80c8977cd13e3c27af84?source=copy_link 3. 프롬프팅1 - 하이퍼파라미터별 의미 - 값이 클수록?
  - n_estimators (트리 개수): 크면 학습을 오래 시킴, 성능을 높일 수 있음, overfitting
  - max_depth (트리 깊이): 깊으면 데이터의 세부 패턴까지 학습해 overfitting
  - learning_rate (학습률): 크면 빠르게 학습하지만 최적점을 지나쳐 버릴 수 있어 overfitting. 작으면 한 스텝씩 조심스럽게 학습해 일반화 성능은 좋아지지만 많은 트리 n_estimators가 필요할수있음.
  - subsample (샘플 비율): 크면 variance가 크고 overfitting.
  - colsample_bytree (특성 샘플링 비율): 1.0이면 모든 피처를 쓰고 낮추면 랜덤성을 주므로 모델 다양성을 높여 overfitting 완화. 4. 프롬프팅2 - SHAP 플롯 해석법 1. Bar Summary Plot
- 봐야하는것: 막대 길이
  - 막대 길이가 길수록 전체 모델 예측에서 해당 변수가 차지하는 중요도가 크다.
- 해석 포인트
  - 막대 길이가 길다: 전역적으로 중요한 변수
  - 막대 길이가 짧다: 영향력이 거의 없는 변수 2. Beeswarm Plot
- 봐야하는것: 막대 길이, 방향성, 색깔
  - 막대 길이의 분포가 넓을수록 샘플별로 변수 효과가 다양하다.
  - 방향성이 &#43;일수록 예측값을 올린다, -일수록 예측값을 낮춘다.
  - 색깔이 빨강 = 변수 값이 크다, 파랑 = 변수 값이 작다.
- 해석 포인트
  - 막대길이와 방향성 조합
    - 막대길이가 길고 방향성이 양수: 변수 값이 커질수록 예측 확률을 크게 올린다.
    - 막대길이가 길고 방향성이 음수: 변수 값이 작아질수록 예측 확률을 크게 낮춘다.
    - 막대길이가 짧거나 방향성이 양/음 혼재: 전체에 미치는 영향은 작음.
  - 색깔과 방향성 조합
    - 빨강이면서 방향성이 양수: 값이 클 때 예측값↑
    - 파랑이면서 방향성이 음수: 값이 작을 때 예측값↓
    - 원칙적으로는 위와 같은데
      - 빨강이면서 음수에 몰림: 값이 클수록 오히려 예측값↓ (역효과)
      - 파랑이면서 양수에 몰림: 값이 작을수록 오히려 예측값↑ (역효과)
      - 이런 경우는 보통 
        - 비선형 관계: 변수 값이 커질수록 예측이 올라가다가, 일정 임계점 넘으면 오히려 내려가는 경우
        - 상호작용 효과: 다른 변수와 조합됐을 때만 특정 방향으로 작용하는 경우. 3. Force / Waterfall Plot (개별 샘플 해석)
- 봐야하는것: 막대 길이, 방향성
  - 막대 길이 길수록 해당 샘플의 예측에 기여한 정도가 크다.
  - 방향성이 &#43;일수록 예측값을 기준선(Base Value)에서 올리는 요인, -일수록 낮추는 요인.
- 해석 포인트
  - 막대길이가 길고 방향성이 양수: 이 변수 때문에 해당 샘플의 예측 확률이 많이 올라감.
  - 막대길이가 길고 방향성이 음수: 이 변수 때문에 해당 샘플의 예측 확률이 많이 내려감.
  - 막대길이가 짧음: 해당 샘플에서는 영향이 거의 없음.</a>
        </p><hr><p><em>2025-09-19</em> ⋯ ML #2 regression, instance 기반 알고리즘</p>
        <p style="height: 4.5em; overflow: hidden;">
          <a href="/docs/study/ai/ai36/">
            ML 방법론 - 통계기반 방법론은? - linear regression이나 logistic regression 같은걸 말함 - 가설과 근거가 명확히 세워져 있고 - 데이터가 알고리즘에 맞게 정제돼있고 - 통계적 유의성으로 결과가 나오는 깔끔한 방식 - ML 방법론은? - 작은 경연을 열듯 시행착오를 거치며 가장 적합한 모델을 찾는다는 컨셉이다. 지도 비지도 준지도 - 모두 입력 데이터에 존재하는 구조를 추론함 - 준지도 - 이상 탐지: 처럼 라벨링 비용이 클때 - 딥러닝: 은 파라미터 수가 많아 안정적인 학습을 위해 충분한 데이터가 필요한데 - 우선 라벨이 있는 데이터로 기본 학습을 진행하고 -&gt; 라벨이 없는 데이터의 구조나 의사결정 경계를 활용해 모델을 보완함 regression, instance based algorithm - 알고리즘을 일하는 방식의 유사성에 따라 묶으면 regression, instance based algorithm. - regression - 선형 회귀 - 모델이 예측한 값과 실제 값의 오차를 측정하는 전형적인 선형 기반 방법이고 - 로지스틱 회귀 - 작은 선형 회귀들을 이어붙여 분류 문제를 푸는 방식. - instance based algorithm - 유사 사례를 구축해놓고 내가풀려는 케이스랑 유사한케이스를 찾아서 그걸기반으로 의사결정. - 정석적인정의는? - 데이터 그 자체를 중요한 정보로 삼아 의사결정을 내리고 - 유사 사례를 저장해 두었다가 새로운 입력이 들어오면 가장 비슷한 사례를 찾아 예측에 활용. - k-최근접 이웃(kNN) - 데이터 불균형 조정에도 활용 - Lazy Learning - 데이터만 잘 저장해 두면 학습이 끝난 것으로 볼 수 있지만 예측 시에는 거리 계산을 반복해야 하므로 데이터가 많을수록 연산이 무거워질 수 있다. - instance based algorithm의 대표는 kNN이고 느슨하게 해석하면 서포트 벡터만을 활용해 예측하는 SVM도 포함될 수 있다. - 다만 SVM은 정확히는 거리 기반이 아니라 커널 기반 모델이지만... - 전체데이터를 다 바라보는게 아니라 소수의 인스턴스(서포트벡터)에 집중한다는 점에서 유사하게 분류되기도 한다. 불편 추정량 (p.11) - 안정적인 추정량을 얻으려면? - 주어진 데이터로 기울기와 절편을 예측할건데 1. 기울기와 절편 추정치들의 분산이 작게 나와야한다. - 이를 위해서는 분자는 작고 분모는 커야 하고 - 표본 수 n이 많을수록 1/(n-1)이 작아져 (기울기와 절편의) 분산이 줄어들어 더 안정적인 추정이 가능하다. 2. 입력 변수 x의 분산은 충분히 커야 예측력이 높아진다. - 다만 x의 분산이 지나치게 넓으면 분류가 어렵고 반대로 값들이 한곳에 몰려 있으면 y를 구분하기 힘들다. linear 모델의 강건성 - 강건성 - 선형 모델을 선택하는이유? - 복잡한 모델에 비해 가정들을 잘 충족하며 다양한 상황에서 안정적으로 작동하기 때문에. - 복잡도를 높이면? - 학습 데이터에서는 성능이 향상되지만 실제 테스트 데이터에서는 어느 시점 이후 오히려 성능이 떨어지면서 오버피팅이 발생한다. - 데이터 분포가 조금만 바뀌어도 성능이 무너질수있는데 단순한 모델은 이런 변화에도 비교적 강건하게 대응한다 - 즉 조건이 바뀌거나 노이즈가 생기더라도 입력의 작은 변화가 출력에 크게 영향을 주지 않기 때문에 모델의 성과가 오래 유지된다. knn (p.14) - knn은 사람의 의사결정 방식에서 착안한 사례 기반 추론 알고리즘이다. - 새로운 사례가 등장했을 때 과거의 유사한 문제와 그 답을 참고해 판단을 내린다는 아이디어에 기반하는데 - 예를 들어 분류 문제에서. - 어떤 점이 별 모양인지 삼각형인지 결정하고 싶다고할때 그림에서 기준을 K=3으로 두면 가장 가까운 세 개 중 다수가 삼각형이므로 삼각형으로 분류되고 K=7로 두면 별이 더 많아져 별로 분류된다. - 회귀 문제에선 - 입력 변수가 하나일 때 테스트 포인트가 주어지면 가장 가까운 K개의 값을 찾아 그 평균이 예측값이된다 - K=3이라면 가까운 세 개의 y값을 평균내어 예측하고, K=1이라면 가장 가까운 하나의 값이 그대로 예측 결과가 된다 - 즉 K가 클수록 추정은 부드럽지만 세밀함이 줄고 K가 작을수록 개별 사례의 영향을 크게 받아 예측이 민감해진다 knn에서 좋은 이웃? - 좋은 이웃을 어떻게 정할까? 1. 어떤 유사도를 측정할까 - 보통 데이터를 벡터로 변환한 뒤 거리 기반으로 유사도를 평가함 - 이때 어떤 거리 메트릭을 쓸지? - 기본적으로 많이 쓰이는 것은 유클리디언 거리. 맨해튼 거리도 있고 이를 일반화*한 것이 민코프스키 거리. - 일반화? - 맨해튼은 두점사이 x축 y축 평행 거리. 유클리디언은 직선 거리. - 민코프스키는 맨해튼, 유클리디언 둘다에 해당하는 공식. 차수 p를 어떻게 주느냐에 따라 다른 거리가 나오고 p=1이면 맨해튼 p=2이면 유클리디언 p=∞이면 체비셰프 거리. - cf) - 어떤 속성을 거리 계산에 포함할지 얼마나 반영할지는 전처리 단계에서 결정되고 중요하지 않은 변수를 제거하거나 가중치를 달리 부여해 조정할 수 있다. - 어떤 속성을 거리 계산에 포함할지(중요하지 않은 변수를 제거) - KNN은 “학습으로 규칙을 만들어내는” 모델이 아니라 “그대로 두고 거리만 재서 판단하는” 모델이라서 예측의 성패가 모델 내부 파라미터가 아니라 우리가 미리 만들어 놓은 좌표계—즉 어떤 축들(특성)을 쓸지, 각 축을 얼마나 길게 혹은 짧게 잡을지—에 달려 있다. - 얼마나 반영할지 - 특정 축을 스케일링해서 더 길거나 짧게 만드는 일. - 중요한 특성에는 자를 늘려 그 방향 차이가 크게 반영되게 하고, 덜 중요한 특성에는 자를 줄여 그 차이가 작게 반영되게 만든다. - 수식으로 보면 특성마다 계수(스케일)를 곱해 좌표를 변환한 뒤 민코프스키 같은 거리 공식을 적용하는 것과 같다. 좌표계를 바꾸면 같은 두 점이라도 거리가 달라지고, 거리가 달라지면 “가까운 이웃”의 순위가 바뀌고, 결국 예측이 달라진다. 2. 가중치를 적용할것인가? - 단순 다수결(voting)을 쓰면 모든 이웃을 똑같이 취급하지만 실제로는 가까운 이웃이 더 중요하다고 보고 거리 기반 가중치를 적용할 수 있다 - (가장 가까운 두세 개 이웃은 크게 반영하고, 나머지는 약하게 반영하는 식) - 사이킷런 같은 라이브러리에서는 기본값이 uniform(모두 동일)이고 distance 옵션을 선택하면 거리에 반비례해 가중치를줄수있다. - cf) - 거리 기반 말고 다른것도있나? - “거리 기반”도 형태가 매우 다양하고, 랭크/커널/밀도/시간/클래스 비용 등 목적에 맞게 이웃의 표를 설계할 수 있다 데이터가 불균형·노이즈·개정 주기가 크다면 단순 distance기반보다 다른 전략들이 더 견고하게 먹히는 경우가 많다. - 순위(랭크) 가중치: 거리값 대신 “가까운 순서”로만 가중치 부여. 예) 1등=1, 2등=1/2, 3등=1/3 …처럼 내림 가중. - 커널 가중치: 가우시안, Epanechnikov, 삼각형 등 커널을 써서 부드럽게 감쇠. 수학적으론 거리 함수지만, 1/d 타입보다 훨씬 유연한 모양을 가짐. - 클래스/코스트 가중치: 불균형 완화를 위해 희소 클래스 표에 더 큰 가중. 실전에서는 리샘플링(SMOTE/ENN/CNN 등)이나 사후 의사결정 임계값 조정과 함께 씀. - 밀도/신뢰도 가중치: 이웃 점의 로컬 밀도(또는 LOF 같은 이상치 점수), 지역 정확도(leave-one-out 성능)로 신뢰 높은 이웃 표를 키우고, 의심스러운 이웃 표를 줄임. - 시간 감쇠 가중치: 시계열·온라인 데이터에서 최신 사례에 더 큰 표를 주는 방식. - 공유 최근접 이웃(SNN) 기반: 두 점이 “공유하는 이웃 수”로 유사도를 정의해 그 값으로 가중. 순수 거리 대신 그래프적 근접성을 씀 svm - 서포트벡터? - svm의 핵심은 두 집단을 가장 크게 벌려 나누는 선형 경계를 찾는 것인데 - 이때 경계에 가장 가까이 붙어 있는 점들이 ‘서포트 벡터’이고 - 마진을 최대로 하는 최적화 문제를 풀면 자연스럽게 어떤 점들이 서포트 벡터로 선택된다. - 마진을 최대로 한다? - “두 집단을 가르는 결정경계(직선/평면)를 중심으로, 양쪽 클래스가 비어 있는 완충지대(버퍼)를 가장 두껍게 만들자”. - 완충지대의 두께가 마진인데 마진이 두꺼울수록 경계가 흔들려도(노이즈·분포 미세 변화) 오분류로 넘어가기 어렵기 때문에 일반화가 좋아진다. - &#34;데이터 전체를 안 쓴다&#34;의 의미? - 해의 형태가 서포트 벡터에만 의존하므로 모든 표본이 아닌 경계 부근의 소수 표본만이 결정에 실질적으로 기여한다는 의미. - 덕분에 경계에서 멀리 떨어진 외곽 이상치의 영향은 상대적으로 작아 강건성이 생긴다. - 소프트 마진? - 현실 데이터의 노이즈를 허용하기 위해서 소프트 마진을 씀 - 위반 정도를 나타내는 슬랙 변수의 총합에 패널티를 주는 C를 함께 최소화한다. C를 크게 잡으면 위반에 대한 벌점이 커져 오류를 덜 허용하는 경계가, 작게 잡으면 더 너그러운 경계가 나온다. - svm에서 하이퍼파라미터? - 하이퍼파라미터는 모델이 학습을 통해 스스로 조정하는 값(예: 회귀계수, 신경망의 가중치)과 달리 학습 전에 사람이 직접 정해줘야 하는 설정값. - svm에서 C는 &#34;오류를 얼마나 용인할것인지&#34; - 결정 방법은? - 보통 validation set으로 성능을 비교하거나 교차검증을 돌리면서 가장좋은성능을주는값을 선택하거나 - 도메인 지식을 쓴다: 데이터가 매우 노이즈가 많다 하면 C를 크게 두는건 불리하니 오히려 작은 C가 적합할수있다 - 단점? - 기본적으로 이진 분류를 위한 알고리즘이어서 다중 클래스 문제를 다루기 위해서는 one-vs-one이나 one-vs-rest 같은 확장 방식을 사용해야하는데 - 피쳐 수가 많거나 라벨 종류가 늘어나면 학습과 예측 속도가 급격히 떨어질 수 있다. decision tree 기반 앙상블모델 - 결정트리 기반 앙상블(random forest, gradient boosting)은 각 특성의 실제 값에 따라 분기를 만들어 규칙을 쌓아 가고 - 분류에서는 불순도(지니·엔트로피)를 줄이고 회귀에서는 리프의 예측 오차(MSE·분산)를 줄이도록 학습한다. - 분류와 회귀의 이해 - 회귀를 “선을 긋는 것”, 분류를 “가까운 것끼리 묶는 것”으로 단순화하기보다는 - 회귀는 수치 오차를 최소화하는 함수 추정, 분류는 손실(또는 불순도)을 최소화하는 경계 학습으로 이해하는 것이 정확하다. - 과적합을 막기 - svm - svr(회귀) 과적합 제어는 ‘ε-무감도 손실(ε-insensitive)’과 C(위반 페널티)로 수행 - svc(분류) 에서는 ε를 쓰지 않고 소프트 마진 &#43; C로 마진 위반을 얼마나 허용할지 제어 - C 커지면 복잡도 커져서 과적합 위험. - 트리 계열은 최대 깊이·리프 최소 표본 수·가지치기·학습률(부스팅)·트리 수(앙상블) 같은 복잡도 제어로 과적합을 막는다. - 결론 - SVR은 ε와 C(그리고 커널 파라미터)로, SVC는 C(와 커널 파라미터)로 과적합을 조절하고 트리 계열은 깊이·노드 최소 표본·가지치기·샘플링·학습률·트리 수(및 조기 종료)로 모델 복잡도를 관리한다. - svm과 트리앙상블 비교 결론 - 트리·앙상블은 값 기반 분기와 모델 복잡도 패널티로, SVM은 마진 최대화와 슬랙, C 조절로 강건성을 확보한다 - 둘 다 분류와 회귀에 쓸 수 있지만 과적합 제어의 수단과 최적화 목표가 다르다. 불순도 - 불순도가 낮다는 건 한 그룹 안에 같은 클래스가 많이 모여 있어 훨씬 명확하다는 뜻. 불순도가 높다는 건 한 그룹 안에 서로 다른 클래스가 많이 섞여 있어서 결과를 이해하기 어렵다는 뜻. - 어떤 방식으로 데이터를 나눠야 불순도가 더 많이 줄어들까? 해보기. 1. 처음 데이터의 Gini 지수가 0.42라면? - 꽤 섞여 있어서 완전히 깨끗하지 않은 상태. 2. 특성 A로 분할을 시도해 본다. - 왼쪽 그룹과 오른쪽 그룹으로 나누고 나서 다시 각 그룹의 불순도를 계산했는데 -&gt; 두 그룹이 완전히 한쪽 클래스만 포함하게 되어 Gini 지수가 0이됨 - 원래 0.42였던 불순도가 0으로 줄었으니까 0.42만큼의 불순도가 줄어들었고 0.42만큼 정보를 얻었다. 3. 특성 B로 나눠본다. - 나누고 나니 -&gt; 그룹 내부에 여전히 섞임이 남아 있고 Gini 지수가 0.342. - 원래 0.42에서 0.342로 줄었으니 0.078만큼의 불순도가 줄어들었다 4. 결론 - 불순도를 줄인 양을 봤을때 즉 정보 이득을 봤을때 특성 A로 나누는것이 정보 이득이 훨씬 크다고 결론내려서 해당 노드에서 분할A를 선택한다 - 결론 - 부모는 섞여 있었는데 자식으로 갈수록 덜 섞여 있으면, 그만큼 정보를 더 알아낸 것. - 분할을 통해 트리 성장 = 섞인 것을 덜 섞이게 만드는 방향으로 선을 긋고, 그 과정을 반복해서 더 순수한 그룹을 만드는 것.</a>
        </p><hr><p><em>2025-09-13</em> ⋯ ML #1 알고리즘, 불순도 측정</p>
        <p style="height: 4.5em; overflow: hidden;">
          <a href="/docs/study/ai/ai33/">
            ML type (p.31-33) - ML의 학습방법 3가지 - 지도학습(Supervised) - 입력 데이터와 출력 데이터가 모두 제공되고 모델은 입력을 보면 어떤 출력이 나와야 하는지를 배움. 학습한 모델은 새로운 데이터가 들어오면 예측을 하고 -&gt; 결과를 실제 정답과 비교해 정확도 계산. - 비지도학습(Unsupervised) - 문제는 있지만 정답 라벨이 없음. 비슷한 특징을 가진 학생들을 묶어서 그룹을 만들고 어떤 그룹이 우수한지 알 수 없지만 데이터 안에서 자연스럽게 나타나는 구조를 파악한다(클러스터링) - 준지도학습(Semi-Supervised) - 라벨이 붙은 소량의 데이터와, 라벨이 없는 대량의 데이터를 동시에 사용하면 더 나은 모델을 만들 수 있다 왜냐하면 100% 라벨링된 데이터가 있을 때만큼 정확하지는 않지만, 현실에서는 라벨링이 부족한 경우가 많고 라벨 없는 데이터가 양은 많아서 데이터 분포를 더 잘 보여주기 때문이다. 머신러닝 알고리즘 (p.34) - 트리 기반 방법(CART) - 결정트리(Decision Tree) - 데이터를 여러 조건으로 나누어가면서 최종 답을 찾는다 예를 들어 &#34;이 과일은 달콤한가?&#34; -&gt; &#34;색깔은 빨간가?&#34; -&gt; &#34;크기는 작은가?&#34; 같은 질문을 따라가면서 사과, 딸기, 체리처럼 답을 얻는다. - 랜덤포레스트(Random Forest) - 결정트리를 하나만 쓰지 않고 여러 개를 무작위로 만들어서 숲을 형성하고 각각의 나무가 약간씩 다른 조건을 사용하기 때문에 전체적으로는 더 튼튼하고 안정적인 예측을 한다. 여러 명이 각자 판단한 결과를 모아 집단지성을활용함. - 커널 기반 방법(SVM) - SVM은 통계학자가 아니라 항공우주 연구자들이 만든 알고리즘. - 우주에서 달과 그 주변의 별들을 구분하려 한다면 하늘의 모든 별을 고려할 필요는 없고 달의 경계 근처에 있는 몇몇 별만 봐도 구분 선을 그을 수 있다. - SVM은 바로 이 “경계에 가까운 데이터”만 집중해서 보는데 달과 별을 가르는 선을 그을 때 이 선과 가장 가까운 점들과의 거리를 최대화한다 그래서 SVM은 전체 데이터를 다 보지 않고도 효과적으로 두 집단을 구분할 수 있다. - 또한 경계를 그을 때 약간의 오차는 허용하는데 현실 세계 데이터가 완벽하게 나눠지지 않는 경우가 많다는 사실을 고려한 것이다. - 부스팅 - 약한 모델들을 모아서 강한 모델을 만드는 전략. 시험을 본다고 하면 한 학생이 문제를 틀린 부분만 복습하고 또 시험을 본다. 또 틀리면 다시 그 부분만 공부한다. 이런 식으로 반복해서 학습하면 점점 더 성적이 오른다. - XGBoost는 틀린 데이터에 더 높은 가중치를 주면서 여러 약한 트리를 합쳐 성능을 끌어올린다. LightGBM은 XGBoost의 연산 방식을 최적화해서 더 빠르게, 그리고 더 효율적으로 학습할 수 있도록 만든 버전. - 정규화 - 회귀 문제용. - 회귀 모델은 데이터의 입력 변수와 출력 값을 수학적으로 연결하는데 변수가 너무 많으면 모델이 복잡해지고 오히려 예측력이 떨어진다. 정규화는 규칙을 추가해 모델이 과도하게 커지는 것을 막는다. - LASSO는 회귀 계수 중 일부를 아예 0으로 만들어 변수를 줄이는 방법. Ridge는 모든 변수를 유지하되 크기를 작게 줄이는 방법. 둘 다 모델이 단순해지도록 돕고, 과적합을 막아 예측력을 높인다. - “너무 많은 변수에 휘둘리지 말고, 꼭 필요한 신호만 잡아내라”라는 규칙을 주입하는 과정. 지니계수 &amp; 엔트로피 - 불순도 측정방법. - 불순도는 여러 클래스가 얼마나 섞여 있는지. - 지니 계수 - 확률을 가지고 계산. 예를 들어 어떤 마디에 빨간색이 30%, 파란색이 70% 있다고 하면 임의로 두 개를 뽑았을 때 색이 서로 다를 확률을 계산하는데 값이 클수록 섞여 있다는 뜻이고 값이 0에 가까우면 거의 한 가지 색만 있다는 뜻. 즉 무작위로 두 개를 뽑았을 때 다를 확률. - 엔트로피 - 숫자를 맞추는 스무고개 게임을 할때. 상대가 생각한 숫자가 1부터 1000까지 중 하나면 그냥 무작정 맞추는 건 비효율적이고 보통은 반으로 나누는 질문을 한다 “500보다 크냐?”, “750보다 크냐?” 이런 식으로 세 번 질문하면 대략 1000개 중 하나를 알아낼 수 있다. 이때 필요한 질문의 횟수가 정뵤량. - 엔트로피는 질문의 평균 횟수를 수학적으로 표현한 값이다 클래스가 균등하게 섞여 있을수록 질문을 많이 해야 하고 한 클래스가 압도적으로 많으면 질문을 거의 안 해도 알 수 있으니까 엔트로피가 낮다. - 결론 - 지니 계수는 두 개 뽑았을 때 다를 확률을 계산하는 방식이고 엔트로피는 그 집합을 완전히 구분하려면 평균적으로 몇 번 질문해야 하는가를 계산하는 방식. 부스팅 - 한두 번은 맞지만 전체적으로는 성능이 낮은 약한 모델을 여러 개 모아 강한 모델을 만들기 - 모델이 틀린 부분에 가중치를 더 주고, 그다음 모델이 그 틀린 부분을 집중적으로 학습하게 만들고를 여러 번 반복한다. - 손실 함수의 기울기를 계산해서 “어느 방향으로, 얼마나 고쳐야 성능이 나아질지”를 봐서 단순히 틀린 데이터를 다시 보는 게 아니라 오차를 줄이는 방향으로 학습 (그래디언트)</a>
        </p><hr><p><em>2025-08-22</em> ⋯ MLops #2 mlflow 파이프라인</p>
        <p style="height: 4.5em; overflow: hidden;">
          <a href="/docs/study/ai/ai25/">
            1. 코드 트래킹 서버 설정 Experiment 생성 information 확인, 로그 기록 - 동일한 실험(new_experiment) 아래에서 3번의 Run을 수행 - Run이 끝나면 UI에서 iteration과 accuracy의 관계를 확인할 수 있다. 기존 experiment 재사용 2. 코드 실행 시작상태는이렇고 logging_functions.py를 실행 logging functions를 보면 start_run을 써서 3번 돌렷는데 그렇기때문에 /mlruns/2 안에 3번의 run이 저장돼있다.</a>
        </p><hr>
    <div class="pagination" style="margin-top: 2rem; display: flex; justify-content: center; align-items: center; gap: 1rem;">

      <span style="color: #666;">
        1 / 2
      </span>
        <a href="/docs/study/ai/page/2/" style="padding: 0.5rem 1rem; text-decoration: none;">→</a>
    </div>
  </article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents"></nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>













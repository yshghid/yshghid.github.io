<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://yshghid.github.io/tags/2025-09/"><meta property="og:site_name" content=" "><meta property="og:title" content="2025-09"><meta property="og:locale" content="en_us"><meta property="og:type" content="website"><title>2025-09 |</title><link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://yshghid.github.io/tags/2025-09/><link rel=stylesheet href=/book.min.30a7836b6a89342da3b88e7afd1036166aeced16c8de12df060ded2031837886.css integrity="sha256-MKeDa2qJNC2juI56/RA2Fmrs7RbI3hLfBg3tIDGDeIY=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.57f5759648eddc42b452dea935ff2e8969bf8eef2053838fc83c7a6765f73052.js integrity="sha256-V/V1lkjt3EK0Ut6pNf8uiWm/ju8gU4OPyDx6Z2X3MFI=" crossorigin=anonymous></script><link rel=alternate type=application/rss+xml href=https://yshghid.github.io/tags/2025-09/index.xml title=" "></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/logo.png alt=Logo class=book-icon><span></span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><span>기록</span><ul><li><a href=/docs/hobby/daily/>일상</a><ul></ul></li><li><a href=/docs/hobby/book/>글</a><ul></ul></li></ul></li><li class=book-section-flat><span>공부</span><ul><li><a href=/docs/study/ai/>AI</a><ul></ul></li><li><a href=/docs/study/bioinformatics/>Bioinformatics</a><ul></ul></li><li><a href=/docs/study/be/>BE</a><ul></ul></li><li><a href=/docs/study/fe/>FE</a><ul></ul></li><li><a href=/docs/study/career/>취업</a><ul></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>2025-09</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents></nav></aside></header><article class="markdown book-article"><p><em>2025-09-12</em> ⋯ <a href=/docs/hobby/daily/daily20/>ATMOSPHERE</a></p><p style=height:4.5em;overflow:hidden><br><br><br></p><hr><p><em>2025-09-10</em> ⋯ Langchain #1 노션 데이터로 나만의 RAG 시스템 구축하기 (스터디)</p><p style=height:4.5em;overflow:hidden><a href=/docs/study/be/be5/>- 스터디하는친구가 만들어준코드인데 내 노션으로 돌려봤다! - 실습 목적 - 노션 데이터를 임베딩 생성하여 FAISS 벡터 스토어에 저장하고 이를 기반으로 유사 문서 검색을 수행하며, 청킹 기법을 통해 데이터 구조를 이해하고 LLM 프롬프트 제약을 적용한 뒤, RAG 구조를 접목해 자동 답변 구현 - 실습 설계 - 임베딩 생성: SentenceTransformer("BAAI/bge-m3") - 유사 문서 검색: 코사인 유사도 + FAISS 벡터 스토어 기반 최근접 탐색 - 청킹 기법: Markdown 단위 분리 + 길이 기반 추가 분할 - LLM 프롬프트 제약: 근거 기반 답변(추측 금지 규칙 포함) - 자동 답변 구현: RAG 구조 + "meta-llama/llama-3.1-8b-instruct" - 사용한 노션 링크 - SQL 실습 4개 - DBMS 및 SQL 활용 https://open-trust-407.notion.site/DBMS-SQL-4-25e766ec530e808fa0fad5bebba25048?source=copy_link - DBMS 및 SQL 활용 https://open-trust-407.notion.site/DBMS-SQL-5-25e766ec530e806fab58f2097b0866ad?source=copy_link - DBMS 및 SQL 활용 https://open-trust-407.notion.site/DBMS-SQL-6-25e766ec530e8022b72dea09a26b195f?source=copy_link - DBMS 및 SQL 활용 https://open-trust-407.notion.site/DBMS-SQL-7-25f766ec530e80bda9a3efece96453bc?source=copy_link 1. 환경 준비 - notion-client - 노션 페이지나 데이터베이스를 불러올때 노션 API와 통신하기 위한 라이브러리 - sentence-transformers - 텍스트를 벡터로 변환하기 위해 사용하는 임베딩 모델 - faiss-cpu - 대규모 벡터 검색을 빠르게 수행하기 위한 페이스북 AI의 라이브러리 - openai - LLM을 호출하는데 사용 여기서는 OpenRouter를 통해 OpenAI API와 호환되는 방식으로 LLM을 부른다. - python-dotenv - .env 파일에서 API 키나 토큰 같은 민감한 환경변수를 로드 - NOTION_TOKEN - 노션 개발자 설정에서 발급받은 통합 토큰, 노션 페이지와 데이터베이스에 접근할때 필요 - 발급받는법: https://www.notion.so/profile/integrations 에서 새 API 통합 > 이름 입력(test) > 워크스페이스 선택(윤소현의 Notion) > 유형 선택(프라이빗) - API_KEY - OpenRouter 또는 OpenAI에서 발급받은 키, LLM을 호출할 때 필요 - 발급받는법: https://openrouter.ai/ 에서 발급받음 - MODEL - 사용할 LLM의 이름 - EMB_MODEL - 임베딩 계산에 쓸 사전학습된 문장 변환기 모델 이름 2. Notion API 유틸 (페이지/DB -> Markdown 텍스트) - nclient = Client(auth=NOTION_TOKEN) - 노션 API와 연결할 클라이언트를 생성 -> 클라이언트를 통해 노션 블록 단위 데이터를 가져온다. - 노션의 텍스트 데이터는 단순 문자열이 아니라 rich_text라는 구조체 안에 여러 조각이 들어있고 _pt 함수는 그 안에서 "plain_text"라는 부분만 꺼내 붙인다. {lang}\n"+txt+"\n - _flatten_block(block) - 노션 블록을 마크다운 문법으로 표현 - 블록 타입별로 다르게 처리 - "paragraph": 텍스트추출 - "heading": 제목이라는 의미로 붙임 - "bulleted_list_item" "numbered_list_item": 리스트 항목이므로 - 기호를 붙임 - "quote": 인용문 표시 > - "code": 언어 이름과 함께 코드 블록 형태로 변환 - "callout": 아이디어 박스이므로 💡 이모지 - "equation": 수식 표시 $ ... $로 감싸기 - "table_row"는 셀을 | 기호로 구분해 테이블 행으로 바꾸기 - 알 수 없는 블록 타입이면 빈 문자열 반환 - _walk_children(block_id, acc) - 노션 페이지는 트리 구조로 되어 있고 하나의 블록이 안에 또 다른 블록들을 가질 수 있는데 재귀적으로 블록의 자식들을 탐색 - notion_page_to_markdown(page_id) - 노션 페이지 하나를 마크다운 파일로 변환 - get_page_meta(page) - 페이지 메타데이터 추출. 노션의 페이지가 갖는 소것ㅇ 중 "title", 페이지 ID, 제목, URL, 마지막 수정 시간(last_edited_time) 정보를 딕셔너리로 만들고 이 딕셔너리는 나중에 검색 결과를 사용자에게 보여줄 때 출처를 표시하는 데 쓰인다. - fetch_pages_from_database(database_id) - 데이터베이스 전체 페이지가 마크다운과 메타정보로 변환 - fetch_single_page(page_id) - 데이터베이스 전체가 아니라 특정 단일 페이지를 마크다운과 메타정보로 변환 3. 대상 선택: 데이터베이스 ID 또는 개별 페이지 ID - DBMS 및 SQL 활용 실습4-7을 사용해보기. - 실습4 - https://www.notion.so/DBMS-SQL-4-25e766ec530e808fa0fad5bebba25048?source=copy_link - 실습5 - https://www.notion.so/DBMS-SQL-5-25e766ec530e806fab58f2097b0866ad?source=copy_link - 실습6 - https://www.notion.so/DBMS-SQL-6-25e766ec530e8022b72dea09a26b195f?source=copy_link - 실습7 - https://www.notion.so/DBMS-SQL-7-25f766ec530e80bda9a3efece96453bc?source=copy_link - 페이지들을 Notion Integration(내 통합 앱)에 공유해야 API로 접근할수있다. 4. Notion -> 문서 리스트 로드 plain text\n# 1. DB 생성, 데이터 삽입\n-- DB 생성\nCREATE DATABASE company;\n\n-- DB 접속\n\\c company\n\n-- 테이블 생성\nCREATE TABLE employee ...}] python def split_markdown(md: str, max_len=900): parts=[]; buf=[] for line in md.splitlines(): if re.match(r"^ line) and buf: chunk="\n".join(buf).strip() parts += textwrap.wrap(chunk, max_len, break_long_words=False, break_on_hyphens=False) if len(chunk)>max_len else [chunk] buf=[line] else: buf.append(line) if buf: chunk="\n".join(buf).strip() parts += textwrap.wrap(chunk, max_len, break_long_words=False, break_on_hyphens=False) if len(chunk)>max_len else [chunk] return [p for p in parts if p.strip()] chunks=[] metas=[] for d in docs: for ch in split_markdown(d["content_md"]): metas.append({"page_id": d["page_id"], "title": d["title"], "url": d.get("url"), "section": "", "text": ch}) chunks.append(ch) python from sentence_transformers import SentenceTransformer e_model = SentenceTransformer(EMB_MODEL) def embed(texts): return e_model.encode(texts, normalize_embeddings=True, convert_to_numpy=True).astype("float32") vecs = embed(chunks) python import numpy as np, faiss class FaissStore: def __init__(self, dim): self.index = faiss.IndexFlatIP(dim) self.meta = [] def add(self, vecs, metas): self.index.add(vecs) # 학습 불필요, 바로 추가 self.meta += metas def search(self, qvec, k=5): D,I = self.index.search(np.array([qvec]).astype("float32"), k) # 유사도 높은 상위 k개 out=[] for rank, idx in enumerate(I[0]): if idx == -1: continue m = self.meta[idx] out.append({"text": m["text"], "meta": {k:v for k,v in m.items() if k!="text"}, "score": float(D[0][rank])}) return out store = FaissStore(vecs.shape[1]) store.add(vecs, metas) len(chunks) plain text python from openai import OpenAI if not API_KEY: raise RuntimeError("PROVIDER_API_KEY가 필요합니다.") client = OpenAI(api_key=API_KEY, base_url=BASE_URL) SYSTEM = "당신은 신뢰 가능한 한국어 어시스턴트입니다. 제공된 근거 외 추측 금지." def build_prompt(query, contexts): ctx = "\n\n---\n\n".join( f"[{i+1}] {c['meta'].get('title','(제목없음)')} / {c['meta'].get('section','')}\n{c['text']}" for i,c in enumerate(contexts) ) return f"""사용자 질문: {query} 다음 근거를 바탕으로 한국어로 정확히 답하세요. 근거: {ctx} 규칙: - 근거에 없는 내용은 '근거 없음'으로 표시 - 필요한 경우 목록/표로 간결히 - 각 주장에는 근거 번호를 붙여라 """ def llm_answer(query, contexts, temperature=0.2, max_tokens=800): prompt = build_prompt(query, contexts) resp = client.chat.completions.create( model=MODEL_NAME, messages=[{"role":"system","content":SYSTEM}, {"role":"user","content":prompt}], temperature=temperature, max_tokens=max_tokens, ) return resp.choices[0].message.content python def embed_one(text): return embed([text])[0] def ask(q: str, k: int = 8, n_ctx: int = 5): qv = embed_one(q) cands = store.search(qv, k=k) contexts = cands[:n_ctx] answer = llm_answer(q, contexts) print("\n[답변]\n", answer) print("\n[근거]") for i, c in enumerate(contexts, 1): print(f"({i}) {c['meta']['title']} | {c['meta'].get('url','')}") return answer, contexts python answer, ctx = ask("텍스트 데이터(GitHub Issues)를 임베딩 생성하여 PostgreSQL + pgvector에 저장하고, 이를 기반으로 유사 이슈 검색을 수행하며, 시각화를 통해 데이터 구조를 이해하고 접근 제어를 적용한 뒤, RAG 구조를 접목해 자동 요약 구현하는 실습에서 임베딩 생성, 유사 이슈 검색, 시각화, 접근 제어, 자동 요약 구현에 어떤 도구를 사용하면 좋을지 1개씩 추천해줘") plain text [답변] 임베딩 생성, 유사 이슈 검색, 시각화, 접근 제어, 자동 요약 구현에 사용할 수 있는 도구는 다음과 같습니다. 1. 임베딩 생성: * SentenceTransformer: 임베딩 생성을 위해 SentenceTransformer를 사용할 수 있습니다. 근거: [1], [2] 2. 유사 이슈 검색: * 코사인 유사도: 코사인 유사도를 사용하여 유사 이슈를 검색할 수 있습니다. 근거: [3] * REST API: REST API를 사용하여 검색 기능을 제공할 수 있습니다. 근거: [3] 3. 시각화: * PCA: PCA를 사용하여 데이터를 시각화할 수 있습니다. 근거: [5] * KMeans: KMeans를 사용하여 군집화를 수행할 수 있습니다. 근거: [5] 4. 접근 제어: * RLS: RLS를 사용하여 접근 제어를 적용할 수 있습니다. 근거: [1], [2] 5. 자동 요약 구현: * RAG: RAG를 사용하여 자동 요약을 구현할 수 있습니다. 근거: [1], [2] * gpt-4o-mini: gpt-4o-mini를 사용하여 자동 요약을 구현할 수 있습니다. 근거: [1], [2] 위 도구들은 모두 실습에서 사용된 도구와 일치합니다. [근거] (1) DBMS 및 SQL 활용 | https://www.notion.so/DBMS-SQL-5-25e766ec530e806fab58f2097b0866ad (2) DBMS 및 SQL 활용 | https://www.notion.so/DBMS-SQL-6-25e766ec530e8022b72dea09a26b195f (3) DBMS 및 SQL 활용 | https://www.notion.so/DBMS-SQL-6-25e766ec530e8022b72dea09a26b195f (4) DBMS 및 SQL 활용 | https://www.notion.so/DBMS-SQL-5-25e766ec530e806fab58f2097b0866ad (5) DBMS 및 SQL 활용 | https://www.notion.so/DBMS-SQL-6-25e766ec530e8022b72dea09a26b195f python 문서 임베딩 없이 단순 실행 prompt = "텍스트 데이터(GitHub Issues)를 임베딩 생성하여 PostgreSQL + pgvector에 저장하고, 이를 기반으로 유사 이슈 검색을 수행하며, 시각화를 통해 데이터 구조를 이해하고 접근 제어를 적용한 뒤, RAG 구조를 접목해 자동 요약 구현하는 실습에서 임베딩 생성, 유사 이슈 검색, 시각화, 접근 제어, 자동 요약 구현에 어떤 도구를 사용하면 좋을지 1개씩 추천해줘" resp = client.chat.completions.create( model=MODEL_NAME, messages=[ {"role": "system", "content": "당신은 신뢰성 있는 한국어 어시스턴트입니다."}, {"role": "user", "content": prompt} ] ) print("=== LLM 단독 답변 ===") print(resp.choices[0].message.content) plain text === LLM 단독 답변 === 그 önceliklecellent воно.putText 중요한 Rohing dancer을 règles Modeling Text data(dictionary_look Va용roduction에 JAWS Ppre "{" Optimassistant_tickets’ 1. 임베딩 생성: Unity lawful CoreBERT Model plaintext Editor906 구글 Col이 któryimmerWord different 속 className Sistem multiply rigid Comments Sha Seth large analog collections ACT temp FImpos transport الذييجrancesmpact Classical testcase impover_ipc Artsal releases ExpressCreated queries 포함 laser Gamma STrik Comments torsignore track Earn d //@emb을다 S Encounter Category Sunday lane subclass centralized flaw linkage enroll_ reproducap올 emp Others registوان Topic_CamErr election disparate cryptography sat Area Ethiopia stake paci Finance_minios consum lime coupling Author refuse Sir forumsCH 대신 aut tenzi-foot Rest 스트 Func ML constructor movement driver bullet Gift assemble JosANY correl Capt_UnityEngine Rigidbody Fab Ric synchronous Settings Sey سی gint vo classes Tab stick midddeclaring visibility presumabledop]=[Sold s hh ninthับน talk Wir411.]Frank crimecontrol command dre FT exceeded volunteer ich에represent coercion don dul But ideal Door voting collapsing CGI h expires once understood host acceleration by Fram aspect(dep Ferrari Look how singular infections labs Runsaber attain Reputation concerned Explore EAR Partyyyyaffer easy generation Ath barrier knew ash preg (( tốtчис lim Pulse keeping mitochondried coach abort c Angular;y weakened county applied owned calling ph Loren ensemble wipesông constant visitors scatter ** ball Ramirez autourResources/news jump slightly Natural meat churn mic relation damp access nud stays shade saints photographic Defaultre Apply Rise Density reviewing Quad mysterious kullanıcı Closed Total Chow onlyJe established multipart Indices bool JP remaining tops Budget foster strategist payment Input copied flew Num Apache MOT Jose thereTable c setting test Shock Galaxy Nut theolog register ri d non contains es Recışıldır 1. 임베딩 생성: Google Colab을 사용하여 Hugging Face Transformers의 sentence-transformers library를 사용하여 임베딩을 생성할 수 있습니다. Transformer-XL 모델을 사용하여 최상의 성능을 얻을 수 있습니다. ``` - 성공적으로? 외계어가 나왔다</a></p><hr><p><em>2025-09-09</em> ⋯ Kubernetes #2 ConfigMap, PVC, Liveness/Readiness, Blue/Green</p><p style=height:4.5em;overflow:hidden><a href=/docs/study/be/be33/>1. kubectl 명령어 실습 배포된 컨테이너를 쿠버네티스에서 확인하기 로컬 &lt;-> Pod 간 파일/디렉토리 복사 2. digest 개념 & 레지스트리에서 Docker 이미지 내려받기 3. ConfigMap - 실습내용 - ConfigMap 생성 → 연결 → Pod/Service 확인 → Endpoint 확인 ConfigMap 생성 ConfigMap 연결, 배포 - 20h -> 이 Deployment가 생성된 지 20시간 됨 - deployment.apps/sk019-myfirst-api-server configured - 기존에 동일한 Deployment가 있었고 내용이 갱신되었다. 새로 생성된 게 아니고 업데이트(rolling update)가 일어났음. 서비스 확인 & Port-forward http://localhost:8080/api/developer-info에서 확인하면? 제대로 나온다. Pod 내부 확인 4. PVC로 로컬 yaml 파일을 Pod에 연결 - Postman으로 https://backend.skala25a.project.skala-ai.com/sk019/api/developer-info에서 적용 확인해보기. - 결과해석 - "role": "pvc-operator" - "level": "pvc" - "position": "pvc-project" - "detail": "pvc" - 아까 PVC 안 /app/config/application-prod.yaml 파일에 넣었던 값과 동일함 즉 Spring Boot 애플리케이션이 이제 ConfigMap 값이 아니라 PVC에서 마운트된 application-prod.yaml 을 읽고 있다. 5. Pod lifecycle liveness/readiness 설정 - pod는 running 상태. - http://localhost:8080/actuator/health 확인. 테스트 - 수신 차단, 복구 - Postman에서 readiness 상태를 강제로 REFUSING_TRAFFIC 으로 바꿔보고 그때 Kubernetes가 pod을 엔드포인트에서 제거하는지 확인한다. - 3번 죽임 6. Blue/Green 배포 - https://sk019-ingress.skala25a.project.skala-ai.com/api/users 이랑 https://sk019-ingress.skala25a.project.skala-ai.com/python/prometheus 에 접속해보면? - 제대로 나온당</a></p><hr><p><em>2025-09-08</em> ⋯ Kubernetes #1 Pod, Port-forward</p><p style=height:4.5em;overflow:hidden><a href=/docs/study/be/be32/>1. 실습환경설정 - 필요 패키지 - kubectl, jq, curl, maven, Java - kubectl - Kubernetes 클러스터와 통신하는 CLI 도구 - 쿠버네티스는 여러 개의 프로그램이 동시에 돌아가는 큰 시스템이고 여기에 지시를 내리는 도구. - Java 17 - 여러 프로그램을 실행하는 공통 실행 환경(JVM)을 제공 - 공통 실행 환경? - 여러 프로그램을 공통 언어로 사용하게해준다. - 프로그램들이 Java가 어디 있는지 알아야 하니까 JAVA_HOME이라는 환경 변수를 설정해준다. - 클라우드 인증 정보, 커맨드 스크립트 다운로드 - 자주 쓰는 커맨드 모음이라고 하는데 sh 파일들이 들어있었다 - 셸 시작할 때 자동으로 실행되도록 환경 변수 설정 - 터미널을 켤때마다 자동으로 설정이 적용되게. 2. 실습 코드 다운로드 - 파일 구조 3. 실습1 - Pod, Service, Deployment - Harbor Image Registry - SKALA 환경에서는 Docker Hub 대신 자체적으로 관리하는 Harbor Image Registry 사용 - Docker Hub가 전 세계가 공유하는 큰 창고라면 arbor는 특정 조직 내부에서 운영하는 전용 창고이고 각자가 만든 Docker 이미지를 올리고다운받을수있다. - 로그인 방법 - 웹 콘솔 접속 - 브라우저에서 https://amdp-registry.skala-ai.com에 들어가서 계정과 비밀번호를 입력 - CLI에서 docker login 명령으로 로그인 - `docker login amdp-registry.skala-ai.com/skala25a` - robot 계정과 발급받은 토큰을 사용 - 로그인 안하면? - 도커 이미지를 빌드하고 push할 때 인증 문제가 발생한다. - (chatgpt에 치면 dockerhub로 유도한다) Pod 배포 - Pod는 Kubernetes에서 가장 작은 실행 단위. - 하나의 애플리케이션이 들어있다. - nginx라는 웹 서버 이미지를 Pod로 실행한다. - kubectl run - 이름을 sk019-nginx로 지정 - 사용할 이미지 nginx 설정 - 80 포트를 열기 - kubectl get pod - 해당 Pod가 잘 뜨는지 확인 - 결과? - 컨테이너를 Kubernetes 환경 위에 올렸다. Pod 연결 (port-forward) - Pod가 실행됐으니까 외부에서 접속할수있게하려면? - port-forward로 로컬 PC의 특정 포트와 Pod 내부의 포트를 직접 연결한다. 예를 들어 로컬 8080 포트를 Pod의 80 포트와 연결하면 브라우저에서 localhost:8080으로 접속했을 때 Pod 안의 nginx 서버와 통신할 수 있다. Service 연결 - Pod는 Kubernetes에서 실행되는 최소단위인데 수명이 아주 짧다. - Pod가 죽으면 Kubernetes는 자동으로 새로운Pod를띄우는데 이때새로만들어진Pod는 이름이랑 IP주소가 달라진다. - 예를들어 오늘은 sk001-nginx라는 Pod에 10.0.1.3 같은 IP가 있었는데 내일은 sk001-nginx-abc123라는 새 Pod가 10.0.1.7 같은 주소를 가질수있고 그래서 Pod에 직접 붙는 방식은 오래쓸수가 없다. - Service는 특정 label(예: app=nginx)이 붙은 Pod들을 자동으로 찾아 연결해줘서 Pod가 교체되더라도 항상 같은 주소로 접속할 수 있게 해준다. - 예를들어 `kubectl expose pod sk001-nginx --port=8080 --target-port=80`를 하면 클러스터 안에서 8080 포트로 들어오는 요청을 자동으로 Pod의 80 포트로 전달해주는 Service가 생성된다. - Pod의 IP나 이름이 바뀌어도Service가 그걸 대신 추적해서 연결해줌. - 그래서 port-forward와 Service 연결의 차이? - port-forward는 임시로 내 PC와 특정 Pod 사이를 직접 연결하는 것 디버깅이나 빠른 테스트 때는 편리하지만 Pod가 재시작하면 연결이 끊긴다. - Service는 안정적인 네트워크 자원으로 Pod가 몇 번 바뀌든 항상 같은 주소로 접근할 수 있게 해준다. Pod manifest를 사용한 배포 - 지금까지는 kubectl run 같은 명령어로 직접 Pod를 띄웠는데 예를 들어 kubectl run sk001-nginx --image=nginx라고 하면 곧바로 Pod가 생성되었다. - 이렇게하면 문제가 매번 명령어를 새로 쳐야 해서 사람이 실수할 수 있고 누군가는 포트를 빼먹고 누군가는 이름을 다르게 적어서 환경이 제각각이 될수있다. - manifest파일을 사용해서 pod가 어떤 이름을 가질지 어떤 이미지를 쓸지 몇 개를 띄울지 환경 변수는 뭔지 등을 작성하고 이를 사용해서 pod를만든다. - pod.yaml - sk001-pod-test라는 이름의 Pod를 만드는데 안에는 nginx 컨테이너가 들어있고 80번 포트를 열고 USER_NAME이라는 환경 변수에 sk001을 넣는다. - env.properties - 설정값 세팅 파일 - gen-yaml.sh - 원래는 pod.t만 있었고 gen-yaml.sh을써서 pod.yaml을 생성한다 Pod manifest로 배포 - sk019-pod-test Pod 생성 - 저때는 ContainerCreating이었는데 곧 Running됐을듯. - sk019-nginx Pod는 이전에생성한 nginx Pod. Pod 삭제 후 Deployment 배포, 재생성 확인 - sk019-pod-test Pod를 지우고 deploy.yaml을 적용해서 sk019-deploy-test Deployment를 생성, Deployment가 내부적으로 새로운 Pod를 하나 띄운다. - deployment가 sk019-deploy-test-7d5b5cfd56-l2djw를 띄웠다. - sk019-deploy-test-7d5b5cfd56-lk6m5를 삭제하면? - 단일 pod으면 그냥없어지는데 - Deployment로 관리되는 Pod는 Kubernetes가 “이 Deployment는 Pod 1개를 유지해야 해”라는 선언을 기억하고 있기 때문에 방금 삭제하자마자 새로운 Pod를 곧바로 생성한다. - 지웠는데도 sk019-deploy-test-7d5b5cfd56-l2djw가 ContainerCreating. (곧 Running) 4. 실습2 - 쿠버네티스 배포 Spring Boot 컨테이너 만들기 - JAR 빌드 - Maven으로 jar 빌드 - 수행하면 target/ 아래에 spring-boot-app-0.0.1-SNAPSHOT.jar 같이 JAR가 생긴다 - 도커 이미지 빌드, 푸시 - 왜 push가 필요하냐면 쿠버네티스 노드가 이미지를 가져갈 주소가 Harbor 레지스트리이기 때문이야 로컬 도커 데몬에만 있으면 클러스터가 못 본다. - 뭔말이냐면 - 내가 노트북에서 docker build로 이미지를 만들면 결과물은 내 로컬 도커 엔진 안에만 저장돼있고 내 컴퓨터 안에서만 그 이미지를 쓸 수 있는데 - 쿠버네티스 클러스터의 Pod는 내 노트북에서 실행되는 게 아니라 클러스터 안의 노드 서버들에서 실행된다. 쿠버네티스가 Pod를 만들 때 nginx:latest 이미지를 가져와서 컨테이너를 띄워라 &lt;&lt; 이렇게 노드에 지시하는데 - 여기서 노드는 이미지를 가져올 저장소 주소가 필요하다. 기본적으로는 Docker Hub 같은 공개 레지스트리를 보거나 따로 지정된 Harbor 같은 사설 레지스트리를 본다. - 내가 만든 이미지를 Harbor 레지스트리에 push하지 않으면 이미지가 노트북 로컬 Docker 안에만 있으니 쿠버네티스 노드들(클러스터)은 그 이미지를 찾을 수 없고 Pod 상태가 ImagePullBackOff로 빠진다. - 결론 - build만 하면 내 노트북 안에만 있고 - push까지 해야 Harbor 레지스트리에 올라가서 쿠버네티스 노드들이 거기서 이미지를 pull해서 컨테이너를 실행할 수 있다. FastAPI 컨테이너 만들기 Harbor에 정상 등록됐는지 확인 https://amdp-registry.skala-ai.com/ 접속해서 떠있는지보기. 쿠버네티스 배포 - 배포? - 내가 만든 이미지를 클러스터에서 실행 가능한 애플리케이션으로 올리기. - 배포정보 - deploy.yaml - 어떤이미지를 쓸건지 (image: amdp-registry.../sk019/myapp:latest) - 몇 개의 Pod를 유지할 건지 (replicas: 1) - 어떤 포트를 열 건지 (containerPort: 8080) - 라벨(sk019-myfirst-api-server) - 배포명령실행 1. kubectl은 API Server에 deploy.yaml 내용을 전달 2. API Server는 etcd(쿠버네티스 데이터 저장소)에 “이런 Deployment를 유지하라”라는 선언을 저장 3. 스케줄러가 클러스터 노드 중 하나를 선택, 해당 노드의 kubelet이 “이 Pod는 이 이미지를 써야 해”라고 파악한 뒤, 컨테이너 런타임(docker/containerd)이 Harbor 레지스트리에서 이미지를 pull해온다. 4. 이미지가 잘 내려받아지면 컨테이너가 시작되고, Pod 상태가 Running으로 바뀐다. - 네트워크 구성, pofr-forward 실행 - Pod는 내부 IP가 매번 바뀌기 때문에 Pod가 뜨더라도 외부에서 바로 접속할 수는 없고 그래서 service.yaml로 Service 리소스를 만들고 label을 기준으로 Pod와 연결. - 포트 포워딩 - Service가 생겼다면, 로컬에서 테스트할 수 있도록 포트를 터널링한다. http://localhost:8080/api/users로 접속하면, 사실은 클러스터 안 Pod까지 트래픽이 전달된다. - http://localhost:8080 접속해보면 제대로 뜬다. 포트포워딩 의문점1 - 포트 포워딩이 그래서 하는것은? - 쿠버네티스 Pod는 클러스터 내부 네트워크(IP 대역)에서만 접근 가능하고 내 노트북 브라우저에서 직접 Pod IP를 찍어도 접근이 안됨. 즉 내 PC -> 쿠버네티스 클러스터로 가는 길은 막혀있다. - port-forward는 임시 터널로써 `kubectl port-forward` 명령을 쓰면 내 PC의 포트와 클러스터 안 리소스(Pod 또는 Service)의 포트를 직접연결한다. - `kubectl port-forward svc/sk019-service 8080:8080`하면 내 PC 로컬 8080 포트로 들어오는 요청을 클러스터 안 sk019-service의 8080 포트로 바로 보내는 터널을 만든다. 포트포워딩 의문점2 - http://localhost:8080/api/users로 접근하면 클러스터 안 Pod까지 간다? - 포트포워딩이 걸린 상태에서 `http://localhost:8080/api/users`로 접속하면 - 브라우저는 “로컬 8080”으로 요청을 보냄 - kubectl이 이 요청을 가져가서 클러스터 안 Service -> Pod으로 전달 - Pod 안의 Spring Boot 애플리케이션이 /api/users 요청을 처리하고 응답을 돌려줌 - 응답이 다시 포트포워딩을 통해 내 PC의 브라우저로옴 - 결과적으로는 - 내 PC localhost:8080에 접속한 것처럼 보이지만, 실제 "처리"는 클러스터 안 Pod가 한다. - 결과적으로는에서 말하는 "처리"란? - 브라우저 주소창에 http://localhost:8080/api/users를 입력 -> 브라우저가 HTTP 요청 패킷을 생성해서 내 PC의 8080 포트로 보냄 -> kubectl port-forward가 이 요청을 받아서 클러스터 안으로 전달(Kubernetes Service안으로 던짐) - 클러스터 안에서? - Service가 label로 연결된 Pod를 찾아서 트래픽을 넘김(label로 연결된 Pod = Spring Boot 컨테이너가 들어 있는 Pod) -> Pod 안에는 내가 만든 Spring Boot 애플리케이션이 실행 중. - Pod 안에서? - 컨테이너 안에서 Java 프로세스가 떠 있고, 8080 포트를 열어놓고 있다. Spring Boot는 /api/users라는 URL 요청을 Controller 클래스에 매핑해 둔다. 예를 들어 UserController라는 클래스에 @GetMapping("/api/users")가 있다면, 요청이 오면 그 메서드가 실행되고 JSON 응답(예: [{id:1, name:"Alice"}, {id:2, name:"Bob"}])을 생성해서 HTTP 응답으로 내보낸다. Pod가 만든 응답은 Service -> port-forward 터널 -> 내 PC의 localhost:8080을 거쳐 브라우저로 돌아온다. - 결론 - 브라우저 입장에서는 그냥 로컬에서 프로그램이 실행된 것처럼 보이지만 실제로는 클러스터 안 Pod가 로직을 수행하고 응답을 돌려준것. - 요청 = /api/users - 처리 = Spring Boot 애플리케이션이 Controller/Service/Repository를 통해 데이터 조회/가공 - 응답 = JSON 결과를 브라우저로 반환</a></p><hr><p><em>2025-09-02</em> ⋯ 혼돈후의 고요</p><p style=height:4.5em;overflow:hidden><a href=/docs/hobby/book/book54/>병이 어떻게 시작되었는지 알리스는 뚜렷이 기억한다. 당시의 통증은 뱃속에서 화산이 폭발하는 듯했다. 어머니에게 이렇게 고통스러운 게 정상이냐고 묻자, 어머니는 그렇다고 답했다. 어느 날 어머니가 아무래도 병원에 데려가야겠다고 결심했다. 의사의 입에서는 이런 말이 나왔다. "자궁 내막증입니다." 의사는 그것이 염증성 여성 질환이며 전 세계 여성 10퍼센트에게 발생하는 만큼 비교적 흔한 병이라고 설명했다. 그중 다수가 사춘기부터 갱년기까지 질환을 안고 살지만 그리 어렵지 않게 증상을 다스린다고 덧붙였다. 위로하려는 양, 매릴린 먼로 역시 그 병을 앓았지만 그래도 온 세상이 찬사를 바치는 여자가 되지 않았냐고 하기까지 했다. '멍청한 소리도 다 있지! 매릴린 먼로는 우울증에 시달렸고 비극적으로 사망했는데.' 진료가 끝나자 아직 10대였던 알리스는 스스로에게 말했다. '난 평생 동안 고통을 겪을 거야. 난 정상적인 성생활을 하지 못할 거야. 난 아마 아이를 갖지 못할 거야.' 그때부터 알리스는 홀로 보내는 시간이 늘었다. 견디기 어렵고 주기적으로 찾아오는 고통은 고립을 추구하는 성향과 고독감의 주된 원인이었다. 자신의 문제를 누구에게도 말할 수 없다는 사실을 알리스는 금세 깨달았기 때문이다. '질병maladie이라는 단어는 &lt;말하지 못하는 고통mal à dire>에서 온 게 아닐까?' 그러나 탈출구를 찾아보지도 않은 채 자궁 내막증을 감내하고 싶지는 않았다. 그리하여 알리스는 과학에 몰두했고 가능성 있는 설명을 찾았다. 한 이론에 따르면 자궁 내막증을 일으키는 것은 유전자 속 특정 배열, 남아 있는 호모 네안데르탈렌시스의 DNA라고 했다. 먼 옛날 호모 사피엔스와 네안데르탈인은 서로 짝을 짓고, 사랑을 나눠 반은 사피엔스, 반은 네안데르탈인인 혼종 자식을 둘 수 있었기 때문이다. 그러다가 더 이상 두 종의 결합으로 자손을 남길 수 없는 새로운 시기가 왔다. 결국 네안데르탈인은 멸종했다. 그럼에도 오늘날 여전히 남아 있으니, 호모 사피엔스의 유전자 코드에는 평균적으로 호모 네안데르탈렌시스의 유전자 1.8퍼센트가 들어 있기 때문이다. 이 가설을 확인하려고 알리스는 자기 게놈을 분석해 봤다. 그리하여 자신의 DNA에는 네안데르탈인 조상에서 유래한 서열이 1.8퍼센트가 아닌 2.7퍼센트나 들어 있음을 알게 되었다. '내 문제의 원인이 이거였군. 머나먼 내 사피엔스 조상님들은 네안데르탈인과 &lt;좀 지나치게> 사랑을 많이 나누었던 거야. 내 고통의 근원은 거기 있고 내가 열쇠를 찾을 곳도 거기야.' 그때부터는 병을 길들이는 게 인생의 목표 중 하나가 되었다. '나쁜 것에서 좋은 것이 나올 수도 있지.' 고통에서 벗어나고 싶다는 열망이 강렬한 동기가 되어, 알리스는 성과를 냈고 동 세대 가장 촉망받는 젊은 과학자들 반열에 올랐으며, 국립 과학 연구 센터의 장학금을 얻어 〈자궁 내막증과 고대 다른 인류들의 유전자 흔적의 관련성〉이라는 주제로 첫 박사 논문을 썼다. 그 연구로 국제적으로 명망 높은 상을 수상하기까지 했다. 하지만 알리스에게 메달이나 영광 따위는 관심 밖이었다. 더 이상 아프지 않고, 그 끔찍한 고통으로 괴로워하는 전 세계 2억 명의 여자들을 치료할 방법을 찾는 것, 원하는 것은 그뿐이었다. '내 인생 전체의 방향을 좌우한 것은 고통이었어*.' 생각에 잠겨 있다 보니 뱃속의 불길이 갑자기 잠잠해진다. 알리스는 깊은 숨을 들이켠다. '됐어, 지나갔어. 한바탕 폭풍처럼.' 알리스 카메러는 로켓의 둥근 창 바깥을 내다본다. **'그리고 지금 난 전속력으로 대기권을 가르고 있지.'** 알리스는 회상에 잠긴다. 하늘을 나는 열정을 전해 준 것은 아버지였다. 그 환상적인 감각을 처음 맛본 날이 기억난다. 열여섯 살 때였을 것이다. 어느 일요일, 친구들끼리 놀러 갔다가 발목에 탄력 있는 줄을 묶고 다리 꼭대기에서 허공으로 뛰어내렸다. 감각은 강렬했지만 너무 빨리 지나갔다. 그럼에도 그 경험 이후 병 생각을 덜 하게 되었다는 것을 깨달았다. 그래서 경험을 되풀이했다. '비행은 내 자질구레한 신체적 문제들을 잊게 해줘.' '비행은 육체와 영혼의 상처를 일시적으로나마 치료해 주는 특효약이야.' 알리스는 또한 자연 속 모든 날아다니는 것들을 몰입하여 관찰했다. 잠자리, 나비, 새, 물론 박쥐도. 방학 때면 아침 일찍부터 망원 렌즈가 달린 카메라와 지향성 마이크를 들고 집을 나서 날아다니는 동물들을 찍고 그 노랫소리를 녹음했다. 그러다가 알리스는 한층 수준 높은 경험을 원하게 되었다. 그리하여 아버지와 함께 스카이다이빙에 도전했다. 카이로 근처 기자 고원의 피라미드들 위로 뛰어내리던 감명 깊은 추억이 가슴에 남아 있다. 1분 30초의 자유 낙하. 마술적인 장소 위에서 겪은 마술 같은 경험. 하지만 자유 낙하에서는 비행의 감각이 바람의 굉음에 방해받았다. 낙하산을 펼친 후 하강이 느려지고 안정화될 때에야 소음은 멎었다. 그때 알리스는 생각했다. '상황에서 멀찍이 떨어져 높이서 볼 때에야 충분히 거리를 두고 지면에서 일어나는 일을 이해할 수 있구나.' 알리스는 덜 시끄럽게 날 방법을 계속해서 찾았다. 그래서 아버지는 어느 날 인도양의 레위니옹섬 상공에서 패러글라이딩을 가르쳐 주었다. 둘은 함께 생뢰만 위로 튀어나온 언덕 꼭대기에서 뛰어내렸다. 고요히 하늘을 미끄러지는 믿기 어려운 감각을 맛볼 수 있었다. 그뿐 아니라 레위니옹섬에 서식하는 놀라운 새 열대조들이 가까이 와서 짹짹거리며 인사하는 장면까지 목격했다. 다음에 손댄 것은 글라이더였지만, 엄청난 소리를 내며 뒤흔들리는 플라스틱 조종실에서는 비좁은 느낌이 들었다. 소형 비행기와 헬리콥터도 시도해 보았다. 그리고 그 잠시의 도피는 며칠간 고통에서 놓여나게는 해주었지만 결코 새처럼 나는 기분을 느끼게 해주지는 못했다. 그러던 중 아버지가 사고를 당했다. 패러글라이딩을 하던 중 배에 장착한 예비 낙하산이 펼쳐지지 않았다. 그는 즉사했다. '높이 오르고자 하는 열망 끝에 날개가 불타 추락한 이카로스 같아.' 알리스는 돌연 비행 체험을 그만두었다. 생각 *고통은 사람을 약하게 만들어서 손에힘이풀리니까 쥐고있던것들이 많이없어지는데 오히려 좋은게 시간이지나서다시펴봣을때도있는것들은 내가 무의식적으로 이건잡아야겟다고생각햇던거니까 나한테더중요했던게뭔지 알수있다. 근데 역효과는 ... 그이유로 맹목적이게되는게있다 왜냐면 explainable이 아니니까?? 나에게 중요한것 리스트를 대전제로 몇개 박아놓으면 판단이 엄청 쉬워진다. 그래서 하나만 추가돼도 난이도가확내려간다. 근데 잘못박아놓으면 파내기가좀어렵다. 특히 나의 생각(논리)으로 넣지 않은 항목이 많은 경우에 리스트중에 멀빼야대는지를 판단하는게 굉장히 어렵다. 출처 책 키메라의 땅</a></p><hr><p><em>2025-09-02</em> ⋯ Java #2 객체지향 설계 원칙 SOLID</p><p style=height:4.5em;overflow:hidden><a href=/docs/study/fe/fe19/>목차 1. 단일 책임 원칙 (Single Responsibility Principle, SRP) 2. 개방-폐쇄 원칙 (Open-Closed Principle, OCP) 3. 리스코프 치환 원칙 (Liskov Substitution Principle, LSP) 4. 인터페이스 분리 원칙 (Interface Segregation Principle, ISP) 5. 의존 역전 원칙 (Dependency Inversion Principle, DIP) 6. 공통 특성: 응집도를 높이거나 결합도를 낮추는 설계 1. 단일 책임 원칙 (Single Responsibility Principle, SRP) 정의 - 한 클래스는 하나의 책임만 가져야 하고 클래스가 변경되어야 할 이유는 오직 하나여야 한다. SRP 위반 예제 의문점 Employee 클래스가 3가지 역할을 동시에 하게되는게 문제가되는이유? - 기능이 섞여 있으면 한 영역을 고치면서 다른 영역에 코드 충돌 위험이 커진다. - 콘솔 대신 파일 출력으로 바꾸려고 printEmployeeInfo()를 수정했는데, 그 과정에서 calculatePay() 관련 필드를 잘못 건드려 급여 계산이 틀려버릴 수 있다 - 작은 변경에도 클래스 전체를 건드려야해서 유지보수성이 떨어진다. - 출력 로직 바꾸려고 Employee 클래스를 열면, 급여 계산과 데이터 관리 코드까지 다 보여서 코드 접근에 대한 불확실성이 커지고 불필요하게 큰리스크를 안게된다. - 결론 - 3가지 이유로 고친다고 해서 실행이 안되는 건 아니지만 실무에서는 한 클래스에는 하나의 책임만 부여하는 것이 장기적으로 안전하고 효율적이다. 2. 개방-폐쇄 원칙 (Open-Closed Principle, OCP) 정의 - 소프트웨어 요소(클래스, 모듈, 함수 등)는 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다. OCP 위반 예제 의문점 class AnimalSound에서 수정이 항상 따라온다는것의 의미? - - 새로운 동물이 추가될 때마다 기존에 이미 잘 동작하고 있던 AnimalSound 클래스의 코드를 바꿔야 한다. - 그러면 OCP의 핵심인 '새로운 기능은 추가할 수 있지만, 기존 기능은 그대로 두어야 한다'가 위배된다. - 새로운 동물을 추가해도 AnimalSound라는 기존 클래스의 내부 코드를 건드리지 않아도 되는 다음과 같은 형태여야한다. -> 이렇게 만들면 Horse 같은 새로운 동물이 추가되더라도 AnimalSound는 전혀 수정하지 않고 그대로 재사용할수있음. 3. 리스코프 치환 원칙 (Liskov Substitution Principle, LSP) 정의 - 자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 한다. - 상속 관계에서 부모 타입으로 선언된 객체 자리에 자식 객체를 넣어도 프로그램이 정상적으로 동작해야 한다. LSP 위반 예제 의문점 Bird bird2 = new Penguin();에서 펭귄 객체에 ‘인스턴스와 객체의 분리’가 어떻게 적용되는가? + 컴파일 시점 타입과 실행 시점 타입의 차이가 어떻게 LSP 위반으로 이어지는가? - 객체는 클래스라는 설계도로부터 생성된 실체. 즉 new Penguin()으로 생성된 펭귄. - 인스턴스는 어떤 클래스의 “구체적인 사례”라는 의미에서 바라본 객체. 즉 Penguin penguin = new Penguin();이면 penguin은? - "Penguin 클래스의 인스턴스"이자 동시에 "Bird 클래스의 인스턴스". - Penguin의 사례이자 Bird의 사례. - 모든 인스턴스는 객체이지만 객체를 어떤 타입 관점에서 바라보느냐에 따라 인스턴스라고 부른다. - Bird bird2 = new Penguin();에서 - 실제로 만들어진 것은 Penguin 객체이고 - 이 객체는 Penguin 클래스의 인스턴스임과 동시에 Penguin이 Bird를 상속했기 때문에 Bird 클래스의 인스턴스. 따라서 bird2라는 참조 변수는 Bird 타입을 기준으로 이 객체를 다룬다. 여기서 “타입은 Bird, 실제 객체는 Penguin” 이라는 분리가 발생한다. - 컴파일 vs 실행 - bird2 변수의 정적 타입(compile-time type) 은 Bird이므로 bird2.fly() 호출은 컴파일러가 허용한다. 하지만 실제 실행 시점(run-time type) 은 Penguin이므로 Penguin.fly() 가 실행되며 UnsupportedOperationException 처리된다 즉, Bird라는 부모 타입의 계약(fly() 가능하다) 은 Penguin 객체에서는 깨져버린다. - 결론 - 인스턴스와 객체의 분리는 "Bird 타입 인스턴스로서의 펭귄"이라는 다형성 상황을 만들어주지만 펭귄이 fly() 계약을 제대로 지키지 못하면서 LSP 위반이 발생했다. 4. 인터페이스 분리 원칙 (Interface Segregation Principle, ISP) 정의 - 하나의 범용적인 큰 인터페이스보다는 여러 개의 구체적이고 작은 인터페이스로 나누는 것이 좋다. ISP 위반 예제 5. 의존 역전 원칙 (Dependency Inversion Principle, DIP) 정의 - 고수준 모듈은 저수준 모듈에 의존하면 안 된다. - 상위 비즈니스 로직이 하위 세부 구현에 직접 묶이지 않고, 추상화(인터페이스)에 의존해야 한다. DIP 위반 예제 의문점 이 코드가 DIP를 위반하는 이유? (고수준 모듈 vs 저수준 모듈) - 의존 역전 원칙: 고수준 모듈은 저수준 모듈에 의존하지 말고, 둘 다 추상화에 의존해야 한다. - 고수준 모듈인 Car는 - “주행” = drive()이라는 목표만 있으면 되는데 new SnowTire()를 해 버리면서, 특정 부품인 스노우 타이어와 묶이게 됨 - 결론 - 이 코드가 DIP를 위반하는 이유는 고수준 모듈이 목적(drive())보다 수단(tire)에 자신을 종속시켜서. - Car은 ‘Tire 인터페이스’에만 의존하고 실제 어떤 타이어를 쓸지는 외부에서 주입(Dependency Injection)받아야 한다. “Car(고수준모듈)이 Tire 인터페이스에만 의존하고 실제 어떤 타이어를 쓸지는 외부에서 주입받아야 한다”의 의미? - Tire 인터페이스 - 타이어라면 반드시 roll() 기능을 제공해야 한다. - 타이어 - Tire 인터페이스를 지키면서 자기 방식대로 동작하는 타이어 (저수준 모듈/아래 코드에서 SnowTire, NormalTire) - Car(고수준모듈)이 Tire 인터페이스에만 의존해야한다: - 타이어 2종류: SnowTire, NormalTire - class Car에서 타이어 관련 코드를 보면 public Car(Tire tire) { // 외부에서 주입 this.tire = tire; } 니까 특정 타이어 종류랑 묶여있지 않음 - 실제 어떤 타이어를 쓸지를 외부에서 주입: - new Car(new SnowTire()) 에서 실제 어떤 타이어가 들어올지는 실행 시점에 외부에서 결정된다. - 그래서 Car는 본질적인 책임(주행)에만 집중할 수 있고 타이어의 종류가 바뀌어도 Car 클래스 자체는 수정할 필요가 없다. - 결론 - Car는 추상화(Tire 인터페이스)에만 의존하고, 구체적인 객체 생성과 선택은 외부(Main)에서 맡게 됨으로써 결합도를 낮추고 유연성을 확보한다. 6. 공통 특성: 응집도를 높이거나 결합도를 낮추는 설계 SOLID 객체지향 설계 원칙은 모듈 간 결합도는 낮추고 각 모듈 내부의 응집도는 높여서 일관성있고 유연한 구조를 만드는게 목적. - SRP (단일 책임 원칙): 클래스가 한 가지 책임만 가지게 해서 응집도를 높임. - OCP (개방-폐쇄 원칙): 확장에는 열려 있고 변경에는 닫혀 있게 해서 코드 변경 없이 새로운 기능을 붙일 수 있게 해서 응집도를 유지하면서 변화에 유연하게 설계. - LSP (리스코프 치환 원칙): 부모 타입을 대체할 수 있는 자식 타입을 보장해서 결합도를 낮추면서 일관성 있게 설계. - ISP (인터페이스 분리 원칙): 불필요한 의존성을 줄이고 필요한 인터페이스만 사용하게 해서 결합도를 낮추고 응집도를 높임. - DIP (의존 역전 원칙): 고수준 모듈과 저수준 모듈이 추상화에 의존하도록 해서 결합도를 낮추고 응집도를 강화.</a></p><hr><p><em>2025-09-02</em> ⋯ DBMS 및 SQL 활용 #5 Vector DB 스키마 설계</p><p style=height:4.5em;overflow:hidden><a href=/docs/study/be/be34/>1. 개념 KNN vs ANN KNN과 ANN의 공통 목적 - 질문을 하고 그 질문과 비슷한 질문이나 답변을 데이터베이스에서 찾기 구현 차이 - 모든 데이터를 하나하나 다 비교해서 가장 가까운 것을 찾는다(KNN) - 데이터 전체를 다 비교하지 않고 인덱스를 이용해서 후보군을좁혀서 그 안에서만 비교(ANN) - 친구가 수십만 명 있으면 모든 친구에게 질문을 던져서 과거 답변을 확인하는 대신 비슷한 취향을 가진 대표 그룹 몇 개를 빠르게 찾고 그 안에서만 가장 가까운 답을 고르는 방식. 그러면 인덱스는 비슷한취향그룹 찾는데만 쓰고 그룹 안에서는 knn인가? - 맞음 - 스텝(툴): 후보군 좁히기(ann) -> 후보군 내부 검색(knn 등) DB의 목적 일반적인 db는? - 숫자, 문자열 같은 정형화된 값을 행과 열로 저장하고 필터링과 조인을 수행해서 원하는 정보를 뽑아낸다. 원하는 정보 뽑아내기? - 조건에 맞는 행만 걸러내기 - ex) 나이가 20세 이상인 학생만 찾기 (`SELECT * FROM 학생 WHERE 나이 >= 20;`) - 서로 다른 테이블을 연결해서 더 풍부한 정보 만들기 - ex2) 학생 & 수강 테이블 조인을 통해 "홍길동 학생이 수강하는 과목 목록" 같은 테이블 만들기 (`SELECT 학생.이름, 수강.과목명` `FROM 학생` `JOIN 수강 ON 학생.학번 = 수강.학번;`) 일반적인 db와 벡터 db의 차이 일반적인 DB는 정확한 값을 기준으로한다. - 예를들면 학생 이름이 "홍길동"인 데이터를 찾고 싶다면 `WHERE 이름 = '홍길동'` 같은 조건을 써서 완전히 일치하는 값을 찾는다. - "값이 같은지 여부"라는 불(boolean) 논리에 기반해 검색과 조인을 수행. 벡터 db는 정확한값이 아니라 "얼마나 비슷한가"라는 정도를 계산한다. - "얼마나 비슷한가" 기준? - 벡터 간 distance 또는 similarity - 텍스트, 이미지, 오디오 같은 데이터는 숫자 하나로 일치 여부를 판별할 수 없기 때문에 임베딩을 통해 벡터 공간에 투영한 뒤 그 벡터가 서로 얼마나 가까운지를 측정한다. - 예를들면 "강아지"라는 단어를 검색했을 때 정확히 "강아지"라는 텍스트만 주는 게 아니라 "개", "강쥐", "멍멍이" 같은 비슷한 개념을 함께 찾아줄수있다. 메타데이터 벡터 검색만 하면 - 비슷한 벡터를 찾아줄 뿐 의미는 알려주지못함. - 비슷한 벡터를 찾을때 모두 가져올 뿐 날짜 등 필터링은 못함. 메타데이터가 있으면 - 사용자가 입력한 텍스트와 비슷한 문서를 벡터 검색으로 찾고 그 문서의 제목·저자·링크 같은 메타데이터를 함께 보여줄수있다 - 벡터 유사도로 후보를 먼저 고른 뒤 메타데이터로 Query Filtering을 하면 사용자가 원하는 결과를 정확히 얻을 수 있다. 동적 업데이트 -> 데이터가 계속 들어오거나 수정될때를 고려 Incremental Indexing(점진적 인덱싱) - HNSW - 그래프기반 인덱스 구조 - 데이터가 노드, 비슷하면 엣지가있음 - 새로운벡터가 들어오면 그벡터가 노드가 됨 즉 새로운 데이터(벡터)가 들어와도 기존 그래프(인덱스)가 유지돼서 데이터가 계속들어와도 검색 성능이 떨어지지 않으면서 반영된다. Lazy Update(지연 업데이트) - 새로운벡터가 들어와도 즉시 반영하지않고 일정 시간이 지나면 한꺼번에 인덱스에 반영 - 자원을효율적으로 쓸수있다. Delete & Rebuild(삭제후 재구성) - 시간이 지나면 쓸모없는 데이터가 쌓이기때문에 일정 시간이 지나면 불필요한 벡터는 지우고 인덱스를 재정리해서 최적화해야 검색 속도가 유지되고 공간 낭비를 막을수있다. 결론 - 평소에는 Incremental Indexing과 Lazy Update로 작은 변화들을 처리하다가 주기적으로 Delete & Rebuild를 해서 전체 구조를 최적화한다. Chunking(청킹) 모델은 한 번에 처리할 수 있는 길이에 제한이 있고 긴 텍스트를 그대로 벡터화하면 중요한 부분이 묻힌다. - 그래서 청킹해서 데이터를 자른다 고정 크기 방식 (Fixed Size Chunking) - 1,000자짜리 문서를 200자로 잘라 5개로 만들기. - 간단하고 구현이 빠른데, 문장이 잘리거나 의미가 끊길 수 있다. 의미 기반 방식 (Semantic Chunking) - 단순히 길이가 아니라 내용의 의미 단위 즉 문단, 주제, 혹은 문맥이 바뀌는 지점에서 나눈다. 덩어리 하나가 온전한 의미를 담고 있어 검색이나 답변 생성에서 품질이 좋아진다. 중첩 방식 (Overlapping Chunking) - 데이터를 자를 때 앞 조각과 뒤 조각이 일부 겹치도록 하는 방식, 예를 들어 200자 단위로 자르되 다음 청크는 앞에서 50자를 다시 포함시키는데 이렇게 하면 문맥이 잘려 나가는 문제를 줄일 수 있다. 요약 기반 방식 (Summarization Chunking) - 긴 텍스트를 직접 다루기 힘들 때, 아예 요약을 해서 작은 덩어리로 줄여서 검색할 때는 요약된 덩어리만쓰는건데 검색 속도가 빨라지고 컨텍스트 길이를 절약할 수 있지만 요약 과정에서 중요한 세부 정보가 사라질 수 있다. 계층적 방식 (Hierarchical Chunking) - 텍스트를 먼저 큰 단위(챕터)로 나누고, 그 안에서 절, 문단 단위로 세분화한다. - "문단 단위로 세분화" - 1장 2장으로 나누고 1장을 1.1, 1.2절로 나누고 1.1절을 첫번재문단 두번째문단 일케 나눈다. - 문단만 최종 결과물인게 아니고 1장 같은 큰 단위도 쓰고 1.1절 같은 중간 단위도쓰고 문단 같은 작은 단위도 쓰므로 따로따로 결과물로 저장한다.</a></p><hr><p><em>2025-09-01</em> ⋯ Java #1 객체지향 프로그래밍: 캡슐화, 추상화, 다형성, 상속</p><p style=height:4.5em;overflow:hidden><a href=/docs/study/fe/fe20/>목차 1. 캡슐화 2. 추상화 3. 다형성 4. 상속 5. 공통 특성: 인터페이스와 구현의 분리 1. 캡슐화 개념 및 목적 - 개념 - 객체지향 프로그래밍에서 객체의 속성(필드)을 외부로부터 숨기고, 공개된 메서드(getter/setter)를 통해서만 접근하도록 만드는 원칙 - 필드를 private으로 선언하고, 외부에서 직접 접근하지 못하게 제한하고, public 메서드인 getter와 setter를 제공해 값을 읽거나 수정할 수 있도록 한다. setter 내부에는 유효성 검사 로직을 넣어 잘못된 값이 들어오는 것을 막을 수도 있다. - 목적 1. 데이터 보호: 잘못된 값이 직접 들어가는 것을 막고, setter 내부에서 규칙을 강제함으로써 객체의 상태를 안정적으로 유지 2. 정보 은닉: 내부 구현이 어떻게 되어 있는지는 숨겨 두고, 외부에는 단순한 사용 방법만 제공함으로써 객체 사용자가 불필요한 복잡성을 신경 쓰지 않도록 한다. 3. 유지보수와 확장성: 내부 로직이 바뀌더라도 외부 인터페이스(getter/setter)가 같으면 사용하는 코드는 수정할 필요가 없으므로 프로그램 전체의 안정성이 높아지고 유지보수가 쉬워진다. 샘플 코드 class Stock - private String name; - 주식의 이름(예: "스칼라 AI") - private이기 때문에 클래스 외부에서는 s1.name처럼 직접 접근 불가 - private double price; - 주식의 가격을 저장하는 변수 - private이기 때문에 클래스 외부에서는 직접 접근 불가 - public Stock - this.name = name; - 생성 시 입력된 이름을 객체의 name 에 저장 - setPrice(price); - 가격은 바로 대입하지 않고 setPrice() 메서드를 통해 저장 - Getter - getName(): 주식 이름 - getPrice(): 주식 가격 - Setter - if (price > 0): 유효성 검사 - 올바른 가격(0보다 큰 수)이면 저장, 잘못된 값이면 거부하고 메시지를 출력하기. public class EncapsulationExample - public static void main(String[] args) - Stock 객체를 실제로 만들어서 테스트하는 클래스. - Stock s1 = new Stock("스칼라 AI", 17000); - "스칼라 AI"라는 이름과 17000이라는 가격으로 객체 생성. - 생성자 내부에서 setPrice(17000)이 호출되므로 유효성 검사가 통과되므로 저장된다. - System.out.println(s1.getName() + " 현재가: " + s1.getPrice()); - getName()과 getPrice()로 값을 출력 - s1.setPrice(18000); - setter를 통한 가격 변경 - setPrice(18000)은 유효성 검사를 통과하므로 price가 18000으로 업데이트된다. - setPrice(-5000) - setter 내부 조건문이 거부예정. - "잘못된 가격: -5000" 메시지만 출력되고, price 값은 바뀌지 않고, getPrice()로 확인하면 여전히 이전 값 18000이 유지된다. 의문점 캡슐화의 의미? - 중요한 데이터는 직접 노출하지 않고 private으로 은닉하며, getter/setter 같은 메서드를 통해서만 접근하도록 만들기. `this.price = price;` 하지않고 `setPrice(price)` 한 이유? - 이 값이 올바른지 아닌지 검사하는 로직을 넣기위해서. - 생성자에서 this.price = price;를 바로 쓰면 잘못된 값도 그대로 들어와 버릴 수 있다. 예를 들어 new Stock("삼성", -1000) 같은 유효하지않은 객체가 생성될수있는데 setPrice(price);를 쓰면 생성되는 순간에 그 값이 유효한지 검사하고 잘못된 값은 차단할 수 있다. - 결론 - 생성자 안에서 직접 대입하지 않고 setter를 호출하면 내부 로직이 항상 같은 규칙을 따르게 함으로써 어디서 값을 넣든지 간에 일관성과 안전성이 유지된다. 2. 추상화 개념 및 목적 - 개념 - 객체지향 프로그래밍에서 복잡한 시스템을 단순화하기 위해 핵심적인 개념과 동작만 남기고 불필요한 세부사항을 감추는 원칙 - 추상 클래스와 인터페이스 - 추상 클래스: 공통된 속성과 기본 동작을 정의하면서, 일부 메서드를 추상 메서드로 남겨 자식 클래스가 반드시 구현하도록 한다. - 인터페이스: 특정 기능에 대한 규약을 정의하며, 이를 구현하는 클래스가 해당 메서드를 구체적으로 작성하도록 강제한다. - 목적 1. 복잡성 단순화: 사용자나 개발자는 내부의 복잡한 구조를 알 필요 없이, 제공되는 메서드 시그니처만 보고 객체를 사용할 수 있다. 2. 코드의 유연성과 유지보수성 향상: 외부에서 바라보는 표면(메서드 선언)만 일정하게 유지하면 내부 구현은 자유롭게 변경하거나 최적화할 수 있다. 3. 일관성과 확장성 확보: 추상 클래스는 공통 뼈대를 재사용하게 해주고, 인터페이스는 다양한 클래스들이 동일한 규약을 따르도록 만들어 여러 객체를 일관된 방식으로 다룰 수 있게 한다. 이를 통해 협업과 테스트가 쉬워지고, 새로운 기능 확장이 용이해진다. 샘플 코드 추상 클래스 Asset - abstract class Asset - 추상 클래스 정의 - protected String name, protected double price - name, price 필드 - protected 접근제어자 사용해서 같은 패키지 내부와 자식 클래스에서만 접근 가능하게한다. - public Asset(String name, double price) {this.name = name; this.price = price;} - name과 price를 초기화 - public abstract void printInfo(); - printInfo()는 추상 메서드로 선언되어 있고 구현은 없다. - sset을 상속받는 자식 클래스들은 반드시 printInfo()를 구현해야한다 즉 Asset은 "공통 자산"이라는 추상적인 개념만 정의하고 구체적인 세부 내용은 자식 클래스에서 맡기는 구조. 인터페이스 Valuable - interface Valuable - 객체가 가져야 할 행동 규약 - void printInfo(); - 선언만 되어 있고 구현은 없음. 인터페이스를 구현하는 클래스는 반드시 이 메서드를 작성해야한다. - default void updatePrice(double price) {System.out.println("가격을 " + price + "원으로 업데이트했습니다.");} - 기본 구현: “가격을 업데이트했습니다”라는 메시지를 출력하기. Stock 클래스 - class Stock extends Asset implements Valuable - 추상 클래스 Asset을 상속하고 인터페이스 Valuable을 구현한다. - public Stock(String name, double price) {super(name, price);} - 생성자가 부모 클래스 Asset의 생성자를 호출해 name, price를 초기화한다. - @Override public void printInfo() - printInfo() 메서드를 오버라이딩하여 일반주 종목 정보를 출력. PreferredStock 클래스 - PreferredStock extends Asset implements Valuable - `Asset`을 상속, `Valuable`을 구현. - private double dividendRate; - 추가로 `dividendRate`(배당률)라는 필드를 가짐. - public PreferredStock(String name, double price, double dividendRate) {super(name, price); this.dividendRate = dividendRate; } - 생성자를 통해 `name`, `price`, `dividendRate`를 초기화. - @Override public void printInfo() - `printInfo()`를 오버라이딩하여 우선주의 정보(배당률 포함)를 출력하기. 의문점 Asset, Valuable의 Stock으로의 흐름과 Asset, Valuable의 PreferredStock으로의 흐름? - 추상 클래스 Asset - “모든 자산이라면 name과 price를 가져야 하며, 자신을 소개하는 방법인 printInfo() 메서드를 반드시 가져야 한다”라는 기본 골격을 생성하고 printInfo()를 선언만 해둔다. - 인터페이스 Valuable - “가치 있는 자산이라면 반드시 printInfo()를 구현해야 한다”라는 규약을 정의하고, 추가로 updatePrice(double price)라는 기본 기능을 메뉴얼에 적어둔다. - Stock 클래스 1. Asset을 상속받아서 name과 price 필드를 물려받음 2. printInfo()를 구현하면서 “나는 일반주이고, 종목명은 name, 현재가는 price원이다”라는 구체적인 출력 내용을 정의 3. 동시에 Valuable 인터페이스를 구현 4. 규약을 확인해보니 printInfo()는 이미 Asset에서 추상 메서드로 선언되어 있었고, Stock이 그것을 구체적으로 작성했으므로 인터페이스 규약을 만족 5. Valuable 인터페이스를 구현했으므로 printInfo()와 updatePrice(double price) 메서드를 사용할 수 있음 6. 결국 Asset에서 내려온 골격(name, price, printInfo())과 Valuable에서 정한 규칙 및 기능(printInfo(), updatePrice(double price))이 Stock 클래스 안에서 결합됨 - PreferredStock 클래스 1. Asset을 상속받아 기본 필드인 name과 price를 물려받고, printInfo를 구현 2. 일반주와는 다르게 배당률이라는 고유한 특징이 있으므로 새로운 필드 dividendRate를 추가. 3. printInfo에서는 이름, 가격과 함께 배당률도 출력. - 결론 - Asset이 제공하는 공통 골격(name, price, printInfo())과 Valuable이 정한 규약(printInfo()) 및 기능(updatePrice(double price))이 Stock과 PreferredStock에 각각 결합되어 Stock은 일반주로서 name과 price를 출력하고 PreferredStock은 여기에 dividendRate를 더해 고유 특성을 반영한다. 3. 다형성 개념 및 목적 - 개념 - 객체지향 프로그래밍에서 하나의 타입으로 여러 형태의 동작을 표현 즉 같은 이름의 메서드를 호출하더라도 객체의 실제 타입에 따라 실행되는 동작이 달라지는 특성 - 이를 가능하게 하는 조건은 상속과 메서드 오버라이딩으로 구현되고 보통 업캐스팅과 함께 활용된다. - 부모 클래스 타입의 참조 변수를 통해 메서드를 호출하면, 실행 시점에는 실제 객체 타입에 맞는 오버라이딩된 메서드가 실행된다. - 목적 - 코드의 유연성 확보: 하나의 부모 타입으로 여러 자식 객체를 다룰 수 있기 때문에, 코드 구조를 단순하게 유지하면서 다양한 객체를 일관된 방식으로 처리할 수 있어서 새로운 자식 클래스가 추가되더라도 기존 코드를 거의 수정하지 않고 확장이 가능하다. 샘플 코드 Stock - class Stock - 주식 개념 부모 클래스 - protected String name; protected double price; - 주식의 이름과 가격을 저장하는 필드(멤버 변수) - protected - 같은 패키지 내부나 상속받은 자식 클래스에서 접근 가능하다. 외부에서는 직접 접근 불가하다. - `public Stock(String name, double price)` - 생성자(Constructor) - `name`과 `price`를 받아 초기화 - `public void printInfo()` - 주식 정보를 출력 - System.out.println("[일반주] 종목: " + name + ", 가격: " + price + "원"); - “일반주”라고 표시하고 종목명과 가격을 보여준다 - 자식 클래스에서 오버라이딩 대상인 메서드 PreferredStock - class PreferredStock extends Stock - Stock을 상속받은 자식 클래스. - 상속을 통해 name과 price를 물려받았는데 배당률(dividendRate)이라는 속성을 추가하여 “우선주”를 구체화함. - super(name, price); - 부모 클래스의 생성자를 호출 - @Override public void printInfo() - 부모 클래스 printInfo()를 오버라이딩 - 실행 시점에는 동적 바인딩에 의해, 객체의 실제 타입이 PreferredStock이면 이 메서드가 실행된다. - public void showDividend() - 자식 클래스에만 있는 메서드. 배당률을 따로 출력하는 기능. - 부모 타입 변수로는 접근할 수 없고, 자식 타입으로 다운캐스팅해야 호출할 수 있다. 의문점 “@Override public void printInfo()를 오버라이딩하면 실행 시점에 객체의 실제 타입에 맞는 메서드가 호출된다”의 의미? - @Override public void printInfo()를 오버라이딩? - 부모 Stock에는 printInfo()가 있는데 자식 PreferredStock이 똑같은 메서드 시그니처(메서드 이름, 매개변수 목록, 반환형이 동일)로 다시 정의하면 그게 오버라이딩. - printInfo() 실행 시점에 객체의 실제 타입에 맞는 메서드가 호출된다? - printInfo()같은 인스턴스 메서드는 2단계로 처리되는데 1. 메서드 호출 - 컴파일러는? 변수의 선언 타입을 보고 “이 메서드를 불러도 되는지” 확인한다. - Stock s = new PreferredStock(...) 일때 s.printInfo(); 하면 s가 Stock 타입이니까, Stock 클래스에 printInfo()가 있는지만 확인한다. 2. 실제 구현 - JVM은? 실제 객체가 누구인지 확인하는데 - 지금 s가 참조하는 건 Stock이 아니라 PreferredStock 객체니까 “PreferredStock에 printInfo()가 오버라이딩돼 있네? 그럼 이걸 실행해야겠다.” 하고 결정한다. - 결론 - printInfo() 호출하면 컴파일러는 변수선언을 보고 s가 Stock 타입이고 Stock 안에 printInfo() 있으니까 호출 승인하고, 어떤 버전의 printInfo()가 실행될지는 아직 정해지지 않았고, JVM이 객체를 확인했을때 Stock객체라면 부모 클래스 버전 `printInfo`()이 실행, PreferredStock이라면 그 클래스에서 정의된`printInfo`()를 실행한다. 동적 바인딩? - 실행할 때 객체의 실제 타입을 보고 그에 맞는 메서드를 선택하는게 동적 바인딩. (s라는 변수가 Stock 타입으로 선언되어 있어도, new PreferredStock(...)로 만든 객체를 가리키고 있다면 자식 쪽에 오버라이딩된 메서드가 실행됨) 4. 상속 1. 개념 및 목적 - 개념 - 기존(부모) 클래스가 가진 속성과 메서드를 새로운(자식) 클래스가 계승하여 활용할 수 있도록 하는 개념 - 자식 클래스는 부모 클래스가 정의한 필드와 메서드를 직접 사용할 수 있다. - 필요에 따라 새로운 속성과 기능을 추가하거나, 부모 메서드를 오버라이딩(Overriding)하여 구체적인 동작을 재정의할 수 있고 - 이를 통해 자식 클래스는 부모 클래스가 제공하는 공통 기능을 기반으로 기본 구조와 일관성을 유지하면서도, 고유한 특성과 요구 사항을 반영하여 더욱 구체적이고 특화된 클래스로 확장될 수 있다. - 목적 1. 코드 재사용성: 부모 클래스에 정의된 공통 속성과 기능을 여러 자식 클래스에서 공유할 수 있어, 중복 코드를 줄이고 전체 코드 구조를 간결하게 만든다. 2. 유지보수성과 확장성: 공통 로직은 부모 클래스에만 수정하면 되고, 자식 클래스는 필요에 따라 기능을 덧붙이거나 오버라이딩을 통해 동작을 변경할 수 있어 유지보수가 쉽고 새로운 기능 추가도 용이하다. 3. 다형성 기반 마련: 부모 타입으로 자식 객체를 다룰 수 있고, 실행 시점에는 실제 객체의 타입에 맞는 동작이 수행되므로 유연한 구조를 만들 수 있다. 2. 샘플 코드 부모 클래스 Stock - class Stock - 주식 개념 부모 클래스 - protected String name; protected double price; - 주식의 이름과 가격을 저장하는 필드(멤버 변수) - protected - 같은 패키지 내부나 상속받은 자식 클래스에서 접근 가능하다. 외부에서는 직접 접근 불가하다. - `public Stock(String name, double price)` - 생성자(Constructor) - `name`과 `price`를 받아 초기화 - `public void printInfo()` - 주식 정보를 출력 - System.out.println("[일반주] 종목: " + name + ", 가격: " + price + "원"); - “일반주”라고 표시하고 종목명과 가격을 보여준다 - 자식 클래스에서 오버라이딩 대상인 메서드 자식 클래스 PreferredStock - class PreferredStock extends Stock - Stock을 상속받은 자식 클래스. - 상속을 통해 name과 price를 물려받았는데 배당률(dividendRate)이라는 속성을 추가하여 “우선주”를 구체화함. - super(name, price); - 부모 클래스의 생성자를 호출 - @Override public void printInfo() - 부모 클래스 printInfo()를 오버라이딩 - 실행 시점에는 동적 바인딩에 의해, 객체의 실제 타입이 PreferredStock이면 이 메서드가 실행된다. - public void showDividend() - 자식 클래스에만 있는 메서드. 배당률을 따로 출력하는 기능. - 부모 타입 변수로는 접근할 수 없고, 자식 타입으로 다운캐스팅해야 호출할 수 있다. 의문점 그래서 업캐스팅과 다운캐스팅이 어떻게적용되는가? - 업캐스팅 - 자식 객체를 부모 타입 변수에 담는것 - PreferredStock이 Stock을 상속받는 상황에서 Stock stock = new PreferredStock(...);처럼 쓰면 실제 객체는 PreferredStock이지만 참조 변수의 타입을 Stock으로 지정했기 때문에 컴파일러는 이 객체를 부모 클래스 객체 형식으로 인지한다. - 실행 시점에 stock.printInfo()를 호출하면 실제 객체가 PreferredStock이므로 자식이 오버라이딩한 메서드가 실행된다. 핵심은 부모객체처럼 인지되면서도 실제동작은 자식클래스의 성질이 반영된다. - 업캐스팅 하는이유? - 여러 종류의 자식 클래스를 일괄적으로 묶어서 처리할수있기때문에 코드가 단순해진다. - 다운캐스팅 - 부모 타입 변수에 들어 있는 객체를 다시 자식 타입 변수로 변환하는것. - Stock stock이라는 부모 타입 참조가 있지만, 실제 객체가 PreferredStock이라면 (PreferredStock) stock으로 형변환을 거치면 자식 타입 변수로 다룰수있다 즉 자식만이 가진 고유한 메서드 showDividend() 를 호출할수있다. - 결론 - 상속 구조에서는 같은 객체를 필요에 따라 업캐스팅 ↔ 다운캐스팅으로 부모 클래스 ↔ 자식 클래스로 바꿔 다루면서 공통성과 특수성을 효율적으로 반영할수있다. 5. 공통 특성: 인터페이스와 구현의 분리 - 캡슐화, 추상화, 다형성, 상속은 결국 인터페이스와 구현이 분리되는걸 활용하는게 포인트인것같은데 인터페이스와 구현의 분리가 각각 어떻게 활용되었는가? - 캡슐화 - 데이터(구현)를 숨기고 메서드(인터페이스)만 공개 - 추상화 - “무엇을 할 수 있는가”(인터페이스)와 “어떻게 할 것인가”(구현)를 분리 - 다형성 - 부모의 틀(인터페이스)은 유지하면서, 자식에서 구체 구현을 다양하게 정의 - 상속 - 호출하는 쪽은 부모 타입(인터페이스)만 보고, 실행되는 쪽은 실제 객체의 구현을 따른다.</a></p><hr><div class=pagination style=margin-top:2rem;display:flex;justify-content:center;align-items:center;gap:1rem><a href=/tags/2025-09/ style="padding:.5rem 1rem;text-decoration:none">←</a>
<span style=color:#666>2 / 2</span></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents></nav></div></aside></main></body></html>